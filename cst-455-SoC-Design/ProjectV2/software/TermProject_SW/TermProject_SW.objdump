
TermProject_SW.elf:     file format elf32-littlenios2
TermProject_SW.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x04000248

Program Header:
    LOAD off    0x00001000 vaddr 0x04000000 paddr 0x04000000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x04000020 paddr 0x04000020 align 2**12
         filesz 0x0000822c memsz 0x0000822c flags r-x
    LOAD off    0x0000924c vaddr 0x0400824c paddr 0x040098a8 align 2**12
         filesz 0x0000165c memsz 0x0000165c flags rw-
    LOAD off    0x0000af04 vaddr 0x0400af04 paddr 0x0400af04 align 2**12
         filesz 0x00000000 memsz 0x00800234 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  04000000  04000000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000228  04000020  04000020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00007fb8  04000248  04000248  00001248  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       0000004c  04008200  04008200  00009200  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       0000165c  0400824c  040098a8  0000924c  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          008002b0  0400af04  0400af04  0000af04  2**2
                  ALLOC, SMALL_DATA
  6 .sdram        00000000  0480b138  0480b138  0000a8a8  2**0
                  CONTENTS
  7 .comment      0000002c  00000000  00000000  0000a8a8  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00000678  00000000  00000000  0000a8d8  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   00023210  00000000  00000000  0000af50  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00006d89  00000000  00000000  0002e160  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   000087ba  00000000  00000000  00034ee9  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  00001f24  00000000  00000000  0003d6a4  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00003394  00000000  00000000  0003f5c8  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    000009b4  00000000  00000000  0004295c  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_alt_sim_info 00000030  00000000  00000000  00043310  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 00000150  00000000  00000000  00043340  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .thread_model 00000003  00000000  00000000  000466d4  2**0
                  CONTENTS, READONLY
 18 .cpu          0000000c  00000000  00000000  000466d7  2**0
                  CONTENTS, READONLY
 19 .qsys         00000001  00000000  00000000  000466e3  2**0
                  CONTENTS, READONLY
 20 .simulation_enabled 00000001  00000000  00000000  000466e4  2**0
                  CONTENTS, READONLY
 21 .stderr_dev   0000000b  00000000  00000000  000466e5  2**0
                  CONTENTS, READONLY
 22 .stdin_dev    0000000b  00000000  00000000  000466f0  2**0
                  CONTENTS, READONLY
 23 .stdout_dev   0000000b  00000000  00000000  000466fb  2**0
                  CONTENTS, READONLY
 24 .sopc_system_name 00000008  00000000  00000000  00046706  2**0
                  CONTENTS, READONLY
 25 .quartus_project_dir 0000001b  00000000  00000000  0004670e  2**0
                  CONTENTS, READONLY
 26 .jdi          00004de6  00000000  00000000  00046729  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
04000000 l    d  .entry	00000000 .entry
04000020 l    d  .exceptions	00000000 .exceptions
04000248 l    d  .text	00000000 .text
04008200 l    d  .rodata	00000000 .rodata
0400824c l    d  .rwdata	00000000 .rwdata
0400af04 l    d  .bss	00000000 .bss
0480b138 l    d  .sdram	00000000 .sdram
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 D:/College/CST455/ProjectV2/software/TermProject_SW_bsp/obj/HAL/src/crt0.o
04000290 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 obj/default/FreeRTOS/portable/GCC/NiosII/port_asm.o
04000020 l       .exceptions	00000000 save_context
0400009c l       .exceptions	00000000 save_sp_to_pxCurrentTCB
040000ac l       .exceptions	00000000 hw_irq_test
04000150 l       .exceptions	00000000 soft_exceptions
040000c0 l       .exceptions	00000000 hw_irq_handler
040000d4 l       .exceptions	00000000 restore_context
0400016c l       .exceptions	00000000 call_scheduler
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 port.c
04000294 l     F .text	0000002c prvReadGp
040003f8 l     F .text	00000088 prvSetupTimerInterrupt
00000000 l    df *ABS*	00000000 heap_1.c
0400af70 l     O .bss	00800000 ucHeap
0400af04 l     O .bss	00000004 xNextFreeByte
0400af08 l     O .bss	00000004 pucAlignedHeap.2598
00000000 l    df *ABS*	00000000 croutine.c
00000000 l    df *ABS*	00000000 event_groups.c
04000df8 l     F .text	00000070 prvTestWaitCondition
00000000 l    df *ABS*	00000000 list.c
00000000 l    df *ABS*	00000000 queue.c
040012a4 l     F .text	00000084 prvInitialiseNewQueue
04001328 l     F .text	00000060 prvInitialiseMutex
0400210c l     F .text	0000018c prvCopyDataToQueue
040024c0 l     F .text	00000058 prvIsQueueFull
04002334 l     F .text	000000f4 prvUnlockQueue
04002298 l     F .text	0000009c prvCopyDataFromQueue
04002428 l     F .text	00000050 prvIsQueueEmpty
040020bc l     F .text	00000050 prvGetDisinheritPriorityAfterTimeout
00000000 l    df *ABS*	00000000 stream_buffer.c
04003418 l     F .text	00000080 prvInitialiseNewStreamBuffer
040033a4 l     F .text	00000074 prvBytesInBuffer
04002b30 l     F .text	000000d4 prvWriteMessageToBuffer
0400319c l     F .text	000000f4 prvWriteBytesToBuffer
04002efc l     F .text	000000bc prvReadMessageFromBuffer
04003290 l     F .text	00000114 prvReadBytesFromBuffer
00000000 l    df *ABS*	00000000 tasks.c
0480af70 l     O .bss	00000064 pxReadyTasksLists
0480afd4 l     O .bss	00000014 xDelayedTaskList1
0480afe8 l     O .bss	00000014 xDelayedTaskList2
0400af10 l     O .bss	00000004 pxDelayedTaskList
0400af14 l     O .bss	00000004 pxOverflowDelayedTaskList
0480affc l     O .bss	00000014 xPendingReadyList
0480b010 l     O .bss	00000014 xTasksWaitingTermination
0400af18 l     O .bss	00000004 uxDeletedTasksWaitingCleanUp
0480b024 l     O .bss	00000014 xSuspendedTaskList
0400af1c l     O .bss	00000004 uxCurrentNumberOfTasks
0400af20 l     O .bss	00000004 xTickCount
0400af24 l     O .bss	00000004 uxTopReadyPriority
0400af28 l     O .bss	00000004 xSchedulerRunning
0400af2c l     O .bss	00000004 xPendedTicks
0400af30 l     O .bss	00000004 xYieldPending
0400af34 l     O .bss	00000004 xNumOfOverflows
0400af38 l     O .bss	00000004 uxTaskNumber
0400af3c l     O .bss	00000004 xNextTaskUnblockTime
0400af40 l     O .bss	00000004 xIdleTaskHandle
0400af44 l     O .bss	00000004 uxSchedulerSuspended
0400357c l     F .text	000001f8 prvInitialiseNewTask
04003774 l     F .text	000000fc prvAddNewTaskToReadyList
04004a1c l     F .text	000000b8 prvInitialiseTaskLists
04004c18 l     F .text	00000044 prvDeleteTCB
04004c5c l     F .text	00000048 prvResetNextTaskUnblockTime
04005af8 l     F .text	000000e8 prvAddCurrentTaskToDelayedList
04003e10 l     F .text	0000006c prvTaskIsTaskSuspended
04004a00 l     F .text	0000001c prvIdleTask
04004ad4 l     F .text	00000080 prvCheckTasksWaitingTermination
04004b54 l     F .text	00000064 prvTaskCheckFreeStackSpace
00000000 l    df *ABS*	00000000 timers.c
00000000 l    df *ABS*	00000000 hello_world.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_load.c
04006424 l     F .text	00000068 alt_load_section
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
0400658c l     F .text	00000034 alt_dev_reg
0400824c l     O .rwdata	00001060 jtag_uart_0
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
04006874 l     F .text	00000210 altera_avalon_jtag_uart_irq
04006a84 l     F .text	000000a0 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
040070c8 l     F .text	00000080 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_close.c
040072f8 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
04007450 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
0400747c l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
0400765c l     F .text	000000b0 alt_open_fd
00000000 l    df *ABS*	00000000 alt_open.c
04007788 l     F .text	0000003c alt_get_errno
040077c4 l     F .text	000000b8 alt_file_locked
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 impure.c
04009454 l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
04006510 g     F .text	0000007c alt_main
0400612c g     F .text	000000dc ServoControl
0480b038 g     O .bss	00000100 alt_irq
040000c4 g       .exceptions	00000000 restore_sp_from_pxCurrentTCB
04004648 g     F .text	00000064 vTaskPlaceOnUnorderedEventList
0400073c g     F .text	0000002c xPortGetFreeHeapSize
04000b50 g     F .text	0000003c xEventGroupGetBitsFromISR
040098a8 g       *ABS*	00000000 __flash_rwdata_start
04003aa4 g     F .text	00000058 uxTaskPriorityGet
04002c04 g     F .text	00000168 xStreamBufferReceive
040007bc g     F .text	00000184 xEventGroupSync
0400af48 g     O .bss	00000004 Overflows
04005a4c g     F .text	000000ac ulTaskGenericNotifyValueClear
04005048 g     F .text	00000054 vTaskEnterCritical
0400171c g     F .text	000000f4 xQueueGenericSendFromISR
040042f0 g     F .text	00000040 pcTaskGetName
04005ce0 g     F .text	00000074 timer_2_ISR
04002780 g     F .text	00000088 xStreamBufferSpacesAvailable
04007bd4 g     F .text	00000024 altera_nios2_gen2_irq_init
04002678 g     F .text	0000009c xStreamBufferReset
04000000 g     F .entry	0000001c __reset
040013e4 g     F .text	00000090 xQueueGiveMutexRecursive
0400af0c g     O .bss	00000004 pxCurrentTCB
04000020 g       *ABS*	00000000 __flash_exceptions_start
0400af6c g     O .bss	00000004 errno
04002a3c g     F .text	000000f4 xStreamBufferSendFromISR
0400af5c g     O .bss	00000004 alt_argv
04011878 g       *ABS*	00000000 _gp
04003b48 g     F .text	000001a4 vTaskPrioritySet
040048b4 g     F .text	0000003c vTaskInternalSetTimeOutState
04000940 g     F .text	000001a8 xEventGroupWaitBits
040092d4 g     O .rwdata	00000180 alt_fd_list
040003a0 g     F .text	00000038 xPortStartScheduler
040040b8 g     F .text	00000048 vTaskEndScheduler
04007bf8 g     F .text	00000090 alt_find_dev
04006234 g     F .text	00000100 memcpy
040045f8 g     F .text	00000050 vTaskPlaceOnEventList
040047a0 g     F .text	000000c8 vTaskRemoveFromUnorderedEventList
0400770c g     F .text	0000007c alt_io_redirect
04001f38 g     F .text	0000007c xQueuePeekFromISR
04008200 g       *ABS*	00000000 __DTOR_END__
04005ec4 g     F .text	000000fc Switch
040006f4 g     F .text	00000024 vPortFree
04001a94 g     F .text	00000210 xQueueSemaphoreTake
04005c60 g     F .text	00000080 timer_1_ISR
04006c80 g     F .text	00000220 altera_avalon_jtag_uart_read
04004bb8 g     F .text	00000060 uxTaskGetStackHighWaterMark
04000efc g     F .text	0000008c vListInsertEnd
04007e30 g     F .text	00000090 alt_icache_flush
0400517c g     F .text	00000104 ulTaskGenericNotifyTake
04000768 g     F .text	00000054 xEventGroupCreate
04000d80 g     F .text	0000003c vEventGroupSetBitsCallback
04003f48 g     F .text	000000e0 xTaskResumeFromISR
04000ed0 g     F .text	0000002c vListInitialiseItem
04009890 g     O .rwdata	00000004 alt_max_fd
04000480 g     F .text	00000048 vPortSysTickHandler
040018ec g     F .text	000001a8 xQueueReceive
04003afc g     F .text	0000004c uxTaskPriorityGetFromISR
040004c8 g     F .text	0000016c alt_irq_register
040098a0 g     O .rwdata	00000004 _global_impure_ptr
04000b8c g     F .text	00000180 xEventGroupSetBits
0480b138 g       *ABS*	00000000 __bss_end
04007acc g     F .text	00000108 alt_tick
04000634 g     F .text	000000c0 pvPortMalloc
04002080 g     F .text	0000003c vQueueDelete
040003d8 g     F .text	00000020 vPortEndScheduler
04000e68 g     F .text	00000068 vListInitialise
04002fb8 g     F .text	00000058 xStreamBufferIsEmpty
04007a28 g     F .text	000000a4 alt_alarm_stop
0400af54 g     O .bss	00000004 alt_irq_active
0400017c g     F .exceptions	000000cc alt_irq_handler
040092ac g     O .rwdata	00000028 alt_dev_null
0400427c g     F .text	00000028 xTaskGetTickCount
04001568 g     F .text	000001b4 xQueueGenericSend
04002848 g     F .text	000001f4 xStreamBufferSend
04003114 g     F .text	00000088 xStreamBufferReceiveCompletedFromISR
04007404 g     F .text	0000004c alt_dcache_flush_all
0400586c g     F .text	00000154 vTaskGenericNotifyGiveFromISR
04002d6c g     F .text	000000a8 xStreamBufferNextMessageLengthBytes
04004e0c g     F .text	000000fc xTaskPriorityDisinherit
040098a8 g       *ABS*	00000000 __ram_rwdata_end
04009888 g     O .rwdata	00000008 alt_dev_list
040046ac g     F .text	000000f4 xTaskRemoveFromEventList
0400824c g       *ABS*	00000000 __ram_rodata_end
04000ae8 g     F .text	00000068 xEventGroupClearBits
04001ca4 g     F .text	000001b0 xQueuePeek
0480b138 g       *ABS*	00000000 end
04002e14 g     F .text	000000e8 xStreamBufferReceiveFromISR
04003870 g     F .text	000000e8 vTaskDelete
040067c0 g     F .text	000000b4 altera_avalon_jtag_uart_init
04005144 g     F .text	00000038 pvTaskIncrementMutexHeldCount
04008200 g       *ABS*	00000000 __CTOR_LIST__
08000000 g       *ABS*	00000000 __alt_stack_pointer
04007148 g     F .text	0000007c alt_avalon_timer_sc_init
04006ea0 g     F .text	00000228 altera_avalon_jtag_uart_write
04005e8c g     F .text	00000038 task1
04005be0 g     F .text	00000080 timer_0_ISR
040048f0 g     F .text	000000e8 xTaskCheckForTimeOut
04004ccc g     F .text	00000140 xTaskPriorityInherit
040080a8 g     F .text	00000120 __call_exitprocs
04005280 g     F .text	00000164 xTaskGenericNotifyWait
04002614 g     F .text	00000064 vStreamBufferDelete
04000248 g     F .text	0000004c _start
04006208 g     F .text	0000002c task2
0400af64 g     O .bss	00000004 _alt_tick_rate
04004100 g     F .text	0000002c vTaskSuspendAll
04003010 g     F .text	0000007c xStreamBufferIsFull
040042a4 g     F .text	0000002c xTaskGetTickCountFromISR
0400af68 g     O .bss	00000004 _alt_nticks
040065fc g     F .text	00000060 alt_sys_init
04001060 g     F .text	00000098 uxListRemove
04008018 g     F .text	00000090 __register_exitproc
04002568 g     F .text	000000ac xStreamBufferGenericCreate
04006b24 g     F .text	00000068 altera_avalon_jtag_uart_close
0400824c g       *ABS*	00000000 __ram_rwdata_start
04008200 g       *ABS*	00000000 __ram_rodata_start
04003e7c g     F .text	000000cc vTaskResume
04004524 g     F .text	000000d4 vTaskSwitchContext
0400665c g     F .text	00000060 altera_avalon_jtag_uart_read_fd
04007d90 g     F .text	000000a0 alt_get_fd
04007f08 g     F .text	00000078 memcmp
0400671c g     F .text	00000050 altera_avalon_jtag_uart_close_fd
0480b138 g       *ABS*	00000000 __alt_stack_base
0400676c g     F .text	00000054 altera_avalon_jtag_uart_ioctl_fd
04003cec g     F .text	00000124 vTaskSuspend
04004330 g     F .text	00000048 xTaskCatchUpTicks
040042d0 g     F .text	00000020 uxTaskGetNumberOfTasks
04007c88 g     F .text	00000108 alt_find_file
040074b8 g     F .text	000000a8 alt_dev_llist_insert
04001474 g     F .text	0000009c xQueueTakeMutexRecursive
04000d0c g     F .text	00000074 vEventGroupDelete
040053e4 g     F .text	00000228 xTaskGenericNotify
0400af04 g       *ABS*	00000000 __bss_start
04006078 g     F .text	000000b4 TranslateDecode
04006334 g     F .text	000000f0 memset
04005d54 g     F .text	00000138 main
0400af60 g     O .bss	00000004 alt_envp
040066bc g     F .text	00000060 altera_avalon_jtag_uart_write_fd
04000f88 g     F .text	000000d8 vListInsert
04009894 g     O .rwdata	00000004 alt_errno
04005fc0 g     F .text	000000b8 HexDecode
04003958 g     F .text	000000f0 vTaskDelayUntil
04001e54 g     F .text	000000e4 xQueueReceiveFromISR
04004ca4 g     F .text	00000028 xTaskGetCurrentTaskHandle
0400120c g     F .text	00000098 xQueueGenericCreate
04008200 g       *ABS*	00000000 __CTOR_END__
04001510 g     F .text	00000058 xQueueCreateCountingSemaphore
04008200 g       *ABS*	00000000 __flash_rodata_start
04008200 g       *ABS*	00000000 __DTOR_LIST__
04002714 g     F .text	0000006c xStreamBufferSetTriggerLevel
0400560c g     F .text	00000260 xTaskGenericNotifyFromISR
040065c0 g     F .text	0000003c alt_irq_init
040079d0 g     F .text	00000058 alt_release_fd
0400412c g     F .text	00000150 xTaskResumeAll
04001ff4 g     F .text	00000054 uxQueueSpacesAvailable
04004028 g     F .text	00000090 vTaskStartScheduler
04007ec0 g     F .text	00000014 atexit
04002518 g     F .text	00000050 xQueueIsQueueFullFromISR
040098a4 g     O .rwdata	00000004 _impure_ptr
0400af58 g     O .bss	00000004 alt_argc
0400af4c g     O .bss	00000004 Go
040075c4 g     F .text	00000064 _do_dtors
040049d8 g     F .text	00000028 vTaskMissedYield
04009880 g     O .rwdata	00000008 alt_fs_list
04001fb4 g     F .text	00000040 uxQueueMessagesWaiting
04004378 g     F .text	000001ac xTaskIncrementTick
04000020 g       *ABS*	00000000 __ram_exceptions_start
040010f8 g     F .text	00000114 xQueueGenericReset
0400af50 g     O .bss	00000004 Translate
040098a8 g       *ABS*	00000000 _edata
0480b138 g       *ABS*	00000000 _end
04000248 g       *ABS*	00000000 __ram_exceptions_end
04006b8c g     F .text	000000f4 altera_avalon_jtag_uart_ioctl
04003498 g     F .text	000000e4 xTaskCreate
04000718 g     F .text	00000024 vPortInitialiseBlocks
040059c0 g     F .text	0000008c xTaskGenericNotifyStateClear
04007ed4 g     F .text	00000034 exit
04003a48 g     F .text	0000005c vTaskDelay
08000000 g       *ABS*	00000000 __alt_data_end
04000000 g       *ABS*	00000000 __alt_mem_sdram
04004f08 g     F .text	00000140 vTaskPriorityDisinheritAfterTimeout
040081c8 g     F .text	00000038 _exit
040071c4 g     F .text	00000134 alt_alarm_start
0400509c g     F .text	00000064 vTaskExitCritical
04007f80 g     F .text	00000098 strlen
040002c0 g     F .text	000000e0 pxPortInitialiseStack
0400787c g     F .text	00000154 open
04007628 g     F .text	00000034 alt_icache_flush_all
04004868 g     F .text	0000004c vTaskSetTimeOutState
0400987c g     O .rwdata	00000004 alt_priority_mask
04002048 g     F .text	00000038 uxQueueMessagesWaitingFromISR
04002478 g     F .text	00000048 xQueueIsQueueEmptyFromISR
04002808 g     F .text	00000040 xStreamBufferBytesAvailable
04009898 g     O .rwdata	00000008 alt_alarm_list
04007560 g     F .text	00000064 _do_ctors
04009878 g     O .rwdata	00000001 Display
04005100 g     F .text	00000044 uxTaskResetEventItemValue
04001388 g     F .text	0000005c xQueueCreateMutex
04007334 g     F .text	000000d0 close
0400648c g     F .text	00000084 alt_load
04000dbc g     F .text	0000003c vEventGroupClearBitsCallback
0400308c g     F .text	00000088 xStreamBufferSendCompletedFromISR
04001810 g     F .text	000000dc xQueueGiveFromISR



Disassembly of section .entry:

04000000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && (!defined(ALT_SIM_OPTIMIZE) || defined(NIOS2_ECC_PRESENT))
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
 4000000:	00840014 	movui	r2,4096
#endif

0:
    initi r2
 4000004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
 4000008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
 400000c:	00bffd16 	blt	zero,r2,4000004 <__reset+0x4>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
 4000010:	00410034 	movhi	at,1024
    ori r1, r1, %lo(_start)
 4000014:	08409214 	ori	at,at,584
    jmp r1
 4000018:	0800683a 	jmp	at
 400001c:	00000000 	call	0 <__alt_mem_sdram-0x4000000>

Disassembly of section .exceptions:

04000020 <save_context>:
# Entry point for exceptions.
.section .exceptions.entry, "xa"		

# Save the entire context of a task.
save_context:
	addi	ea, ea, -4			# Point to the next instruction.
 4000020:	ef7fff04 	addi	ea,ea,-4
	addi	sp,	sp, -116		# Create space on the stack.
 4000024:	deffe304 	addi	sp,sp,-116
	stw		ra, 0(sp)
 4000028:	dfc00015 	stw	ra,0(sp)
								# Leave a gap for muldiv 0
	stw		at, 8(sp)		 
 400002c:	d8400215 	stw	at,8(sp)
	stw		r2, 12(sp)
 4000030:	d8800315 	stw	r2,12(sp)
	stw		r3, 16(sp)
 4000034:	d8c00415 	stw	r3,16(sp)
	stw		r4, 20(sp)
 4000038:	d9000515 	stw	r4,20(sp)
	stw		r5, 24(sp) 
 400003c:	d9400615 	stw	r5,24(sp)
	stw		r6, 28(sp) 
 4000040:	d9800715 	stw	r6,28(sp)
	stw		r7, 32(sp) 
 4000044:	d9c00815 	stw	r7,32(sp)
	stw		r8, 36(sp) 
 4000048:	da000915 	stw	r8,36(sp)
	stw		r9, 40(sp) 
 400004c:	da400a15 	stw	r9,40(sp)
	stw		r10, 44(sp)
 4000050:	da800b15 	stw	r10,44(sp)
	stw		r11, 48(sp)
 4000054:	dac00c15 	stw	r11,48(sp)
	stw		r12, 52(sp)
 4000058:	db000d15 	stw	r12,52(sp)
	stw		r13, 56(sp)
 400005c:	db400e15 	stw	r13,56(sp)
	stw		r14, 60(sp)
 4000060:	db800f15 	stw	r14,60(sp)
	stw		r15, 64(sp)
 4000064:	dbc01015 	stw	r15,64(sp)
	rdctl	r5, estatus 		# Save the eStatus
 4000068:	000b307a 	rdctl	r5,estatus
	stw		r5, 68(sp)
 400006c:	d9401115 	stw	r5,68(sp)
	stw		ea, 72(sp)			# Save the PC
 4000070:	df401215 	stw	ea,72(sp)
	stw		r16, 76(sp)			# Save the remaining registers
 4000074:	dc001315 	stw	r16,76(sp)
	stw		r17, 80(sp)
 4000078:	dc401415 	stw	r17,80(sp)
	stw		r18, 84(sp)
 400007c:	dc801515 	stw	r18,84(sp)
	stw		r19, 88(sp)
 4000080:	dcc01615 	stw	r19,88(sp)
	stw		r20, 92(sp)
 4000084:	dd001715 	stw	r20,92(sp)
	stw		r21, 96(sp)
 4000088:	dd401815 	stw	r21,96(sp)
	stw		r22, 100(sp)
 400008c:	dd801915 	stw	r22,100(sp)
	stw		r23, 104(sp)
 4000090:	ddc01a15 	stw	r23,104(sp)
	stw		gp, 108(sp)
 4000094:	de801b15 	stw	gp,108(sp)
	stw		fp, 112(sp)
 4000098:	df001c15 	stw	fp,112(sp)

0400009c <save_sp_to_pxCurrentTCB>:
 400009c:	06010074 	movhi	et,1025

save_sp_to_pxCurrentTCB:
	movia	et, pxCurrentTCB	# Load the address of the pxCurrentTCB pointer
 40000a0:	c62bc304 	addi	et,et,-20724
	ldw		et, (et)			# Load the value of the pxCurrentTCB pointer
 40000a4:	c6000017 	ldw	et,0(et)
	stw		sp, (et)			# Store the stack pointer into the top of the TCB
 40000a8:	c6c00015 	stw	sp,0(et)

040000ac <hw_irq_test>:
hw_irq_test:
	/*
     * Test to see if the exception was a software exception or caused 
     * by an external interrupt, and vector accordingly.
     */
    rdctl	r4, ipending		# Load the Pending Interrupts indication
 40000ac:	0009313a 	rdctl	r4,ipending
	rdctl	r5, estatus 		# Load the eStatus (enabled interrupts).
 40000b0:	000b307a 	rdctl	r5,estatus
    andi	r2, r5, 1			# Are interrupts enabled globally.
 40000b4:	2880004c 	andi	r2,r5,1
    beq		r2, zero, soft_exceptions		# Interrupts are not enabled.
 40000b8:	10002526 	beq	r2,zero,4000150 <soft_exceptions>
    beq		r4, zero, soft_exceptions		# There are no interrupts triggered.
 40000bc:	20002426 	beq	r4,zero,4000150 <soft_exceptions>

040000c0 <hw_irq_handler>:

	.section .exceptions.irqhandler, "xa"
hw_irq_handler:
	call	alt_irq_handler					# Call the alt_irq_handler to deliver to the registered interrupt handler.
 40000c0:	400017c0 	call	400017c <alt_irq_handler>

040000c4 <restore_sp_from_pxCurrentTCB>:
 40000c4:	06010074 	movhi	et,1025

    .section .exceptions.irqreturn, "xa"
restore_sp_from_pxCurrentTCB:
	movia	et, pxCurrentTCB		# Load the address of the pxCurrentTCB pointer
 40000c8:	c62bc304 	addi	et,et,-20724
	ldw		et, (et)				# Load the value of the pxCurrentTCB pointer
 40000cc:	c6000017 	ldw	et,0(et)
	ldw		sp, (et)				# Load the stack pointer with the top value of the TCB
 40000d0:	c6c00017 	ldw	sp,0(et)

040000d4 <restore_context>:

restore_context:
	ldw		ra, 0(sp)		# Restore the registers.
 40000d4:	dfc00017 	ldw	ra,0(sp)
							# Leave a gap for muldiv 0.
	ldw		at, 8(sp)
 40000d8:	d8400217 	ldw	at,8(sp)
	ldw		r2, 12(sp)
 40000dc:	d8800317 	ldw	r2,12(sp)
	ldw		r3, 16(sp)
 40000e0:	d8c00417 	ldw	r3,16(sp)
	ldw		r4, 20(sp)
 40000e4:	d9000517 	ldw	r4,20(sp)
	ldw		r5, 24(sp) 
 40000e8:	d9400617 	ldw	r5,24(sp)
	ldw		r6, 28(sp) 
 40000ec:	d9800717 	ldw	r6,28(sp)
	ldw		r7, 32(sp) 
 40000f0:	d9c00817 	ldw	r7,32(sp)
	ldw		r8, 36(sp) 
 40000f4:	da000917 	ldw	r8,36(sp)
	ldw		r9, 40(sp) 
 40000f8:	da400a17 	ldw	r9,40(sp)
	ldw		r10, 44(sp)
 40000fc:	da800b17 	ldw	r10,44(sp)
	ldw		r11, 48(sp)
 4000100:	dac00c17 	ldw	r11,48(sp)
	ldw		r12, 52(sp)
 4000104:	db000d17 	ldw	r12,52(sp)
	ldw		r13, 56(sp)
 4000108:	db400e17 	ldw	r13,56(sp)
	ldw		r14, 60(sp)
 400010c:	db800f17 	ldw	r14,60(sp)
	ldw		r15, 64(sp)
 4000110:	dbc01017 	ldw	r15,64(sp)
	ldw		et, 68(sp)		# Load the eStatus
 4000114:	de001117 	ldw	et,68(sp)
	wrctl	estatus, et 	# Write the eStatus
 4000118:	c001707a 	wrctl	estatus,et
	ldw		ea, 72(sp)		# Load the Program Counter
 400011c:	df401217 	ldw	ea,72(sp)
	ldw		r16, 76(sp)
 4000120:	dc001317 	ldw	r16,76(sp)
	ldw		r17, 80(sp)
 4000124:	dc401417 	ldw	r17,80(sp)
	ldw		r18, 84(sp)
 4000128:	dc801517 	ldw	r18,84(sp)
	ldw		r19, 88(sp)
 400012c:	dcc01617 	ldw	r19,88(sp)
	ldw		r20, 92(sp)
 4000130:	dd001717 	ldw	r20,92(sp)
	ldw		r21, 96(sp)
 4000134:	dd401817 	ldw	r21,96(sp)
	ldw		r22, 100(sp)
 4000138:	dd801917 	ldw	r22,100(sp)
	ldw		r23, 104(sp)
 400013c:	ddc01a17 	ldw	r23,104(sp)
	ldw		gp, 108(sp)
 4000140:	de801b17 	ldw	gp,108(sp)
	ldw		fp, 112(sp)
 4000144:	df001c17 	ldw	fp,112(sp)
	addi	sp,	sp, 116		# Release stack space
 4000148:	dec01d04 	addi	sp,sp,116

    eret					# Return to address ea, loading eStatus into Status.
 400014c:	ef80083a 	eret

04000150 <soft_exceptions>:
   
	.section .exceptions.soft, "xa"
soft_exceptions:
	ldw		et, 0(ea)				# Load the instruction where the interrupt occured.
 4000150:	ee000017 	ldw	et,0(ea)
	movhi	at, %hi(0x003B683A)		# Load the registers with the trap instruction code
 4000154:	00400ef4 	movhi	at,59
	ori		at, at, %lo(0x003B683A)
 4000158:	085a0e94 	ori	at,at,26682
   	cmpne	et, et, at				# Compare the trap instruction code to the last excuted instruction
 400015c:	c070c03a 	cmpne	et,et,at
  	beq		et, r0, call_scheduler	# its a trap so switchcontext
 4000160:	c0000226 	beq	et,zero,400016c <call_scheduler>
  	break							# This is an un-implemented instruction or muldiv problem.
 4000164:	003da03a 	break	0
  	br		restore_context			# its something else
 4000168:	003fda06 	br	40000d4 <restore_context>

0400016c <call_scheduler>:

call_scheduler:
	addi	ea, ea, 4						# A trap was called, increment the program counter so it is not called again.
 400016c:	ef400104 	addi	ea,ea,4
	stw		ea, 72(sp)						# Save the new program counter to the context.
 4000170:	df401215 	stw	ea,72(sp)
	call	vTaskSwitchContext				# Pick the next context.
 4000174:	40045240 	call	4004524 <vTaskSwitchContext>
	br		restore_sp_from_pxCurrentTCB	# Switch in the task context and restore. 
 4000178:	003fd206 	br	40000c4 <restore_sp_from_pxCurrentTCB>

0400017c <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
 400017c:	defff904 	addi	sp,sp,-28
 4000180:	dfc00615 	stw	ra,24(sp)
 4000184:	df000515 	stw	fp,20(sp)
 4000188:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
 400018c:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 4000190:	0005313a 	rdctl	r2,ipending
 4000194:	e0bffc15 	stw	r2,-16(fp)

  return active;
 4000198:	e0bffc17 	ldw	r2,-16(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
 400019c:	e0bfff15 	stw	r2,-4(fp)

  do
  {
    i = 0;
 40001a0:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
 40001a4:	00800044 	movi	r2,1
 40001a8:	e0bffe15 	stw	r2,-8(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
 40001ac:	e0ffff17 	ldw	r3,-4(fp)
 40001b0:	e0bffe17 	ldw	r2,-8(fp)
 40001b4:	1884703a 	and	r2,r3,r2
 40001b8:	10001226 	beq	r2,zero,4000204 <alt_irq_handler+0x88>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
 40001bc:	e0bffd17 	ldw	r2,-12(fp)
 40001c0:	100690fa 	slli	r3,r2,3
 40001c4:	00812074 	movhi	r2,1153
 40001c8:	1885883a 	add	r2,r3,r2
 40001cc:	10ec0e17 	ldw	r3,-20424(r2)
 40001d0:	e0bffd17 	ldw	r2,-12(fp)
 40001d4:	100890fa 	slli	r4,r2,3
 40001d8:	00812074 	movhi	r2,1153
 40001dc:	2085883a 	add	r2,r4,r2
 40001e0:	10ac0f17 	ldw	r2,-20420(r2)
 40001e4:	e17ffd17 	ldw	r5,-12(fp)
 40001e8:	1009883a 	mov	r4,r2
 40001ec:	183ee83a 	callr	r3
#endif
        break;
 40001f0:	0001883a 	nop
  NIOS2_READ_IPENDING (active);
 40001f4:	0005313a 	rdctl	r2,ipending
 40001f8:	e0bffb15 	stw	r2,-20(fp)
  return active;
 40001fc:	e0bffb17 	ldw	r2,-20(fp)
 4000200:	00000706 	br	4000220 <alt_irq_handler+0xa4>
      }
      mask <<= 1;
 4000204:	e0bffe17 	ldw	r2,-8(fp)
 4000208:	1085883a 	add	r2,r2,r2
 400020c:	e0bffe15 	stw	r2,-8(fp)
      i++;
 4000210:	e0bffd17 	ldw	r2,-12(fp)
 4000214:	10800044 	addi	r2,r2,1
 4000218:	e0bffd15 	stw	r2,-12(fp)
      if (active & mask)
 400021c:	003fe306 	br	40001ac <alt_irq_handler+0x30>

    } while (1);

    active = alt_irq_pending ();
 4000220:	e0bfff15 	stw	r2,-4(fp)
    
  } while (active);
 4000224:	e0bfff17 	ldw	r2,-4(fp)
 4000228:	103fdd1e 	bne	r2,zero,40001a0 <alt_irq_handler+0x24>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
 400022c:	0001883a 	nop
}
 4000230:	0001883a 	nop
 4000234:	e037883a 	mov	sp,fp
 4000238:	dfc00117 	ldw	ra,4(sp)
 400023c:	df000017 	ldw	fp,0(sp)
 4000240:	dec00204 	addi	sp,sp,8
 4000244:	f800283a 	ret

Disassembly of section .text:

04000248 <_start>:

    /* Assume the data cache size is always a power of two. */
#if NIOS2_DCACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_DCACHE_SIZE)
#else
    movui r2, NIOS2_DCACHE_SIZE
 4000248:	00820014 	movui	r2,2048
#endif

0:
    initd 0(r2)
 400024c:	10000033 	initd	0(r2)
#ifdef NIOS2_ECC_PRESENT
    addi r2, r2, -4
#else
    addi r2, r2, -NIOS2_DCACHE_LINE_SIZE
 4000250:	10bff804 	addi	r2,r2,-32
#endif
    bgt r2, zero, 0b
 4000254:	00bffd16 	blt	zero,r2,400024c <_start+0x4>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
 4000258:	06c20034 	movhi	sp,2048
    ori sp, sp, %lo(__alt_stack_pointer)
 400025c:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
 4000260:	06810074 	movhi	gp,1025
    ori gp, gp, %lo(_gp)
 4000264:	d6861e14 	ori	gp,gp,6264
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
 4000268:	00810034 	movhi	r2,1024
    ori r2, r2, %lo(__bss_start)
 400026c:	10abc114 	ori	r2,r2,44804

    movhi r3, %hi(__bss_end)
 4000270:	00c12034 	movhi	r3,1152
    ori r3, r3, %lo(__bss_end)
 4000274:	18ec4e14 	ori	r3,r3,45368

    beq r2, r3, 1f
 4000278:	10c00326 	beq	r2,r3,4000288 <_start+0x40>

0:
    stw zero, (r2)
 400027c:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
 4000280:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
 4000284:	10fffd36 	bltu	r2,r3,400027c <_start+0x34>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
 4000288:	400648c0 	call	400648c <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
 400028c:	40065100 	call	4006510 <alt_main>

04000290 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
 4000290:	003fff06 	br	4000290 <alt_after_alt_main>

04000294 <prvReadGp>:
void vPortSysTickHandler( void * context, alt_u32 id );

/*-----------------------------------------------------------*/

static void prvReadGp( uint32_t *ulValue )
{
 4000294:	defffe04 	addi	sp,sp,-8
 4000298:	df000115 	stw	fp,4(sp)
 400029c:	df000104 	addi	fp,sp,4
 40002a0:	e13fff15 	stw	r4,-4(fp)
	asm( "stw gp, (%0)" :: "r"(ulValue) );
 40002a4:	e0bfff17 	ldw	r2,-4(fp)
 40002a8:	16800015 	stw	gp,0(r2)
}
 40002ac:	0001883a 	nop
 40002b0:	e037883a 	mov	sp,fp
 40002b4:	df000017 	ldw	fp,0(sp)
 40002b8:	dec00104 	addi	sp,sp,4
 40002bc:	f800283a 	ret

040002c0 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{    
 40002c0:	defff904 	addi	sp,sp,-28
 40002c4:	dfc00615 	stw	ra,24(sp)
 40002c8:	df000515 	stw	fp,20(sp)
 40002cc:	df000504 	addi	fp,sp,20
 40002d0:	e13ffd15 	stw	r4,-12(fp)
 40002d4:	e17ffc15 	stw	r5,-16(fp)
 40002d8:	e1bffb15 	stw	r6,-20(fp)
StackType_t *pxFramePointer = pxTopOfStack - 1;
 40002dc:	e0bffd17 	ldw	r2,-12(fp)
 40002e0:	10bfff04 	addi	r2,r2,-4
 40002e4:	e0bfff15 	stw	r2,-4(fp)
StackType_t xGlobalPointer;

    prvReadGp( &xGlobalPointer ); 
 40002e8:	e0bffe04 	addi	r2,fp,-8
 40002ec:	1009883a 	mov	r4,r2
 40002f0:	40002940 	call	4000294 <prvReadGp>

    /* End of stack marker. */
    *pxTopOfStack = 0xdeadbeef;
 40002f4:	e0fffd17 	ldw	r3,-12(fp)
 40002f8:	00b7abb4 	movhi	r2,57006
 40002fc:	10afbbc4 	addi	r2,r2,-16657
 4000300:	18800015 	stw	r2,0(r3)
    pxTopOfStack--;
 4000304:	e0bffd17 	ldw	r2,-12(fp)
 4000308:	10bfff04 	addi	r2,r2,-4
 400030c:	e0bffd15 	stw	r2,-12(fp)
    
    *pxTopOfStack = ( StackType_t ) pxFramePointer; 
 4000310:	e0ffff17 	ldw	r3,-4(fp)
 4000314:	e0bffd17 	ldw	r2,-12(fp)
 4000318:	10c00015 	stw	r3,0(r2)
    pxTopOfStack--;
 400031c:	e0bffd17 	ldw	r2,-12(fp)
 4000320:	10bfff04 	addi	r2,r2,-4
 4000324:	e0bffd15 	stw	r2,-12(fp)
    
    *pxTopOfStack = xGlobalPointer; 
 4000328:	e0fffe17 	ldw	r3,-8(fp)
 400032c:	e0bffd17 	ldw	r2,-12(fp)
 4000330:	10c00015 	stw	r3,0(r2)
    
    /* Space for R23 to R16. */
    pxTopOfStack -= 9;
 4000334:	e0bffd17 	ldw	r2,-12(fp)
 4000338:	10bff704 	addi	r2,r2,-36
 400033c:	e0bffd15 	stw	r2,-12(fp)

    *pxTopOfStack = ( StackType_t ) pxCode; 
 4000340:	e0fffc17 	ldw	r3,-16(fp)
 4000344:	e0bffd17 	ldw	r2,-12(fp)
 4000348:	10c00015 	stw	r3,0(r2)
    pxTopOfStack--;
 400034c:	e0bffd17 	ldw	r2,-12(fp)
 4000350:	10bfff04 	addi	r2,r2,-4
 4000354:	e0bffd15 	stw	r2,-12(fp)

    *pxTopOfStack = portINITIAL_ESTATUS; 
 4000358:	e0bffd17 	ldw	r2,-12(fp)
 400035c:	00c00044 	movi	r3,1
 4000360:	10c00015 	stw	r3,0(r2)

    /* Space for R15 to R5. */    
    pxTopOfStack -= 12;
 4000364:	e0bffd17 	ldw	r2,-12(fp)
 4000368:	10bff404 	addi	r2,r2,-48
 400036c:	e0bffd15 	stw	r2,-12(fp)
    
    *pxTopOfStack = ( StackType_t ) pvParameters; 
 4000370:	e0fffb17 	ldw	r3,-20(fp)
 4000374:	e0bffd17 	ldw	r2,-12(fp)
 4000378:	10c00015 	stw	r3,0(r2)

    /* Space for R3 to R1, muldiv and RA. */
    pxTopOfStack -= 5;
 400037c:	e0bffd17 	ldw	r2,-12(fp)
 4000380:	10bffb04 	addi	r2,r2,-20
 4000384:	e0bffd15 	stw	r2,-12(fp)
    
    return pxTopOfStack;
 4000388:	e0bffd17 	ldw	r2,-12(fp)
}
 400038c:	e037883a 	mov	sp,fp
 4000390:	dfc00117 	ldw	ra,4(sp)
 4000394:	df000017 	ldw	fp,0(sp)
 4000398:	dec00204 	addi	sp,sp,8
 400039c:	f800283a 	ret

040003a0 <xPortStartScheduler>:

/* 
 * See header file for description. 
 */
BaseType_t xPortStartScheduler( void )
{
 40003a0:	defffe04 	addi	sp,sp,-8
 40003a4:	dfc00115 	stw	ra,4(sp)
 40003a8:	df000015 	stw	fp,0(sp)
 40003ac:	d839883a 	mov	fp,sp
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();
 40003b0:	40003f80 	call	40003f8 <prvSetupTimerInterrupt>
 40003b4:	00810034 	movhi	r2,1024
	
	/* Start the first task. */
    asm volatile (  " movia r2, restore_sp_from_pxCurrentTCB        \n"
 40003b8:	10803104 	addi	r2,r2,196
 40003bc:	1000683a 	jmp	r2
                    " jmp r2                                          " );

	/* Should not get here! */
	return 0;
 40003c0:	0005883a 	mov	r2,zero
}
 40003c4:	e037883a 	mov	sp,fp
 40003c8:	dfc00117 	ldw	ra,4(sp)
 40003cc:	df000017 	ldw	fp,0(sp)
 40003d0:	dec00204 	addi	sp,sp,8
 40003d4:	f800283a 	ret

040003d8 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 40003d8:	deffff04 	addi	sp,sp,-4
 40003dc:	df000015 	stw	fp,0(sp)
 40003e0:	d839883a 	mov	fp,sp
	/* It is unlikely that the NIOS2 port will require this function as there
	is nothing to return to.  */
}
 40003e4:	0001883a 	nop
 40003e8:	e037883a 	mov	sp,fp
 40003ec:	df000017 	ldw	fp,0(sp)
 40003f0:	dec00104 	addi	sp,sp,4
 40003f4:	f800283a 	ret

040003f8 <prvSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
void prvSetupTimerInterrupt( void )
{
 40003f8:	defffe04 	addi	sp,sp,-8
 40003fc:	dfc00115 	stw	ra,4(sp)
 4000400:	df000015 	stw	fp,0(sp)
 4000404:	d839883a 	mov	fp,sp
	/* Try to register the interrupt handler. */
	if ( -EINVAL == alt_irq_register( SYS_CLK_IRQ, 0x0, vPortSysTickHandler ) )
 4000408:	01810034 	movhi	r6,1024
 400040c:	31812004 	addi	r6,r6,1152
 4000410:	000b883a 	mov	r5,zero
 4000414:	01000044 	movi	r4,1
 4000418:	40004c80 	call	40004c8 <alt_irq_register>
 400041c:	10bffa98 	cmpnei	r2,r2,-22
 4000420:	1000021e 	bne	r2,zero,400042c <prvSetupTimerInterrupt+0x34>
	{ 
		/* Failed to install the Interrupt Handler. */
		asm( "break" );
 4000424:	003da03a 	break	0
 4000428:	00000c06 	br	400045c <prvSetupTimerInterrupt+0x64>
	}
	else
	{
		/* Configure SysTick to interrupt at the requested rate. */
		IOWR_ALTERA_AVALON_TIMER_CONTROL( SYS_CLK_BASE, ALTERA_AVALON_TIMER_CONTROL_STOP_MSK );
 400042c:	00c00204 	movi	r3,8
 4000430:	00820034 	movhi	r2,2048
 4000434:	10c41135 	stwio	r3,4164(r2)
		IOWR_ALTERA_AVALON_TIMER_PERIODL( SYS_CLK_BASE, ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) & 0xFFFF );
 4000438:	00f0d414 	movui	r3,50000
 400043c:	00820034 	movhi	r2,2048
 4000440:	10c41235 	stwio	r3,4168(r2)
		IOWR_ALTERA_AVALON_TIMER_PERIODH( SYS_CLK_BASE, ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) >> 16 );
 4000444:	0007883a 	mov	r3,zero
 4000448:	00820034 	movhi	r2,2048
 400044c:	10c41335 	stwio	r3,4172(r2)
		IOWR_ALTERA_AVALON_TIMER_CONTROL( SYS_CLK_BASE, ALTERA_AVALON_TIMER_CONTROL_CONT_MSK | ALTERA_AVALON_TIMER_CONTROL_START_MSK | ALTERA_AVALON_TIMER_CONTROL_ITO_MSK );	
 4000450:	00c001c4 	movi	r3,7
 4000454:	00820034 	movhi	r2,2048
 4000458:	10c41135 	stwio	r3,4164(r2)
	} 

	/* Clear any already pending interrupts generated by the Timer. */
	IOWR_ALTERA_AVALON_TIMER_STATUS( SYS_CLK_BASE, ~ALTERA_AVALON_TIMER_STATUS_TO_MSK );
 400045c:	00ffff84 	movi	r3,-2
 4000460:	00820034 	movhi	r2,2048
 4000464:	10c41035 	stwio	r3,4160(r2)
}
 4000468:	0001883a 	nop
 400046c:	e037883a 	mov	sp,fp
 4000470:	dfc00117 	ldw	ra,4(sp)
 4000474:	df000017 	ldw	fp,0(sp)
 4000478:	dec00204 	addi	sp,sp,8
 400047c:	f800283a 	ret

04000480 <vPortSysTickHandler>:
/*-----------------------------------------------------------*/

void vPortSysTickHandler( void * context, alt_u32 id )
{
 4000480:	defffc04 	addi	sp,sp,-16
 4000484:	dfc00315 	stw	ra,12(sp)
 4000488:	df000215 	stw	fp,8(sp)
 400048c:	df000204 	addi	fp,sp,8
 4000490:	e13fff15 	stw	r4,-4(fp)
 4000494:	e17ffe15 	stw	r5,-8(fp)
	/* Increment the kernel tick. */
	if( xTaskIncrementTick() != pdFALSE )
 4000498:	40043780 	call	4004378 <xTaskIncrementTick>
 400049c:	10000126 	beq	r2,zero,40004a4 <vPortSysTickHandler+0x24>
	{
        vTaskSwitchContext();
 40004a0:	40045240 	call	4004524 <vTaskSwitchContext>
	}
		
	/* Clear the interrupt. */
	IOWR_ALTERA_AVALON_TIMER_STATUS( SYS_CLK_BASE, ~ALTERA_AVALON_TIMER_STATUS_TO_MSK );
 40004a4:	00ffff84 	movi	r3,-2
 40004a8:	00820034 	movhi	r2,2048
 40004ac:	10c41035 	stwio	r3,4160(r2)
}
 40004b0:	0001883a 	nop
 40004b4:	e037883a 	mov	sp,fp
 40004b8:	dfc00117 	ldw	ra,4(sp)
 40004bc:	df000017 	ldw	fp,0(sp)
 40004c0:	dec00204 	addi	sp,sp,8
 40004c4:	f800283a 	ret

040004c8 <alt_irq_register>:
 * when it is registered. Interrupts should only be enabled after the FreeRTOS.org
 * kernel has its scheduler started so that contexts are saved and switched 
 * correctly.
 */
int alt_irq_register( alt_u32 id, void* context, void (*handler)(void*, alt_u32) )
{
 40004c8:	defff104 	addi	sp,sp,-60
 40004cc:	df000e15 	stw	fp,56(sp)
 40004d0:	df000e04 	addi	fp,sp,56
 40004d4:	e13ff415 	stw	r4,-48(fp)
 40004d8:	e17ff315 	stw	r5,-52(fp)
 40004dc:	e1bff215 	stw	r6,-56(fp)
	int rc = -EINVAL;  
 40004e0:	00bffa84 	movi	r2,-22
 40004e4:	e0bfff15 	stw	r2,-4(fp)
	alt_irq_context status;

	if (id < ALT_NIRQ)
 40004e8:	e0bff417 	ldw	r2,-48(fp)
 40004ec:	10800828 	cmpgeui	r2,r2,32
 40004f0:	10004b1e 	bne	r2,zero,4000620 <alt_irq_register+0x158>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 40004f4:	0005303a 	rdctl	r2,status
 40004f8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 40004fc:	e0fffd17 	ldw	r3,-12(fp)
 4000500:	00bfff84 	movi	r2,-2
 4000504:	1884703a 	and	r2,r3,r2
 4000508:	1001703a 	wrctl	status,r2
  
  return context;
 400050c:	e0bffd17 	ldw	r2,-12(fp)
		 * interrupts are disabled while the handler tables are updated to ensure
		 * that an interrupt doesn't occur while the tables are in an inconsistent
		 * state.
		 */
	
		status = alt_irq_disable_all ();
 4000510:	e0bffe15 	stw	r2,-8(fp)
	
		alt_irq[id].handler = handler;
 4000514:	e0bff417 	ldw	r2,-48(fp)
 4000518:	100890fa 	slli	r4,r2,3
 400051c:	e0fff217 	ldw	r3,-56(fp)
 4000520:	00812074 	movhi	r2,1153
 4000524:	2085883a 	add	r2,r4,r2
 4000528:	10ec0e15 	stw	r3,-20424(r2)
		alt_irq[id].context = context;
 400052c:	e0bff417 	ldw	r2,-48(fp)
 4000530:	100890fa 	slli	r4,r2,3
 4000534:	e0fff317 	ldw	r3,-52(fp)
 4000538:	00812074 	movhi	r2,1153
 400053c:	2085883a 	add	r2,r4,r2
 4000540:	10ec0f15 	stw	r3,-20420(r2)
	
		rc = (handler) ? alt_irq_enable (id): alt_irq_disable (id);
 4000544:	e0bff217 	ldw	r2,-56(fp)
 4000548:	10001a26 	beq	r2,zero,40005b4 <alt_irq_register+0xec>
 400054c:	e0bff417 	ldw	r2,-48(fp)
 4000550:	e0bffc15 	stw	r2,-16(fp)
  NIOS2_READ_STATUS (context);
 4000554:	0005303a 	rdctl	r2,status
 4000558:	e0bffb15 	stw	r2,-20(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 400055c:	e0fffb17 	ldw	r3,-20(fp)
 4000560:	00bfff84 	movi	r2,-2
 4000564:	1884703a 	and	r2,r3,r2
 4000568:	1001703a 	wrctl	status,r2
  return context;
 400056c:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 4000570:	e0bffa15 	stw	r2,-24(fp)

  alt_irq_active |= (1 << id);
 4000574:	00c00044 	movi	r3,1
 4000578:	e0bffc17 	ldw	r2,-16(fp)
 400057c:	1884983a 	sll	r2,r3,r2
 4000580:	1007883a 	mov	r3,r2
 4000584:	d0a5b717 	ldw	r2,-26916(gp)
 4000588:	1884b03a 	or	r2,r3,r2
 400058c:	d0a5b715 	stw	r2,-26916(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 4000590:	d0a5b717 	ldw	r2,-26916(gp)
 4000594:	100170fa 	wrctl	ienable,r2
 4000598:	e0bffa17 	ldw	r2,-24(fp)
 400059c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 40005a0:	e0bff917 	ldw	r2,-28(fp)
 40005a4:	1001703a 	wrctl	status,r2
#endif
}
 40005a8:	0001883a 	nop

  alt_irq_enable_all(status);

  return 0;
 40005ac:	0005883a 	mov	r2,zero
 40005b0:	00001a06 	br	400061c <alt_irq_register+0x154>
 40005b4:	e0bff417 	ldw	r2,-48(fp)
 40005b8:	e0bff815 	stw	r2,-32(fp)
  NIOS2_READ_STATUS (context);
 40005bc:	0005303a 	rdctl	r2,status
 40005c0:	e0bff715 	stw	r2,-36(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 40005c4:	e0fff717 	ldw	r3,-36(fp)
 40005c8:	00bfff84 	movi	r2,-2
 40005cc:	1884703a 	and	r2,r3,r2
 40005d0:	1001703a 	wrctl	status,r2
  return context;
 40005d4:	e0bff717 	ldw	r2,-36(fp)
  status = alt_irq_disable_all ();
 40005d8:	e0bff615 	stw	r2,-40(fp)
  alt_irq_active &= ~(1 << id);
 40005dc:	00c00044 	movi	r3,1
 40005e0:	e0bff817 	ldw	r2,-32(fp)
 40005e4:	1884983a 	sll	r2,r3,r2
 40005e8:	0084303a 	nor	r2,zero,r2
 40005ec:	1007883a 	mov	r3,r2
 40005f0:	d0a5b717 	ldw	r2,-26916(gp)
 40005f4:	1884703a 	and	r2,r3,r2
 40005f8:	d0a5b715 	stw	r2,-26916(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 40005fc:	d0a5b717 	ldw	r2,-26916(gp)
 4000600:	100170fa 	wrctl	ienable,r2
 4000604:	e0bff617 	ldw	r2,-40(fp)
 4000608:	e0bff515 	stw	r2,-44(fp)
  NIOS2_WRITE_STATUS (context);
 400060c:	e0bff517 	ldw	r2,-44(fp)
 4000610:	1001703a 	wrctl	status,r2
}
 4000614:	0001883a 	nop
  return 0;
 4000618:	0005883a 	mov	r2,zero
 400061c:	e0bfff15 	stw	r2,-4(fp)
	
		/* alt_irq_enable_all(status); This line is removed to prevent the interrupt from being immediately enabled. */
	}
    
	return rc; 
 4000620:	e0bfff17 	ldw	r2,-4(fp)
}
 4000624:	e037883a 	mov	sp,fp
 4000628:	df000017 	ldw	fp,0(sp)
 400062c:	dec00104 	addi	sp,sp,4
 4000630:	f800283a 	ret

04000634 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
 4000634:	defffc04 	addi	sp,sp,-16
 4000638:	dfc00315 	stw	ra,12(sp)
 400063c:	df000215 	stw	fp,8(sp)
 4000640:	df000204 	addi	fp,sp,8
 4000644:	e13ffe15 	stw	r4,-8(fp)
    void * pvReturn = NULL;
 4000648:	e03fff15 	stw	zero,-4(fp)
    static uint8_t * pucAlignedHeap = NULL;

    /* Ensure that blocks are always aligned to the required number of bytes. */
    #if ( portBYTE_ALIGNMENT != 1 )
        {
            if( xWantedSize & portBYTE_ALIGNMENT_MASK )
 400064c:	e0bffe17 	ldw	r2,-8(fp)
 4000650:	108000cc 	andi	r2,r2,3
 4000654:	10000526 	beq	r2,zero,400066c <pvPortMalloc+0x38>
            {
                /* Byte alignment required. */
                xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 4000658:	e0fffe17 	ldw	r3,-8(fp)
 400065c:	00bfff04 	movi	r2,-4
 4000660:	1884703a 	and	r2,r3,r2
 4000664:	10800104 	addi	r2,r2,4
 4000668:	e0bffe15 	stw	r2,-8(fp)
            }
        }
    #endif

    vTaskSuspendAll();
 400066c:	40041000 	call	4004100 <vTaskSuspendAll>
    {
        if( pucAlignedHeap == NULL )
 4000670:	d0a5a417 	ldw	r2,-26992(gp)
 4000674:	1000051e 	bne	r2,zero,400068c <pvPortMalloc+0x58>
        {
            /* Ensure the heap starts on a correctly aligned boundary. */
            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
 4000678:	00810074 	movhi	r2,1025
 400067c:	10abdd04 	addi	r2,r2,-20620
 4000680:	00ffff04 	movi	r3,-4
 4000684:	10c4703a 	and	r2,r2,r3
 4000688:	d0a5a415 	stw	r2,-26992(gp)
        }

        /* Check there is enough room left for the allocation. */
        if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 400068c:	d0e5a317 	ldw	r3,-26996(gp)
 4000690:	e0bffe17 	ldw	r2,-8(fp)
 4000694:	1887883a 	add	r3,r3,r2
 4000698:	00802034 	movhi	r2,128
 400069c:	10bffec4 	addi	r2,r2,-5
 40006a0:	10c00d36 	bltu	r2,r3,40006d8 <pvPortMalloc+0xa4>
            ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) /* Check for overflow. */
 40006a4:	d0e5a317 	ldw	r3,-26996(gp)
 40006a8:	e0bffe17 	ldw	r2,-8(fp)
 40006ac:	1885883a 	add	r2,r3,r2
 40006b0:	d0e5a317 	ldw	r3,-26996(gp)
        if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 40006b4:	1880082e 	bgeu	r3,r2,40006d8 <pvPortMalloc+0xa4>
        {
            /* Return the next free byte then increment the index past this
             * block. */
            pvReturn = pucAlignedHeap + xNextFreeByte;
 40006b8:	d0e5a417 	ldw	r3,-26992(gp)
 40006bc:	d0a5a317 	ldw	r2,-26996(gp)
 40006c0:	1885883a 	add	r2,r3,r2
 40006c4:	e0bfff15 	stw	r2,-4(fp)
            xNextFreeByte += xWantedSize;
 40006c8:	d0e5a317 	ldw	r3,-26996(gp)
 40006cc:	e0bffe17 	ldw	r2,-8(fp)
 40006d0:	1885883a 	add	r2,r3,r2
 40006d4:	d0a5a315 	stw	r2,-26996(gp)
        }

        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
 40006d8:	400412c0 	call	400412c <xTaskResumeAll>
                vApplicationMallocFailedHook();
            }
        }
    #endif

    return pvReturn;
 40006dc:	e0bfff17 	ldw	r2,-4(fp)
}
 40006e0:	e037883a 	mov	sp,fp
 40006e4:	dfc00117 	ldw	ra,4(sp)
 40006e8:	df000017 	ldw	fp,0(sp)
 40006ec:	dec00204 	addi	sp,sp,8
 40006f0:	f800283a 	ret

040006f4 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
 40006f4:	defffe04 	addi	sp,sp,-8
 40006f8:	df000115 	stw	fp,4(sp)
 40006fc:	df000104 	addi	fp,sp,4
 4000700:	e13fff15 	stw	r4,-4(fp)
     * https://www.FreeRTOS.org for more information. */
    ( void ) pv;

    /* Force an assert as it is invalid to call this function. */
    configASSERT( pv == NULL );
}
 4000704:	0001883a 	nop
 4000708:	e037883a 	mov	sp,fp
 400070c:	df000017 	ldw	fp,0(sp)
 4000710:	dec00104 	addi	sp,sp,4
 4000714:	f800283a 	ret

04000718 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
 4000718:	deffff04 	addi	sp,sp,-4
 400071c:	df000015 	stw	fp,0(sp)
 4000720:	d839883a 	mov	fp,sp
    /* Only required when static memory is not cleared. */
    xNextFreeByte = ( size_t ) 0;
 4000724:	d025a315 	stw	zero,-26996(gp)
}
 4000728:	0001883a 	nop
 400072c:	e037883a 	mov	sp,fp
 4000730:	df000017 	ldw	fp,0(sp)
 4000734:	dec00104 	addi	sp,sp,4
 4000738:	f800283a 	ret

0400073c <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
 400073c:	deffff04 	addi	sp,sp,-4
 4000740:	df000015 	stw	fp,0(sp)
 4000744:	d839883a 	mov	fp,sp
    return( configADJUSTED_HEAP_SIZE - xNextFreeByte );
 4000748:	d0e5a317 	ldw	r3,-26996(gp)
 400074c:	00802034 	movhi	r2,128
 4000750:	10bfff04 	addi	r2,r2,-4
 4000754:	10c5c83a 	sub	r2,r2,r3
}
 4000758:	e037883a 	mov	sp,fp
 400075c:	df000017 	ldw	fp,0(sp)
 4000760:	dec00104 	addi	sp,sp,4
 4000764:	f800283a 	ret

04000768 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    EventGroupHandle_t xEventGroupCreate( void )
    {
 4000768:	defffd04 	addi	sp,sp,-12
 400076c:	dfc00215 	stw	ra,8(sp)
 4000770:	df000115 	stw	fp,4(sp)
 4000774:	df000104 	addi	fp,sp,4
         * TickType_t alignment requirements the cast is safe.  In other cases,
         * where the natural word size of the architecture is less than
         * sizeof( TickType_t ), the TickType_t variables will be accessed in two
         * or more reads operations, and the alignment requirements is only that
         * of each individual read. */
        pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
 4000778:	01000604 	movi	r4,24
 400077c:	40006340 	call	4000634 <pvPortMalloc>
 4000780:	e0bfff15 	stw	r2,-4(fp)

        if( pxEventBits != NULL )
 4000784:	e0bfff17 	ldw	r2,-4(fp)
 4000788:	10000626 	beq	r2,zero,40007a4 <xEventGroupCreate+0x3c>
        {
            pxEventBits->uxEventBits = 0;
 400078c:	e0bfff17 	ldw	r2,-4(fp)
 4000790:	10000015 	stw	zero,0(r2)
            vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
 4000794:	e0bfff17 	ldw	r2,-4(fp)
 4000798:	10800104 	addi	r2,r2,4
 400079c:	1009883a 	mov	r4,r2
 40007a0:	4000e680 	call	4000e68 <vListInitialise>
        else
        {
            traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
        }

        return pxEventBits;
 40007a4:	e0bfff17 	ldw	r2,-4(fp)
    }
 40007a8:	e037883a 	mov	sp,fp
 40007ac:	dfc00117 	ldw	ra,4(sp)
 40007b0:	df000017 	ldw	fp,0(sp)
 40007b4:	dec00204 	addi	sp,sp,8
 40007b8:	f800283a 	ret

040007bc <xEventGroupSync>:

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup,
                             const EventBits_t uxBitsToSet,
                             const EventBits_t uxBitsToWaitFor,
                             TickType_t xTicksToWait )
{
 40007bc:	defff504 	addi	sp,sp,-44
 40007c0:	dfc00a15 	stw	ra,40(sp)
 40007c4:	df000915 	stw	fp,36(sp)
 40007c8:	df000904 	addi	fp,sp,36
 40007cc:	e13ffa15 	stw	r4,-24(fp)
 40007d0:	e17ff915 	stw	r5,-28(fp)
 40007d4:	e1bff815 	stw	r6,-32(fp)
 40007d8:	e1fff715 	stw	r7,-36(fp)
    EventBits_t uxOriginalBitValue, uxReturn;
    EventGroup_t * pxEventBits = xEventGroup;
 40007dc:	e0bffa17 	ldw	r2,-24(fp)
 40007e0:	e0bffe15 	stw	r2,-8(fp)
    BaseType_t xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
 40007e4:	e03ffd15 	stw	zero,-12(fp)
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
        }
    #endif

    vTaskSuspendAll();
 40007e8:	40041000 	call	4004100 <vTaskSuspendAll>
    {
        uxOriginalBitValue = pxEventBits->uxEventBits;
 40007ec:	e0bffe17 	ldw	r2,-8(fp)
 40007f0:	10800017 	ldw	r2,0(r2)
 40007f4:	e0bffc15 	stw	r2,-16(fp)

        ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
 40007f8:	e17ff917 	ldw	r5,-28(fp)
 40007fc:	e13ffa17 	ldw	r4,-24(fp)
 4000800:	4000b8c0 	call	4000b8c <xEventGroupSetBits>

        if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
 4000804:	e0fffc17 	ldw	r3,-16(fp)
 4000808:	e0bff917 	ldw	r2,-28(fp)
 400080c:	1886b03a 	or	r3,r3,r2
 4000810:	e0bff817 	ldw	r2,-32(fp)
 4000814:	1884703a 	and	r2,r3,r2
 4000818:	e0fff817 	ldw	r3,-32(fp)
 400081c:	18800d1e 	bne	r3,r2,4000854 <xEventGroupSync+0x98>
        {
            /* All the rendezvous bits are now set - no need to block. */
            uxReturn = ( uxOriginalBitValue | uxBitsToSet );
 4000820:	e0fffc17 	ldw	r3,-16(fp)
 4000824:	e0bff917 	ldw	r2,-28(fp)
 4000828:	1884b03a 	or	r2,r3,r2
 400082c:	e0bfff15 	stw	r2,-4(fp)

            /* Rendezvous always clear the bits.  They will have been cleared
             * already unless this is the only task in the rendezvous. */
            pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 4000830:	e0bffe17 	ldw	r2,-8(fp)
 4000834:	10c00017 	ldw	r3,0(r2)
 4000838:	e0bff817 	ldw	r2,-32(fp)
 400083c:	0084303a 	nor	r2,zero,r2
 4000840:	1886703a 	and	r3,r3,r2
 4000844:	e0bffe17 	ldw	r2,-8(fp)
 4000848:	10c00015 	stw	r3,0(r2)

            xTicksToWait = 0;
 400084c:	e03ff715 	stw	zero,-36(fp)
 4000850:	00001106 	br	4000898 <xEventGroupSync+0xdc>
        }
        else
        {
            if( xTicksToWait != ( TickType_t ) 0 )
 4000854:	e0bff717 	ldw	r2,-36(fp)
 4000858:	10000a26 	beq	r2,zero,4000884 <xEventGroupSync+0xc8>
                traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

                /* Store the bits that the calling task is waiting for in the
                 * task's event list item so the kernel knows when a match is
                 * found.  Then enter the blocked state. */
                vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
 400085c:	e0bffe17 	ldw	r2,-8(fp)
 4000860:	10c00104 	addi	r3,r2,4
 4000864:	e0bff817 	ldw	r2,-32(fp)
 4000868:	10814034 	orhi	r2,r2,1280
 400086c:	e1bff717 	ldw	r6,-36(fp)
 4000870:	100b883a 	mov	r5,r2
 4000874:	1809883a 	mov	r4,r3
 4000878:	40046480 	call	4004648 <vTaskPlaceOnUnorderedEventList>

                /* This assignment is obsolete as uxReturn will get set after
                 * the task unblocks, but some compilers mistakenly generate a
                 * warning about uxReturn being returned without being set if the
                 * assignment is omitted. */
                uxReturn = 0;
 400087c:	e03fff15 	stw	zero,-4(fp)
 4000880:	00000506 	br	4000898 <xEventGroupSync+0xdc>
            }
            else
            {
                /* The rendezvous bits were not set, but no block time was
                 * specified - just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
 4000884:	e0bffe17 	ldw	r2,-8(fp)
 4000888:	10800017 	ldw	r2,0(r2)
 400088c:	e0bfff15 	stw	r2,-4(fp)
                xTimeoutOccurred = pdTRUE;
 4000890:	00800044 	movi	r2,1
 4000894:	e0bffd15 	stw	r2,-12(fp)
            }
        }
    }
    xAlreadyYielded = xTaskResumeAll();
 4000898:	400412c0 	call	400412c <xTaskResumeAll>
 400089c:	e0bffb15 	stw	r2,-20(fp)

    if( xTicksToWait != ( TickType_t ) 0 )
 40008a0:	e0bff717 	ldw	r2,-36(fp)
 40008a4:	10002026 	beq	r2,zero,4000928 <xEventGroupSync+0x16c>
    {
        if( xAlreadyYielded == pdFALSE )
 40008a8:	e0bffb17 	ldw	r2,-20(fp)
 40008ac:	1000011e 	bne	r2,zero,40008b4 <xEventGroupSync+0xf8>
        {
            portYIELD_WITHIN_API();
 40008b0:	003b683a 	trap	0

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
 40008b4:	40051000 	call	4005100 <uxTaskResetEventItemValue>
 40008b8:	e0bfff15 	stw	r2,-4(fp)

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
 40008bc:	e0bfff17 	ldw	r2,-4(fp)
 40008c0:	1080802c 	andhi	r2,r2,512
 40008c4:	1000131e 	bne	r2,zero,4000914 <xEventGroupSync+0x158>
        {
            /* The task timed out, just return the current event bit value. */
            taskENTER_CRITICAL();
 40008c8:	40050480 	call	4005048 <vTaskEnterCritical>
            {
                uxReturn = pxEventBits->uxEventBits;
 40008cc:	e0bffe17 	ldw	r2,-8(fp)
 40008d0:	10800017 	ldw	r2,0(r2)
 40008d4:	e0bfff15 	stw	r2,-4(fp)

                /* Although the task got here because it timed out before the
                 * bits it was waiting for were set, it is possible that since it
                 * unblocked another task has set the bits.  If this is the case
                 * then it needs to clear the bits before exiting. */
                if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
 40008d8:	e0ffff17 	ldw	r3,-4(fp)
 40008dc:	e0bff817 	ldw	r2,-32(fp)
 40008e0:	1884703a 	and	r2,r3,r2
 40008e4:	e0fff817 	ldw	r3,-32(fp)
 40008e8:	1880071e 	bne	r3,r2,4000908 <xEventGroupSync+0x14c>
                {
                    pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 40008ec:	e0bffe17 	ldw	r2,-8(fp)
 40008f0:	10c00017 	ldw	r3,0(r2)
 40008f4:	e0bff817 	ldw	r2,-32(fp)
 40008f8:	0084303a 	nor	r2,zero,r2
 40008fc:	1886703a 	and	r3,r3,r2
 4000900:	e0bffe17 	ldw	r2,-8(fp)
 4000904:	10c00015 	stw	r3,0(r2)
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
 4000908:	400509c0 	call	400509c <vTaskExitCritical>

            xTimeoutOccurred = pdTRUE;
 400090c:	00800044 	movi	r2,1
 4000910:	e0bffd15 	stw	r2,-12(fp)
            /* The task unblocked because the bits were set. */
        }

        /* Control bits might be set as the task had blocked should not be
         * returned. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
 4000914:	e0ffff17 	ldw	r3,-4(fp)
 4000918:	00804034 	movhi	r2,256
 400091c:	10bfffc4 	addi	r2,r2,-1
 4000920:	1884703a 	and	r2,r3,r2
 4000924:	e0bfff15 	stw	r2,-4(fp)
    traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
 4000928:	e0bfff17 	ldw	r2,-4(fp)
}
 400092c:	e037883a 	mov	sp,fp
 4000930:	dfc00117 	ldw	ra,4(sp)
 4000934:	df000017 	ldw	fp,0(sp)
 4000938:	dec00204 	addi	sp,sp,8
 400093c:	f800283a 	ret

04000940 <xEventGroupWaitBits>:
EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,
                                 const EventBits_t uxBitsToWaitFor,
                                 const BaseType_t xClearOnExit,
                                 const BaseType_t xWaitForAllBits,
                                 TickType_t xTicksToWait )
{
 4000940:	defff304 	addi	sp,sp,-52
 4000944:	dfc00c15 	stw	ra,48(sp)
 4000948:	df000b15 	stw	fp,44(sp)
 400094c:	df000b04 	addi	fp,sp,44
 4000950:	e13ff815 	stw	r4,-32(fp)
 4000954:	e17ff715 	stw	r5,-36(fp)
 4000958:	e1bff615 	stw	r6,-40(fp)
 400095c:	e1fff515 	stw	r7,-44(fp)
    EventGroup_t * pxEventBits = xEventGroup;
 4000960:	e0bff817 	ldw	r2,-32(fp)
 4000964:	e0bffd15 	stw	r2,-12(fp)
    EventBits_t uxReturn, uxControlBits = 0;
 4000968:	e03ffe15 	stw	zero,-8(fp)
    BaseType_t xWaitConditionMet, xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
 400096c:	e03ffc15 	stw	zero,-16(fp)
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
        }
    #endif

    vTaskSuspendAll();
 4000970:	40041000 	call	4004100 <vTaskSuspendAll>
    {
        const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
 4000974:	e0bffd17 	ldw	r2,-12(fp)
 4000978:	10800017 	ldw	r2,0(r2)
 400097c:	e0bffb15 	stw	r2,-20(fp)

        /* Check to see if the wait condition is already met or not. */
        xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
 4000980:	e1bff517 	ldw	r6,-44(fp)
 4000984:	e17ff717 	ldw	r5,-36(fp)
 4000988:	e13ffb17 	ldw	r4,-20(fp)
 400098c:	4000df80 	call	4000df8 <prvTestWaitCondition>
 4000990:	e0bffa15 	stw	r2,-24(fp)

        if( xWaitConditionMet != pdFALSE )
 4000994:	e0bffa17 	ldw	r2,-24(fp)
 4000998:	10000d26 	beq	r2,zero,40009d0 <xEventGroupWaitBits+0x90>
        {
            /* The wait condition has already been met so there is no need to
             * block. */
            uxReturn = uxCurrentEventBits;
 400099c:	e0bffb17 	ldw	r2,-20(fp)
 40009a0:	e0bfff15 	stw	r2,-4(fp)
            xTicksToWait = ( TickType_t ) 0;
 40009a4:	e0000215 	stw	zero,8(fp)

            /* Clear the wait bits if requested to do so. */
            if( xClearOnExit != pdFALSE )
 40009a8:	e0bff617 	ldw	r2,-40(fp)
 40009ac:	10002226 	beq	r2,zero,4000a38 <xEventGroupWaitBits+0xf8>
            {
                pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 40009b0:	e0bffd17 	ldw	r2,-12(fp)
 40009b4:	10c00017 	ldw	r3,0(r2)
 40009b8:	e0bff717 	ldw	r2,-36(fp)
 40009bc:	0084303a 	nor	r2,zero,r2
 40009c0:	1886703a 	and	r3,r3,r2
 40009c4:	e0bffd17 	ldw	r2,-12(fp)
 40009c8:	10c00015 	stw	r3,0(r2)
 40009cc:	00001a06 	br	4000a38 <xEventGroupWaitBits+0xf8>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else if( xTicksToWait == ( TickType_t ) 0 )
 40009d0:	e0800217 	ldw	r2,8(fp)
 40009d4:	1000051e 	bne	r2,zero,40009ec <xEventGroupWaitBits+0xac>
        {
            /* The wait condition has not been met, but no block time was
             * specified, so just return the current value. */
            uxReturn = uxCurrentEventBits;
 40009d8:	e0bffb17 	ldw	r2,-20(fp)
 40009dc:	e0bfff15 	stw	r2,-4(fp)
            xTimeoutOccurred = pdTRUE;
 40009e0:	00800044 	movi	r2,1
 40009e4:	e0bffc15 	stw	r2,-16(fp)
 40009e8:	00001306 	br	4000a38 <xEventGroupWaitBits+0xf8>
        {
            /* The task is going to block to wait for its required bits to be
             * set.  uxControlBits are used to remember the specified behaviour of
             * this call to xEventGroupWaitBits() - for use when the event bits
             * unblock the task. */
            if( xClearOnExit != pdFALSE )
 40009ec:	e0bff617 	ldw	r2,-40(fp)
 40009f0:	10000326 	beq	r2,zero,4000a00 <xEventGroupWaitBits+0xc0>
            {
                uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
 40009f4:	e0bffe17 	ldw	r2,-8(fp)
 40009f8:	10804034 	orhi	r2,r2,256
 40009fc:	e0bffe15 	stw	r2,-8(fp)
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            if( xWaitForAllBits != pdFALSE )
 4000a00:	e0bff517 	ldw	r2,-44(fp)
 4000a04:	10000326 	beq	r2,zero,4000a14 <xEventGroupWaitBits+0xd4>
            {
                uxControlBits |= eventWAIT_FOR_ALL_BITS;
 4000a08:	e0bffe17 	ldw	r2,-8(fp)
 4000a0c:	10810034 	orhi	r2,r2,1024
 4000a10:	e0bffe15 	stw	r2,-8(fp)
            }

            /* Store the bits that the calling task is waiting for in the
             * task's event list item so the kernel knows when a match is
             * found.  Then enter the blocked state. */
            vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
 4000a14:	e0bffd17 	ldw	r2,-12(fp)
 4000a18:	11000104 	addi	r4,r2,4
 4000a1c:	e0fff717 	ldw	r3,-36(fp)
 4000a20:	e0bffe17 	ldw	r2,-8(fp)
 4000a24:	1884b03a 	or	r2,r3,r2
 4000a28:	e1800217 	ldw	r6,8(fp)
 4000a2c:	100b883a 	mov	r5,r2
 4000a30:	40046480 	call	4004648 <vTaskPlaceOnUnorderedEventList>

            /* This is obsolete as it will get set after the task unblocks, but
             * some compilers mistakenly generate a warning about the variable
             * being returned without being set if it is not done. */
            uxReturn = 0;
 4000a34:	e03fff15 	stw	zero,-4(fp)

            traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
        }
    }
    xAlreadyYielded = xTaskResumeAll();
 4000a38:	400412c0 	call	400412c <xTaskResumeAll>
 4000a3c:	e0bff915 	stw	r2,-28(fp)

    if( xTicksToWait != ( TickType_t ) 0 )
 4000a40:	e0800217 	ldw	r2,8(fp)
 4000a44:	10002226 	beq	r2,zero,4000ad0 <xEventGroupWaitBits+0x190>
    {
        if( xAlreadyYielded == pdFALSE )
 4000a48:	e0bff917 	ldw	r2,-28(fp)
 4000a4c:	1000011e 	bne	r2,zero,4000a54 <xEventGroupWaitBits+0x114>
        {
            portYIELD_WITHIN_API();
 4000a50:	003b683a 	trap	0

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
 4000a54:	40051000 	call	4005100 <uxTaskResetEventItemValue>
 4000a58:	e0bfff15 	stw	r2,-4(fp)

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
 4000a5c:	e0bfff17 	ldw	r2,-4(fp)
 4000a60:	1080802c 	andhi	r2,r2,512
 4000a64:	1000151e 	bne	r2,zero,4000abc <xEventGroupWaitBits+0x17c>
        {
            taskENTER_CRITICAL();
 4000a68:	40050480 	call	4005048 <vTaskEnterCritical>
            {
                /* The task timed out, just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
 4000a6c:	e0bffd17 	ldw	r2,-12(fp)
 4000a70:	10800017 	ldw	r2,0(r2)
 4000a74:	e0bfff15 	stw	r2,-4(fp)

                /* It is possible that the event bits were updated between this
                 * task leaving the Blocked state and running again. */
                if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
 4000a78:	e1bff517 	ldw	r6,-44(fp)
 4000a7c:	e17ff717 	ldw	r5,-36(fp)
 4000a80:	e13fff17 	ldw	r4,-4(fp)
 4000a84:	4000df80 	call	4000df8 <prvTestWaitCondition>
 4000a88:	10000926 	beq	r2,zero,4000ab0 <xEventGroupWaitBits+0x170>
                {
                    if( xClearOnExit != pdFALSE )
 4000a8c:	e0bff617 	ldw	r2,-40(fp)
 4000a90:	10000726 	beq	r2,zero,4000ab0 <xEventGroupWaitBits+0x170>
                    {
                        pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 4000a94:	e0bffd17 	ldw	r2,-12(fp)
 4000a98:	10c00017 	ldw	r3,0(r2)
 4000a9c:	e0bff717 	ldw	r2,-36(fp)
 4000aa0:	0084303a 	nor	r2,zero,r2
 4000aa4:	1886703a 	and	r3,r3,r2
 4000aa8:	e0bffd17 	ldw	r2,-12(fp)
 4000aac:	10c00015 	stw	r3,0(r2)
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                xTimeoutOccurred = pdTRUE;
 4000ab0:	00800044 	movi	r2,1
 4000ab4:	e0bffc15 	stw	r2,-16(fp)
            }
            taskEXIT_CRITICAL();
 4000ab8:	400509c0 	call	400509c <vTaskExitCritical>
        {
            /* The task unblocked because the bits were set. */
        }

        /* The task blocked so control bits may have been set. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
 4000abc:	e0ffff17 	ldw	r3,-4(fp)
 4000ac0:	00804034 	movhi	r2,256
 4000ac4:	10bfffc4 	addi	r2,r2,-1
 4000ac8:	1884703a 	and	r2,r3,r2
 4000acc:	e0bfff15 	stw	r2,-4(fp)
    traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
 4000ad0:	e0bfff17 	ldw	r2,-4(fp)
}
 4000ad4:	e037883a 	mov	sp,fp
 4000ad8:	dfc00117 	ldw	ra,4(sp)
 4000adc:	df000017 	ldw	fp,0(sp)
 4000ae0:	dec00204 	addi	sp,sp,8
 4000ae4:	f800283a 	ret

04000ae8 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup,
                                  const EventBits_t uxBitsToClear )
{
 4000ae8:	defffa04 	addi	sp,sp,-24
 4000aec:	dfc00515 	stw	ra,20(sp)
 4000af0:	df000415 	stw	fp,16(sp)
 4000af4:	df000404 	addi	fp,sp,16
 4000af8:	e13ffd15 	stw	r4,-12(fp)
 4000afc:	e17ffc15 	stw	r5,-16(fp)
    EventGroup_t * pxEventBits = xEventGroup;
 4000b00:	e0bffd17 	ldw	r2,-12(fp)
 4000b04:	e0bfff15 	stw	r2,-4(fp)
    /* Check the user is not attempting to clear the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    taskENTER_CRITICAL();
 4000b08:	40050480 	call	4005048 <vTaskEnterCritical>
    {
        traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

        /* The value returned is the event group value prior to the bits being
         * cleared. */
        uxReturn = pxEventBits->uxEventBits;
 4000b0c:	e0bfff17 	ldw	r2,-4(fp)
 4000b10:	10800017 	ldw	r2,0(r2)
 4000b14:	e0bffe15 	stw	r2,-8(fp)

        /* Clear the bits. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
 4000b18:	e0bfff17 	ldw	r2,-4(fp)
 4000b1c:	10c00017 	ldw	r3,0(r2)
 4000b20:	e0bffc17 	ldw	r2,-16(fp)
 4000b24:	0084303a 	nor	r2,zero,r2
 4000b28:	1886703a 	and	r3,r3,r2
 4000b2c:	e0bfff17 	ldw	r2,-4(fp)
 4000b30:	10c00015 	stw	r3,0(r2)
    }
    taskEXIT_CRITICAL();
 4000b34:	400509c0 	call	400509c <vTaskExitCritical>

    return uxReturn;
 4000b38:	e0bffe17 	ldw	r2,-8(fp)
}
 4000b3c:	e037883a 	mov	sp,fp
 4000b40:	dfc00117 	ldw	ra,4(sp)
 4000b44:	df000017 	ldw	fp,0(sp)
 4000b48:	dec00204 	addi	sp,sp,8
 4000b4c:	f800283a 	ret

04000b50 <xEventGroupGetBitsFromISR>:

#endif /* if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) ) */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
 4000b50:	defffb04 	addi	sp,sp,-20
 4000b54:	df000415 	stw	fp,16(sp)
 4000b58:	df000404 	addi	fp,sp,16
 4000b5c:	e13ffc15 	stw	r4,-16(fp)
    UBaseType_t uxSavedInterruptStatus;
    EventGroup_t const * const pxEventBits = xEventGroup;
 4000b60:	e0bffc17 	ldw	r2,-16(fp)
 4000b64:	e0bfff15 	stw	r2,-4(fp)
    EventBits_t uxReturn;

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 4000b68:	e03ffe15 	stw	zero,-8(fp)
    {
        uxReturn = pxEventBits->uxEventBits;
 4000b6c:	e0bfff17 	ldw	r2,-4(fp)
 4000b70:	10800017 	ldw	r2,0(r2)
 4000b74:	e0bffd15 	stw	r2,-12(fp)
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return uxReturn;
 4000b78:	e0bffd17 	ldw	r2,-12(fp)
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
 4000b7c:	e037883a 	mov	sp,fp
 4000b80:	df000017 	ldw	fp,0(sp)
 4000b84:	dec00104 	addi	sp,sp,4
 4000b88:	f800283a 	ret

04000b8c <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,
                                const EventBits_t uxBitsToSet )
{
 4000b8c:	defff304 	addi	sp,sp,-52
 4000b90:	dfc00c15 	stw	ra,48(sp)
 4000b94:	df000b15 	stw	fp,44(sp)
 4000b98:	df000b04 	addi	fp,sp,44
 4000b9c:	e13ff615 	stw	r4,-40(fp)
 4000ba0:	e17ff515 	stw	r5,-44(fp)
    ListItem_t * pxListItem, * pxNext;
    ListItem_t const * pxListEnd;
    List_t const * pxList;
    EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
 4000ba4:	e03ffe15 	stw	zero,-8(fp)
    EventGroup_t * pxEventBits = xEventGroup;
 4000ba8:	e0bff617 	ldw	r2,-40(fp)
 4000bac:	e0bffc15 	stw	r2,-16(fp)
    BaseType_t xMatchFound = pdFALSE;
 4000bb0:	e03ffd15 	stw	zero,-12(fp)
    /* Check the user is not attempting to set the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    pxList = &( pxEventBits->xTasksWaitingForBits );
 4000bb4:	e0bffc17 	ldw	r2,-16(fp)
 4000bb8:	10800104 	addi	r2,r2,4
 4000bbc:	e0bffb15 	stw	r2,-20(fp)
    pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 4000bc0:	e0bffb17 	ldw	r2,-20(fp)
 4000bc4:	10800204 	addi	r2,r2,8
 4000bc8:	e0bffa15 	stw	r2,-24(fp)
    vTaskSuspendAll();
 4000bcc:	40041000 	call	4004100 <vTaskSuspendAll>
    {
        traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

        pxListItem = listGET_HEAD_ENTRY( pxList );
 4000bd0:	e0bffb17 	ldw	r2,-20(fp)
 4000bd4:	10800317 	ldw	r2,12(r2)
 4000bd8:	e0bfff15 	stw	r2,-4(fp)

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;
 4000bdc:	e0bffc17 	ldw	r2,-16(fp)
 4000be0:	10c00017 	ldw	r3,0(r2)
 4000be4:	e0bff517 	ldw	r2,-44(fp)
 4000be8:	1886b03a 	or	r3,r3,r2
 4000bec:	e0bffc17 	ldw	r2,-16(fp)
 4000bf0:	10c00015 	stw	r3,0(r2)

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
 4000bf4:	00003306 	br	4000cc4 <xEventGroupSetBits+0x138>
        {
            pxNext = listGET_NEXT( pxListItem );
 4000bf8:	e0bfff17 	ldw	r2,-4(fp)
 4000bfc:	10800117 	ldw	r2,4(r2)
 4000c00:	e0bff915 	stw	r2,-28(fp)
            uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
 4000c04:	e0bfff17 	ldw	r2,-4(fp)
 4000c08:	10800017 	ldw	r2,0(r2)
 4000c0c:	e0bff815 	stw	r2,-32(fp)
            xMatchFound = pdFALSE;
 4000c10:	e03ffd15 	stw	zero,-12(fp)

            /* Split the bits waited for from the control bits. */
            uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
 4000c14:	e0bff817 	ldw	r2,-32(fp)
 4000c18:	10bfc02c 	andhi	r2,r2,65280
 4000c1c:	e0bff715 	stw	r2,-36(fp)
            uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
 4000c20:	e0fff817 	ldw	r3,-32(fp)
 4000c24:	00804034 	movhi	r2,256
 4000c28:	10bfffc4 	addi	r2,r2,-1
 4000c2c:	1884703a 	and	r2,r3,r2
 4000c30:	e0bff815 	stw	r2,-32(fp)

            if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
 4000c34:	e0bff717 	ldw	r2,-36(fp)
 4000c38:	1081002c 	andhi	r2,r2,1024
 4000c3c:	1000081e 	bne	r2,zero,4000c60 <xEventGroupSetBits+0xd4>
            {
                /* Just looking for single bit being set. */
                if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
 4000c40:	e0bffc17 	ldw	r2,-16(fp)
 4000c44:	10c00017 	ldw	r3,0(r2)
 4000c48:	e0bff817 	ldw	r2,-32(fp)
 4000c4c:	1884703a 	and	r2,r3,r2
 4000c50:	10000b26 	beq	r2,zero,4000c80 <xEventGroupSetBits+0xf4>
                {
                    xMatchFound = pdTRUE;
 4000c54:	00800044 	movi	r2,1
 4000c58:	e0bffd15 	stw	r2,-12(fp)
 4000c5c:	00000806 	br	4000c80 <xEventGroupSetBits+0xf4>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
 4000c60:	e0bffc17 	ldw	r2,-16(fp)
 4000c64:	10c00017 	ldw	r3,0(r2)
 4000c68:	e0bff817 	ldw	r2,-32(fp)
 4000c6c:	1884703a 	and	r2,r3,r2
 4000c70:	e0fff817 	ldw	r3,-32(fp)
 4000c74:	1880021e 	bne	r3,r2,4000c80 <xEventGroupSetBits+0xf4>
            {
                /* All bits are set. */
                xMatchFound = pdTRUE;
 4000c78:	00800044 	movi	r2,1
 4000c7c:	e0bffd15 	stw	r2,-12(fp)
            else
            {
                /* Need all bits to be set, but not all the bits were set. */
            }

            if( xMatchFound != pdFALSE )
 4000c80:	e0bffd17 	ldw	r2,-12(fp)
 4000c84:	10000d26 	beq	r2,zero,4000cbc <xEventGroupSetBits+0x130>
            {
                /* The bits match.  Should the bits be cleared on exit? */
                if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
 4000c88:	e0bff717 	ldw	r2,-36(fp)
 4000c8c:	1080402c 	andhi	r2,r2,256
 4000c90:	10000426 	beq	r2,zero,4000ca4 <xEventGroupSetBits+0x118>
                {
                    uxBitsToClear |= uxBitsWaitedFor;
 4000c94:	e0fffe17 	ldw	r3,-8(fp)
 4000c98:	e0bff817 	ldw	r2,-32(fp)
 4000c9c:	1884b03a 	or	r2,r3,r2
 4000ca0:	e0bffe15 	stw	r2,-8(fp)
                /* Store the actual event flag value in the task's event list
                 * item before removing the task from the event list.  The
                 * eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
                 * that is was unblocked due to its required bits matching, rather
                 * than because it timed out. */
                vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
 4000ca4:	e0bffc17 	ldw	r2,-16(fp)
 4000ca8:	10800017 	ldw	r2,0(r2)
 4000cac:	10808034 	orhi	r2,r2,512
 4000cb0:	100b883a 	mov	r5,r2
 4000cb4:	e13fff17 	ldw	r4,-4(fp)
 4000cb8:	40047a00 	call	40047a0 <vTaskRemoveFromUnorderedEventList>
            }

            /* Move onto the next list item.  Note pxListItem->pxNext is not
             * used here as the list item may have been removed from the event list
             * and inserted into the ready/pending reading list. */
            pxListItem = pxNext;
 4000cbc:	e0bff917 	ldw	r2,-28(fp)
 4000cc0:	e0bfff15 	stw	r2,-4(fp)
        while( pxListItem != pxListEnd )
 4000cc4:	e0ffff17 	ldw	r3,-4(fp)
 4000cc8:	e0bffa17 	ldw	r2,-24(fp)
 4000ccc:	18bfca1e 	bne	r3,r2,4000bf8 <xEventGroupSetBits+0x6c>
        }

        /* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
         * bit was set in the control word. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
 4000cd0:	e0bffc17 	ldw	r2,-16(fp)
 4000cd4:	10c00017 	ldw	r3,0(r2)
 4000cd8:	e0bffe17 	ldw	r2,-8(fp)
 4000cdc:	0084303a 	nor	r2,zero,r2
 4000ce0:	1886703a 	and	r3,r3,r2
 4000ce4:	e0bffc17 	ldw	r2,-16(fp)
 4000ce8:	10c00015 	stw	r3,0(r2)
    }
    ( void ) xTaskResumeAll();
 4000cec:	400412c0 	call	400412c <xTaskResumeAll>

    return pxEventBits->uxEventBits;
 4000cf0:	e0bffc17 	ldw	r2,-16(fp)
 4000cf4:	10800017 	ldw	r2,0(r2)
}
 4000cf8:	e037883a 	mov	sp,fp
 4000cfc:	dfc00117 	ldw	ra,4(sp)
 4000d00:	df000017 	ldw	fp,0(sp)
 4000d04:	dec00204 	addi	sp,sp,8
 4000d08:	f800283a 	ret

04000d0c <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
 4000d0c:	defffb04 	addi	sp,sp,-20
 4000d10:	dfc00415 	stw	ra,16(sp)
 4000d14:	df000315 	stw	fp,12(sp)
 4000d18:	df000304 	addi	fp,sp,12
 4000d1c:	e13ffd15 	stw	r4,-12(fp)
    EventGroup_t * pxEventBits = xEventGroup;
 4000d20:	e0bffd17 	ldw	r2,-12(fp)
 4000d24:	e0bfff15 	stw	r2,-4(fp)
    const List_t * pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
 4000d28:	e0bfff17 	ldw	r2,-4(fp)
 4000d2c:	10800104 	addi	r2,r2,4
 4000d30:	e0bffe15 	stw	r2,-8(fp)

    vTaskSuspendAll();
 4000d34:	40041000 	call	4004100 <vTaskSuspendAll>
    {
        traceEVENT_GROUP_DELETE( xEventGroup );

        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
 4000d38:	00000506 	br	4000d50 <vEventGroupDelete+0x44>
        {
            /* Unblock the task, returning 0 as the event list is being deleted
             * and cannot therefore have any bits set. */
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
 4000d3c:	e0bffe17 	ldw	r2,-8(fp)
 4000d40:	10800317 	ldw	r2,12(r2)
 4000d44:	01408034 	movhi	r5,512
 4000d48:	1009883a 	mov	r4,r2
 4000d4c:	40047a00 	call	40047a0 <vTaskRemoveFromUnorderedEventList>
        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
 4000d50:	e0bffe17 	ldw	r2,-8(fp)
 4000d54:	10800017 	ldw	r2,0(r2)
 4000d58:	103ff81e 	bne	r2,zero,4000d3c <vEventGroupDelete+0x30>

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
            {
                /* The event group can only have been allocated dynamically - free
                 * it again. */
                vPortFree( pxEventBits );
 4000d5c:	e13fff17 	ldw	r4,-4(fp)
 4000d60:	40006f40 	call	40006f4 <vPortFree>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
    ( void ) xTaskResumeAll();
 4000d64:	400412c0 	call	400412c <xTaskResumeAll>
}
 4000d68:	0001883a 	nop
 4000d6c:	e037883a 	mov	sp,fp
 4000d70:	dfc00117 	ldw	ra,4(sp)
 4000d74:	df000017 	ldw	fp,0(sp)
 4000d78:	dec00204 	addi	sp,sp,8
 4000d7c:	f800283a 	ret

04000d80 <vEventGroupSetBitsCallback>:

/* For internal use only - execute a 'set bits' command that was pended from
 * an interrupt. */
void vEventGroupSetBitsCallback( void * pvEventGroup,
                                 const uint32_t ulBitsToSet )
{
 4000d80:	defffc04 	addi	sp,sp,-16
 4000d84:	dfc00315 	stw	ra,12(sp)
 4000d88:	df000215 	stw	fp,8(sp)
 4000d8c:	df000204 	addi	fp,sp,8
 4000d90:	e13fff15 	stw	r4,-4(fp)
 4000d94:	e17ffe15 	stw	r5,-8(fp)
    ( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
 4000d98:	e17ffe17 	ldw	r5,-8(fp)
 4000d9c:	e13fff17 	ldw	r4,-4(fp)
 4000da0:	4000b8c0 	call	4000b8c <xEventGroupSetBits>
}
 4000da4:	0001883a 	nop
 4000da8:	e037883a 	mov	sp,fp
 4000dac:	dfc00117 	ldw	ra,4(sp)
 4000db0:	df000017 	ldw	fp,0(sp)
 4000db4:	dec00204 	addi	sp,sp,8
 4000db8:	f800283a 	ret

04000dbc <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
 * an interrupt. */
void vEventGroupClearBitsCallback( void * pvEventGroup,
                                   const uint32_t ulBitsToClear )
{
 4000dbc:	defffc04 	addi	sp,sp,-16
 4000dc0:	dfc00315 	stw	ra,12(sp)
 4000dc4:	df000215 	stw	fp,8(sp)
 4000dc8:	df000204 	addi	fp,sp,8
 4000dcc:	e13fff15 	stw	r4,-4(fp)
 4000dd0:	e17ffe15 	stw	r5,-8(fp)
    ( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
 4000dd4:	e17ffe17 	ldw	r5,-8(fp)
 4000dd8:	e13fff17 	ldw	r4,-4(fp)
 4000ddc:	4000ae80 	call	4000ae8 <xEventGroupClearBits>
}
 4000de0:	0001883a 	nop
 4000de4:	e037883a 	mov	sp,fp
 4000de8:	dfc00117 	ldw	ra,4(sp)
 4000dec:	df000017 	ldw	fp,0(sp)
 4000df0:	dec00204 	addi	sp,sp,8
 4000df4:	f800283a 	ret

04000df8 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits,
                                        const EventBits_t uxBitsToWaitFor,
                                        const BaseType_t xWaitForAllBits )
{
 4000df8:	defffb04 	addi	sp,sp,-20
 4000dfc:	df000415 	stw	fp,16(sp)
 4000e00:	df000404 	addi	fp,sp,16
 4000e04:	e13ffe15 	stw	r4,-8(fp)
 4000e08:	e17ffd15 	stw	r5,-12(fp)
 4000e0c:	e1bffc15 	stw	r6,-16(fp)
    BaseType_t xWaitConditionMet = pdFALSE;
 4000e10:	e03fff15 	stw	zero,-4(fp)

    if( xWaitForAllBits == pdFALSE )
 4000e14:	e0bffc17 	ldw	r2,-16(fp)
 4000e18:	1000071e 	bne	r2,zero,4000e38 <prvTestWaitCondition+0x40>
    {
        /* Task only has to wait for one bit within uxBitsToWaitFor to be
         * set.  Is one already set? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
 4000e1c:	e0fffe17 	ldw	r3,-8(fp)
 4000e20:	e0bffd17 	ldw	r2,-12(fp)
 4000e24:	1884703a 	and	r2,r3,r2
 4000e28:	10000a26 	beq	r2,zero,4000e54 <prvTestWaitCondition+0x5c>
        {
            xWaitConditionMet = pdTRUE;
 4000e2c:	00800044 	movi	r2,1
 4000e30:	e0bfff15 	stw	r2,-4(fp)
 4000e34:	00000706 	br	4000e54 <prvTestWaitCondition+0x5c>
    }
    else
    {
        /* Task has to wait for all the bits in uxBitsToWaitFor to be set.
         * Are they set already? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
 4000e38:	e0fffe17 	ldw	r3,-8(fp)
 4000e3c:	e0bffd17 	ldw	r2,-12(fp)
 4000e40:	1884703a 	and	r2,r3,r2
 4000e44:	e0fffd17 	ldw	r3,-12(fp)
 4000e48:	1880021e 	bne	r3,r2,4000e54 <prvTestWaitCondition+0x5c>
        {
            xWaitConditionMet = pdTRUE;
 4000e4c:	00800044 	movi	r2,1
 4000e50:	e0bfff15 	stw	r2,-4(fp)
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    return xWaitConditionMet;
 4000e54:	e0bfff17 	ldw	r2,-4(fp)
}
 4000e58:	e037883a 	mov	sp,fp
 4000e5c:	df000017 	ldw	fp,0(sp)
 4000e60:	dec00104 	addi	sp,sp,4
 4000e64:	f800283a 	ret

04000e68 <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 4000e68:	defffe04 	addi	sp,sp,-8
 4000e6c:	df000115 	stw	fp,4(sp)
 4000e70:	df000104 	addi	fp,sp,4
 4000e74:	e13fff15 	stw	r4,-4(fp)
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 4000e78:	e0bfff17 	ldw	r2,-4(fp)
 4000e7c:	10c00204 	addi	r3,r2,8
 4000e80:	e0bfff17 	ldw	r2,-4(fp)
 4000e84:	10c00115 	stw	r3,4(r2)

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
 4000e88:	e0bfff17 	ldw	r2,-4(fp)
 4000e8c:	00ffffc4 	movi	r3,-1
 4000e90:	10c00215 	stw	r3,8(r2)

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 4000e94:	e0bfff17 	ldw	r2,-4(fp)
 4000e98:	10c00204 	addi	r3,r2,8
 4000e9c:	e0bfff17 	ldw	r2,-4(fp)
 4000ea0:	10c00315 	stw	r3,12(r2)
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 4000ea4:	e0bfff17 	ldw	r2,-4(fp)
 4000ea8:	10c00204 	addi	r3,r2,8
 4000eac:	e0bfff17 	ldw	r2,-4(fp)
 4000eb0:	10c00415 	stw	r3,16(r2)

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 4000eb4:	e0bfff17 	ldw	r2,-4(fp)
 4000eb8:	10000015 	stw	zero,0(r2)

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 4000ebc:	0001883a 	nop
 4000ec0:	e037883a 	mov	sp,fp
 4000ec4:	df000017 	ldw	fp,0(sp)
 4000ec8:	dec00104 	addi	sp,sp,4
 4000ecc:	f800283a 	ret

04000ed0 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
 4000ed0:	defffe04 	addi	sp,sp,-8
 4000ed4:	df000115 	stw	fp,4(sp)
 4000ed8:	df000104 	addi	fp,sp,4
 4000edc:	e13fff15 	stw	r4,-4(fp)
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
 4000ee0:	e0bfff17 	ldw	r2,-4(fp)
 4000ee4:	10000415 	stw	zero,16(r2)

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 4000ee8:	0001883a 	nop
 4000eec:	e037883a 	mov	sp,fp
 4000ef0:	df000017 	ldw	fp,0(sp)
 4000ef4:	dec00104 	addi	sp,sp,4
 4000ef8:	f800283a 	ret

04000efc <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
 4000efc:	defffc04 	addi	sp,sp,-16
 4000f00:	df000315 	stw	fp,12(sp)
 4000f04:	df000304 	addi	fp,sp,12
 4000f08:	e13ffe15 	stw	r4,-8(fp)
 4000f0c:	e17ffd15 	stw	r5,-12(fp)
    ListItem_t * const pxIndex = pxList->pxIndex;
 4000f10:	e0bffe17 	ldw	r2,-8(fp)
 4000f14:	10800117 	ldw	r2,4(r2)
 4000f18:	e0bfff15 	stw	r2,-4(fp)
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
 4000f1c:	e0bffd17 	ldw	r2,-12(fp)
 4000f20:	e0ffff17 	ldw	r3,-4(fp)
 4000f24:	10c00115 	stw	r3,4(r2)
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 4000f28:	e0bfff17 	ldw	r2,-4(fp)
 4000f2c:	10c00217 	ldw	r3,8(r2)
 4000f30:	e0bffd17 	ldw	r2,-12(fp)
 4000f34:	10c00215 	stw	r3,8(r2)

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
 4000f38:	e0bfff17 	ldw	r2,-4(fp)
 4000f3c:	10800217 	ldw	r2,8(r2)
 4000f40:	e0fffd17 	ldw	r3,-12(fp)
 4000f44:	10c00115 	stw	r3,4(r2)
    pxIndex->pxPrevious = pxNewListItem;
 4000f48:	e0bfff17 	ldw	r2,-4(fp)
 4000f4c:	e0fffd17 	ldw	r3,-12(fp)
 4000f50:	10c00215 	stw	r3,8(r2)

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
 4000f54:	e0bffd17 	ldw	r2,-12(fp)
 4000f58:	e0fffe17 	ldw	r3,-8(fp)
 4000f5c:	10c00415 	stw	r3,16(r2)

    ( pxList->uxNumberOfItems )++;
 4000f60:	e0bffe17 	ldw	r2,-8(fp)
 4000f64:	10800017 	ldw	r2,0(r2)
 4000f68:	10c00044 	addi	r3,r2,1
 4000f6c:	e0bffe17 	ldw	r2,-8(fp)
 4000f70:	10c00015 	stw	r3,0(r2)
}
 4000f74:	0001883a 	nop
 4000f78:	e037883a 	mov	sp,fp
 4000f7c:	df000017 	ldw	fp,0(sp)
 4000f80:	dec00104 	addi	sp,sp,4
 4000f84:	f800283a 	ret

04000f88 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
 4000f88:	defffb04 	addi	sp,sp,-20
 4000f8c:	df000415 	stw	fp,16(sp)
 4000f90:	df000404 	addi	fp,sp,16
 4000f94:	e13ffd15 	stw	r4,-12(fp)
 4000f98:	e17ffc15 	stw	r5,-16(fp)
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 4000f9c:	e0bffc17 	ldw	r2,-16(fp)
 4000fa0:	10800017 	ldw	r2,0(r2)
 4000fa4:	e0bffe15 	stw	r2,-8(fp)
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
 4000fa8:	e0bffe17 	ldw	r2,-8(fp)
 4000fac:	10bfffd8 	cmpnei	r2,r2,-1
 4000fb0:	1000041e 	bne	r2,zero,4000fc4 <vListInsert+0x3c>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
 4000fb4:	e0bffd17 	ldw	r2,-12(fp)
 4000fb8:	10800417 	ldw	r2,16(r2)
 4000fbc:	e0bfff15 	stw	r2,-4(fp)
 4000fc0:	00000c06 	br	4000ff4 <vListInsert+0x6c>
        *   4) Using a queue or semaphore before it has been initialised or
        *      before the scheduler has been started (are interrupts firing
        *      before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 4000fc4:	e0bffd17 	ldw	r2,-12(fp)
 4000fc8:	10800204 	addi	r2,r2,8
 4000fcc:	e0bfff15 	stw	r2,-4(fp)
 4000fd0:	00000306 	br	4000fe0 <vListInsert+0x58>
 4000fd4:	e0bfff17 	ldw	r2,-4(fp)
 4000fd8:	10800117 	ldw	r2,4(r2)
 4000fdc:	e0bfff15 	stw	r2,-4(fp)
 4000fe0:	e0bfff17 	ldw	r2,-4(fp)
 4000fe4:	10800117 	ldw	r2,4(r2)
 4000fe8:	10800017 	ldw	r2,0(r2)
 4000fec:	e0fffe17 	ldw	r3,-8(fp)
 4000ff0:	18bff82e 	bgeu	r3,r2,4000fd4 <vListInsert+0x4c>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
 4000ff4:	e0bfff17 	ldw	r2,-4(fp)
 4000ff8:	10c00117 	ldw	r3,4(r2)
 4000ffc:	e0bffc17 	ldw	r2,-16(fp)
 4001000:	10c00115 	stw	r3,4(r2)
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 4001004:	e0bffc17 	ldw	r2,-16(fp)
 4001008:	10800117 	ldw	r2,4(r2)
 400100c:	e0fffc17 	ldw	r3,-16(fp)
 4001010:	10c00215 	stw	r3,8(r2)
    pxNewListItem->pxPrevious = pxIterator;
 4001014:	e0bffc17 	ldw	r2,-16(fp)
 4001018:	e0ffff17 	ldw	r3,-4(fp)
 400101c:	10c00215 	stw	r3,8(r2)
    pxIterator->pxNext = pxNewListItem;
 4001020:	e0bfff17 	ldw	r2,-4(fp)
 4001024:	e0fffc17 	ldw	r3,-16(fp)
 4001028:	10c00115 	stw	r3,4(r2)

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
 400102c:	e0bffc17 	ldw	r2,-16(fp)
 4001030:	e0fffd17 	ldw	r3,-12(fp)
 4001034:	10c00415 	stw	r3,16(r2)

    ( pxList->uxNumberOfItems )++;
 4001038:	e0bffd17 	ldw	r2,-12(fp)
 400103c:	10800017 	ldw	r2,0(r2)
 4001040:	10c00044 	addi	r3,r2,1
 4001044:	e0bffd17 	ldw	r2,-12(fp)
 4001048:	10c00015 	stw	r3,0(r2)
}
 400104c:	0001883a 	nop
 4001050:	e037883a 	mov	sp,fp
 4001054:	df000017 	ldw	fp,0(sp)
 4001058:	dec00104 	addi	sp,sp,4
 400105c:	f800283a 	ret

04001060 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 4001060:	defffd04 	addi	sp,sp,-12
 4001064:	df000215 	stw	fp,8(sp)
 4001068:	df000204 	addi	fp,sp,8
 400106c:	e13ffe15 	stw	r4,-8(fp)
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
 4001070:	e0bffe17 	ldw	r2,-8(fp)
 4001074:	10800417 	ldw	r2,16(r2)
 4001078:	e0bfff15 	stw	r2,-4(fp)

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 400107c:	e0bffe17 	ldw	r2,-8(fp)
 4001080:	10800117 	ldw	r2,4(r2)
 4001084:	e0fffe17 	ldw	r3,-8(fp)
 4001088:	18c00217 	ldw	r3,8(r3)
 400108c:	10c00215 	stw	r3,8(r2)
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 4001090:	e0bffe17 	ldw	r2,-8(fp)
 4001094:	10800217 	ldw	r2,8(r2)
 4001098:	e0fffe17 	ldw	r3,-8(fp)
 400109c:	18c00117 	ldw	r3,4(r3)
 40010a0:	10c00115 	stw	r3,4(r2)

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
 40010a4:	e0bfff17 	ldw	r2,-4(fp)
 40010a8:	10800117 	ldw	r2,4(r2)
 40010ac:	e0fffe17 	ldw	r3,-8(fp)
 40010b0:	1880041e 	bne	r3,r2,40010c4 <uxListRemove+0x64>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
 40010b4:	e0bffe17 	ldw	r2,-8(fp)
 40010b8:	10c00217 	ldw	r3,8(r2)
 40010bc:	e0bfff17 	ldw	r2,-4(fp)
 40010c0:	10c00115 	stw	r3,4(r2)
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
 40010c4:	e0bffe17 	ldw	r2,-8(fp)
 40010c8:	10000415 	stw	zero,16(r2)
    ( pxList->uxNumberOfItems )--;
 40010cc:	e0bfff17 	ldw	r2,-4(fp)
 40010d0:	10800017 	ldw	r2,0(r2)
 40010d4:	10ffffc4 	addi	r3,r2,-1
 40010d8:	e0bfff17 	ldw	r2,-4(fp)
 40010dc:	10c00015 	stw	r3,0(r2)

    return pxList->uxNumberOfItems;
 40010e0:	e0bfff17 	ldw	r2,-4(fp)
 40010e4:	10800017 	ldw	r2,0(r2)
}
 40010e8:	e037883a 	mov	sp,fp
 40010ec:	df000017 	ldw	fp,0(sp)
 40010f0:	dec00104 	addi	sp,sp,4
 40010f4:	f800283a 	ret

040010f8 <xQueueGenericReset>:
    taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
 40010f8:	defffb04 	addi	sp,sp,-20
 40010fc:	dfc00415 	stw	ra,16(sp)
 4001100:	df000315 	stw	fp,12(sp)
 4001104:	df000304 	addi	fp,sp,12
 4001108:	e13ffe15 	stw	r4,-8(fp)
 400110c:	e17ffd15 	stw	r5,-12(fp)
    Queue_t * const pxQueue = xQueue;
 4001110:	e0bffe17 	ldw	r2,-8(fp)
 4001114:	e0bfff15 	stw	r2,-4(fp)

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
 4001118:	40050480 	call	4005048 <vTaskEnterCritical>
    {
        pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 400111c:	e0bfff17 	ldw	r2,-4(fp)
 4001120:	10c00017 	ldw	r3,0(r2)
 4001124:	e0bfff17 	ldw	r2,-4(fp)
 4001128:	11000f17 	ldw	r4,60(r2)
 400112c:	e0bfff17 	ldw	r2,-4(fp)
 4001130:	10801017 	ldw	r2,64(r2)
 4001134:	2085383a 	mul	r2,r4,r2
 4001138:	1887883a 	add	r3,r3,r2
 400113c:	e0bfff17 	ldw	r2,-4(fp)
 4001140:	10c00215 	stw	r3,8(r2)
        pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 4001144:	e0bfff17 	ldw	r2,-4(fp)
 4001148:	10000e15 	stw	zero,56(r2)
        pxQueue->pcWriteTo = pxQueue->pcHead;
 400114c:	e0bfff17 	ldw	r2,-4(fp)
 4001150:	10c00017 	ldw	r3,0(r2)
 4001154:	e0bfff17 	ldw	r2,-4(fp)
 4001158:	10c00115 	stw	r3,4(r2)
        pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 400115c:	e0bfff17 	ldw	r2,-4(fp)
 4001160:	10c00017 	ldw	r3,0(r2)
 4001164:	e0bfff17 	ldw	r2,-4(fp)
 4001168:	10800f17 	ldw	r2,60(r2)
 400116c:	113fffc4 	addi	r4,r2,-1
 4001170:	e0bfff17 	ldw	r2,-4(fp)
 4001174:	10801017 	ldw	r2,64(r2)
 4001178:	2085383a 	mul	r2,r4,r2
 400117c:	1887883a 	add	r3,r3,r2
 4001180:	e0bfff17 	ldw	r2,-4(fp)
 4001184:	10c00315 	stw	r3,12(r2)
        pxQueue->cRxLock = queueUNLOCKED;
 4001188:	e0bfff17 	ldw	r2,-4(fp)
 400118c:	00ffffc4 	movi	r3,-1
 4001190:	10c01105 	stb	r3,68(r2)
        pxQueue->cTxLock = queueUNLOCKED;
 4001194:	e0bfff17 	ldw	r2,-4(fp)
 4001198:	00ffffc4 	movi	r3,-1
 400119c:	10c01145 	stb	r3,69(r2)

        if( xNewQueue == pdFALSE )
 40011a0:	e0bffd17 	ldw	r2,-12(fp)
 40011a4:	10000a1e 	bne	r2,zero,40011d0 <xQueueGenericReset+0xd8>
            /* If there are tasks blocked waiting to read from the queue, then
             * the tasks will remain blocked as after this function exits the queue
             * will still be empty.  If there are tasks blocked waiting to write to
             * the queue, then one should be unblocked as after this function exits
             * it will be possible to write to it. */
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 40011a8:	e0bfff17 	ldw	r2,-4(fp)
 40011ac:	10800417 	ldw	r2,16(r2)
 40011b0:	10000f26 	beq	r2,zero,40011f0 <xQueueGenericReset+0xf8>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 40011b4:	e0bfff17 	ldw	r2,-4(fp)
 40011b8:	10800404 	addi	r2,r2,16
 40011bc:	1009883a 	mov	r4,r2
 40011c0:	40046ac0 	call	40046ac <xTaskRemoveFromEventList>
 40011c4:	10000a26 	beq	r2,zero,40011f0 <xQueueGenericReset+0xf8>
                {
                    queueYIELD_IF_USING_PREEMPTION();
 40011c8:	003b683a 	trap	0
 40011cc:	00000806 	br	40011f0 <xQueueGenericReset+0xf8>
            }
        }
        else
        {
            /* Ensure the event queues start in the correct state. */
            vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 40011d0:	e0bfff17 	ldw	r2,-4(fp)
 40011d4:	10800404 	addi	r2,r2,16
 40011d8:	1009883a 	mov	r4,r2
 40011dc:	4000e680 	call	4000e68 <vListInitialise>
            vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 40011e0:	e0bfff17 	ldw	r2,-4(fp)
 40011e4:	10800904 	addi	r2,r2,36
 40011e8:	1009883a 	mov	r4,r2
 40011ec:	4000e680 	call	4000e68 <vListInitialise>
        }
    }
    taskEXIT_CRITICAL();
 40011f0:	400509c0 	call	400509c <vTaskExitCritical>

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return pdPASS;
 40011f4:	00800044 	movi	r2,1
}
 40011f8:	e037883a 	mov	sp,fp
 40011fc:	dfc00117 	ldw	ra,4(sp)
 4001200:	df000017 	ldw	fp,0(sp)
 4001204:	dec00204 	addi	sp,sp,8
 4001208:	f800283a 	ret

0400120c <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
 400120c:	defff704 	addi	sp,sp,-36
 4001210:	dfc00815 	stw	ra,32(sp)
 4001214:	df000715 	stw	fp,28(sp)
 4001218:	df000704 	addi	fp,sp,28
 400121c:	e13ffc15 	stw	r4,-16(fp)
 4001220:	e17ffb15 	stw	r5,-20(fp)
 4001224:	3005883a 	mov	r2,r6
 4001228:	e0bffa05 	stb	r2,-24(fp)
        configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

        /* Allocate enough space to hold the maximum number of items that
         * can be in the queue at any time.  It is valid for uxItemSize to be
         * zero in the case the queue is used as a semaphore. */
        xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 400122c:	e0fffc17 	ldw	r3,-16(fp)
 4001230:	e0bffb17 	ldw	r2,-20(fp)
 4001234:	1885383a 	mul	r2,r3,r2
 4001238:	e0bfff15 	stw	r2,-4(fp)
         * alignment requirements of the Queue_t structure - which in this case
         * is an int8_t *.  Therefore, whenever the stack alignment requirements
         * are greater than or equal to the pointer to char requirements the cast
         * is safe.  In other cases alignment requirements are not strict (one or
         * two bytes). */
        pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
 400123c:	e0bfff17 	ldw	r2,-4(fp)
 4001240:	10801204 	addi	r2,r2,72
 4001244:	1009883a 	mov	r4,r2
 4001248:	40006340 	call	4000634 <pvPortMalloc>
 400124c:	e0bffe15 	stw	r2,-8(fp)

        if( pxNewQueue != NULL )
 4001250:	e0bffe17 	ldw	r2,-8(fp)
 4001254:	10000d26 	beq	r2,zero,400128c <xQueueGenericCreate+0x80>
        {
            /* Jump past the queue structure to find the location of the queue
             * storage area. */
            pucQueueStorage = ( uint8_t * ) pxNewQueue;
 4001258:	e0bffe17 	ldw	r2,-8(fp)
 400125c:	e0bffd15 	stw	r2,-12(fp)
            pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 4001260:	e0bffd17 	ldw	r2,-12(fp)
 4001264:	10801204 	addi	r2,r2,72
 4001268:	e0bffd15 	stw	r2,-12(fp)
                     * deleted. */
                    pxNewQueue->ucStaticallyAllocated = pdFALSE;
                }
            #endif /* configSUPPORT_STATIC_ALLOCATION */

            prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 400126c:	e0fffa03 	ldbu	r3,-24(fp)
 4001270:	e0bffe17 	ldw	r2,-8(fp)
 4001274:	d8800015 	stw	r2,0(sp)
 4001278:	180f883a 	mov	r7,r3
 400127c:	e1bffd17 	ldw	r6,-12(fp)
 4001280:	e17ffb17 	ldw	r5,-20(fp)
 4001284:	e13ffc17 	ldw	r4,-16(fp)
 4001288:	40012a40 	call	40012a4 <prvInitialiseNewQueue>
        {
            traceQUEUE_CREATE_FAILED( ucQueueType );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
 400128c:	e0bffe17 	ldw	r2,-8(fp)
    }
 4001290:	e037883a 	mov	sp,fp
 4001294:	dfc00117 	ldw	ra,4(sp)
 4001298:	df000017 	ldw	fp,0(sp)
 400129c:	dec00204 	addi	sp,sp,8
 40012a0:	f800283a 	ret

040012a4 <prvInitialiseNewQueue>:
static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
                                   const UBaseType_t uxItemSize,
                                   uint8_t * pucQueueStorage,
                                   const uint8_t ucQueueType,
                                   Queue_t * pxNewQueue )
{
 40012a4:	defffa04 	addi	sp,sp,-24
 40012a8:	dfc00515 	stw	ra,20(sp)
 40012ac:	df000415 	stw	fp,16(sp)
 40012b0:	df000404 	addi	fp,sp,16
 40012b4:	e13fff15 	stw	r4,-4(fp)
 40012b8:	e17ffe15 	stw	r5,-8(fp)
 40012bc:	e1bffd15 	stw	r6,-12(fp)
 40012c0:	3805883a 	mov	r2,r7
 40012c4:	e0bffc05 	stb	r2,-16(fp)
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
 40012c8:	e0bffe17 	ldw	r2,-8(fp)
 40012cc:	1000041e 	bne	r2,zero,40012e0 <prvInitialiseNewQueue+0x3c>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 40012d0:	e0800217 	ldw	r2,8(fp)
 40012d4:	e0c00217 	ldw	r3,8(fp)
 40012d8:	10c00015 	stw	r3,0(r2)
 40012dc:	00000306 	br	40012ec <prvInitialiseNewQueue+0x48>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 40012e0:	e0800217 	ldw	r2,8(fp)
 40012e4:	e0fffd17 	ldw	r3,-12(fp)
 40012e8:	10c00015 	stw	r3,0(r2)
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
 40012ec:	e0800217 	ldw	r2,8(fp)
 40012f0:	e0ffff17 	ldw	r3,-4(fp)
 40012f4:	10c00f15 	stw	r3,60(r2)
    pxNewQueue->uxItemSize = uxItemSize;
 40012f8:	e0800217 	ldw	r2,8(fp)
 40012fc:	e0fffe17 	ldw	r3,-8(fp)
 4001300:	10c01015 	stw	r3,64(r2)
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 4001304:	01400044 	movi	r5,1
 4001308:	e1000217 	ldw	r4,8(fp)
 400130c:	40010f80 	call	40010f8 <xQueueGenericReset>
            pxNewQueue->pxQueueSetContainer = NULL;
        }
    #endif /* configUSE_QUEUE_SETS */

    traceQUEUE_CREATE( pxNewQueue );
}
 4001310:	0001883a 	nop
 4001314:	e037883a 	mov	sp,fp
 4001318:	dfc00117 	ldw	ra,4(sp)
 400131c:	df000017 	ldw	fp,0(sp)
 4001320:	dec00204 	addi	sp,sp,8
 4001324:	f800283a 	ret

04001328 <prvInitialiseMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    static void prvInitialiseMutex( Queue_t * pxNewQueue )
    {
 4001328:	defffd04 	addi	sp,sp,-12
 400132c:	dfc00215 	stw	ra,8(sp)
 4001330:	df000115 	stw	fp,4(sp)
 4001334:	df000104 	addi	fp,sp,4
 4001338:	e13fff15 	stw	r4,-4(fp)
        if( pxNewQueue != NULL )
 400133c:	e0bfff17 	ldw	r2,-4(fp)
 4001340:	10000b26 	beq	r2,zero,4001370 <prvInitialiseMutex+0x48>
        {
            /* The queue create function will set all the queue structure members
            * correctly for a generic queue, but this function is creating a
            * mutex.  Overwrite those members that need to be set differently -
            * in particular the information required for priority inheritance. */
            pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
 4001344:	e0bfff17 	ldw	r2,-4(fp)
 4001348:	10000215 	stw	zero,8(r2)
            pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 400134c:	e0bfff17 	ldw	r2,-4(fp)
 4001350:	10000015 	stw	zero,0(r2)

            /* In case this is a recursive mutex. */
            pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
 4001354:	e0bfff17 	ldw	r2,-4(fp)
 4001358:	10000315 	stw	zero,12(r2)

            traceCREATE_MUTEX( pxNewQueue );

            /* Start with the semaphore in the expected state. */
            ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 400135c:	000f883a 	mov	r7,zero
 4001360:	000d883a 	mov	r6,zero
 4001364:	000b883a 	mov	r5,zero
 4001368:	e13fff17 	ldw	r4,-4(fp)
 400136c:	40015680 	call	4001568 <xQueueGenericSend>
        }
        else
        {
            traceCREATE_MUTEX_FAILED();
        }
    }
 4001370:	0001883a 	nop
 4001374:	e037883a 	mov	sp,fp
 4001378:	dfc00117 	ldw	ra,4(sp)
 400137c:	df000017 	ldw	fp,0(sp)
 4001380:	dec00204 	addi	sp,sp,8
 4001384:	f800283a 	ret

04001388 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

    QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
    {
 4001388:	defffa04 	addi	sp,sp,-24
 400138c:	dfc00515 	stw	ra,20(sp)
 4001390:	df000415 	stw	fp,16(sp)
 4001394:	df000404 	addi	fp,sp,16
 4001398:	2005883a 	mov	r2,r4
 400139c:	e0bffc05 	stb	r2,-16(fp)
        QueueHandle_t xNewQueue;
        const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 40013a0:	00800044 	movi	r2,1
 40013a4:	e0bfff15 	stw	r2,-4(fp)
 40013a8:	e03ffe15 	stw	zero,-8(fp)

        xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
 40013ac:	e0bffc03 	ldbu	r2,-16(fp)
 40013b0:	100d883a 	mov	r6,r2
 40013b4:	e17ffe17 	ldw	r5,-8(fp)
 40013b8:	e13fff17 	ldw	r4,-4(fp)
 40013bc:	400120c0 	call	400120c <xQueueGenericCreate>
 40013c0:	e0bffd15 	stw	r2,-12(fp)
        prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 40013c4:	e13ffd17 	ldw	r4,-12(fp)
 40013c8:	40013280 	call	4001328 <prvInitialiseMutex>

        return xNewQueue;
 40013cc:	e0bffd17 	ldw	r2,-12(fp)
    }
 40013d0:	e037883a 	mov	sp,fp
 40013d4:	dfc00117 	ldw	ra,4(sp)
 40013d8:	df000017 	ldw	fp,0(sp)
 40013dc:	dec00204 	addi	sp,sp,8
 40013e0:	f800283a 	ret

040013e4 <xQueueGiveMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

    BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
    {
 40013e4:	defffa04 	addi	sp,sp,-24
 40013e8:	dfc00515 	stw	ra,20(sp)
 40013ec:	df000415 	stw	fp,16(sp)
 40013f0:	dc000315 	stw	r16,12(sp)
 40013f4:	df000404 	addi	fp,sp,16
 40013f8:	e13ffc15 	stw	r4,-16(fp)
        BaseType_t xReturn;
        Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 40013fc:	e0bffc17 	ldw	r2,-16(fp)
 4001400:	e0bffd15 	stw	r2,-12(fp)
         * change outside of this task.  If this task does not hold the mutex then
         * pxMutexHolder can never coincidentally equal the tasks handle, and as
         * this is the only condition we are interested in it does not matter if
         * pxMutexHolder is accessed simultaneously by another task.  Therefore no
         * mutual exclusion is required to test the pxMutexHolder variable. */
        if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 4001404:	e0bffd17 	ldw	r2,-12(fp)
 4001408:	14000217 	ldw	r16,8(r2)
 400140c:	4004ca40 	call	4004ca4 <xTaskGetCurrentTaskHandle>
 4001410:	8080101e 	bne	r16,r2,4001454 <xQueueGiveMutexRecursive+0x70>
            /* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to
             * the task handle, therefore no underflow check is required.  Also,
             * uxRecursiveCallCount is only modified by the mutex holder, and as
             * there can only be one, no mutual exclusion is required to modify the
             * uxRecursiveCallCount member. */
            ( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
 4001414:	e0bffd17 	ldw	r2,-12(fp)
 4001418:	10800317 	ldw	r2,12(r2)
 400141c:	10ffffc4 	addi	r3,r2,-1
 4001420:	e0bffd17 	ldw	r2,-12(fp)
 4001424:	10c00315 	stw	r3,12(r2)

            /* Has the recursive call count unwound to 0? */
            if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
 4001428:	e0bffd17 	ldw	r2,-12(fp)
 400142c:	10800317 	ldw	r2,12(r2)
 4001430:	1000051e 	bne	r2,zero,4001448 <xQueueGiveMutexRecursive+0x64>
            {
                /* Return the mutex.  This will automatically unblock any other
                 * task that might be waiting to access the mutex. */
                ( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 4001434:	000f883a 	mov	r7,zero
 4001438:	000d883a 	mov	r6,zero
 400143c:	000b883a 	mov	r5,zero
 4001440:	e13ffd17 	ldw	r4,-12(fp)
 4001444:	40015680 	call	4001568 <xQueueGenericSend>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            xReturn = pdPASS;
 4001448:	00800044 	movi	r2,1
 400144c:	e0bffe15 	stw	r2,-8(fp)
 4001450:	00000106 	br	4001458 <xQueueGiveMutexRecursive+0x74>
        }
        else
        {
            /* The mutex cannot be given because the calling task is not the
             * holder. */
            xReturn = pdFAIL;
 4001454:	e03ffe15 	stw	zero,-8(fp)

            traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
        }

        return xReturn;
 4001458:	e0bffe17 	ldw	r2,-8(fp)
    }
 400145c:	e6ffff04 	addi	sp,fp,-4
 4001460:	dfc00217 	ldw	ra,8(sp)
 4001464:	df000117 	ldw	fp,4(sp)
 4001468:	dc000017 	ldw	r16,0(sp)
 400146c:	dec00304 	addi	sp,sp,12
 4001470:	f800283a 	ret

04001474 <xQueueTakeMutexRecursive>:

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

    BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex,
                                         TickType_t xTicksToWait )
    {
 4001474:	defff904 	addi	sp,sp,-28
 4001478:	dfc00615 	stw	ra,24(sp)
 400147c:	df000515 	stw	fp,20(sp)
 4001480:	dc000415 	stw	r16,16(sp)
 4001484:	df000504 	addi	fp,sp,20
 4001488:	e13ffc15 	stw	r4,-16(fp)
 400148c:	e17ffb15 	stw	r5,-20(fp)
        BaseType_t xReturn;
        Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 4001490:	e0bffc17 	ldw	r2,-16(fp)
 4001494:	e0bffd15 	stw	r2,-12(fp)
        /* Comments regarding mutual exclusion as per those within
         * xQueueGiveMutexRecursive(). */

        traceTAKE_MUTEX_RECURSIVE( pxMutex );

        if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 4001498:	e0bffd17 	ldw	r2,-12(fp)
 400149c:	14000217 	ldw	r16,8(r2)
 40014a0:	4004ca40 	call	4004ca4 <xTaskGetCurrentTaskHandle>
 40014a4:	8080081e 	bne	r16,r2,40014c8 <xQueueTakeMutexRecursive+0x54>
        {
            ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 40014a8:	e0bffd17 	ldw	r2,-12(fp)
 40014ac:	10800317 	ldw	r2,12(r2)
 40014b0:	10c00044 	addi	r3,r2,1
 40014b4:	e0bffd17 	ldw	r2,-12(fp)
 40014b8:	10c00315 	stw	r3,12(r2)
            xReturn = pdPASS;
 40014bc:	00800044 	movi	r2,1
 40014c0:	e0bffe15 	stw	r2,-8(fp)
 40014c4:	00000b06 	br	40014f4 <xQueueTakeMutexRecursive+0x80>
        }
        else
        {
            xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
 40014c8:	e17ffb17 	ldw	r5,-20(fp)
 40014cc:	e13ffd17 	ldw	r4,-12(fp)
 40014d0:	4001a940 	call	4001a94 <xQueueSemaphoreTake>
 40014d4:	e0bffe15 	stw	r2,-8(fp)

            /* pdPASS will only be returned if the mutex was successfully
             * obtained.  The calling task may have entered the Blocked state
             * before reaching here. */
            if( xReturn != pdFAIL )
 40014d8:	e0bffe17 	ldw	r2,-8(fp)
 40014dc:	10000526 	beq	r2,zero,40014f4 <xQueueTakeMutexRecursive+0x80>
            {
                ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 40014e0:	e0bffd17 	ldw	r2,-12(fp)
 40014e4:	10800317 	ldw	r2,12(r2)
 40014e8:	10c00044 	addi	r3,r2,1
 40014ec:	e0bffd17 	ldw	r2,-12(fp)
 40014f0:	10c00315 	stw	r3,12(r2)
            {
                traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
            }
        }

        return xReturn;
 40014f4:	e0bffe17 	ldw	r2,-8(fp)
    }
 40014f8:	e6ffff04 	addi	sp,fp,-4
 40014fc:	dfc00217 	ldw	ra,8(sp)
 4001500:	df000117 	ldw	fp,4(sp)
 4001504:	dc000017 	ldw	r16,0(sp)
 4001508:	dec00304 	addi	sp,sp,12
 400150c:	f800283a 	ret

04001510 <xQueueCreateCountingSemaphore>:

#if ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

    QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount,
                                                 const UBaseType_t uxInitialCount )
    {
 4001510:	defffb04 	addi	sp,sp,-20
 4001514:	dfc00415 	stw	ra,16(sp)
 4001518:	df000315 	stw	fp,12(sp)
 400151c:	df000304 	addi	fp,sp,12
 4001520:	e13ffe15 	stw	r4,-8(fp)
 4001524:	e17ffd15 	stw	r5,-12(fp)
        QueueHandle_t xHandle;

        configASSERT( uxMaxCount != 0 );
        configASSERT( uxInitialCount <= uxMaxCount );

        xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
 4001528:	01800084 	movi	r6,2
 400152c:	000b883a 	mov	r5,zero
 4001530:	e13ffe17 	ldw	r4,-8(fp)
 4001534:	400120c0 	call	400120c <xQueueGenericCreate>
 4001538:	e0bfff15 	stw	r2,-4(fp)

        if( xHandle != NULL )
 400153c:	e0bfff17 	ldw	r2,-4(fp)
 4001540:	10000326 	beq	r2,zero,4001550 <xQueueCreateCountingSemaphore+0x40>
        {
            ( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 4001544:	e0bfff17 	ldw	r2,-4(fp)
 4001548:	e0fffd17 	ldw	r3,-12(fp)
 400154c:	10c00e15 	stw	r3,56(r2)
        else
        {
            traceCREATE_COUNTING_SEMAPHORE_FAILED();
        }

        return xHandle;
 4001550:	e0bfff17 	ldw	r2,-4(fp)
    }
 4001554:	e037883a 	mov	sp,fp
 4001558:	dfc00117 	ldw	ra,4(sp)
 400155c:	df000017 	ldw	fp,0(sp)
 4001560:	dec00204 	addi	sp,sp,8
 4001564:	f800283a 	ret

04001568 <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
 4001568:	defff504 	addi	sp,sp,-44
 400156c:	dfc00a15 	stw	ra,40(sp)
 4001570:	df000915 	stw	fp,36(sp)
 4001574:	df000904 	addi	fp,sp,36
 4001578:	e13ffa15 	stw	r4,-24(fp)
 400157c:	e17ff915 	stw	r5,-28(fp)
 4001580:	e1bff815 	stw	r6,-32(fp)
 4001584:	e1fff715 	stw	r7,-36(fp)
    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 4001588:	e03fff15 	stw	zero,-4(fp)
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
 400158c:	e0bffa17 	ldw	r2,-24(fp)
 4001590:	e0bffe15 	stw	r2,-8(fp)
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
 4001594:	40050480 	call	4005048 <vTaskEnterCritical>
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 4001598:	e0bffe17 	ldw	r2,-8(fp)
 400159c:	10c00e17 	ldw	r3,56(r2)
 40015a0:	e0bffe17 	ldw	r2,-8(fp)
 40015a4:	10800f17 	ldw	r2,60(r2)
 40015a8:	18800336 	bltu	r3,r2,40015b8 <xQueueGenericSend+0x50>
 40015ac:	e0bff717 	ldw	r2,-36(fp)
 40015b0:	10800098 	cmpnei	r2,r2,2
 40015b4:	1000151e 	bne	r2,zero,400160c <xQueueGenericSend+0xa4>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 40015b8:	e1bff717 	ldw	r6,-36(fp)
 40015bc:	e17ff917 	ldw	r5,-28(fp)
 40015c0:	e13ffe17 	ldw	r4,-8(fp)
 40015c4:	400210c0 	call	400210c <prvCopyDataToQueue>
 40015c8:	e0bffd15 	stw	r2,-12(fp)

                        /* If there was a task waiting for data to arrive on the
                         * queue then unblock it now. */
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 40015cc:	e0bffe17 	ldw	r2,-8(fp)
 40015d0:	10800917 	ldw	r2,36(r2)
 40015d4:	10000726 	beq	r2,zero,40015f4 <xQueueGenericSend+0x8c>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 40015d8:	e0bffe17 	ldw	r2,-8(fp)
 40015dc:	10800904 	addi	r2,r2,36
 40015e0:	1009883a 	mov	r4,r2
 40015e4:	40046ac0 	call	40046ac <xTaskRemoveFromEventList>
 40015e8:	10000526 	beq	r2,zero,4001600 <xQueueGenericSend+0x98>
                            {
                                /* The unblocked task has a priority higher than
                                 * our own so yield immediately.  Yes it is ok to do
                                 * this from within the critical section - the kernel
                                 * takes care of that. */
                                queueYIELD_IF_USING_PREEMPTION();
 40015ec:	003b683a 	trap	0
 40015f0:	00000306 	br	4001600 <xQueueGenericSend+0x98>
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }
                        }
                        else if( xYieldRequired != pdFALSE )
 40015f4:	e0bffd17 	ldw	r2,-12(fp)
 40015f8:	10000126 	beq	r2,zero,4001600 <xQueueGenericSend+0x98>
                        {
                            /* This path is a special case that will only get
                             * executed if the task was holding multiple mutexes and
                             * the mutexes were given back in an order that is
                             * different to that in which they were taken. */
                            queueYIELD_IF_USING_PREEMPTION();
 40015fc:	003b683a 	trap	0
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
 4001600:	400509c0 	call	400509c <vTaskExitCritical>
                return pdPASS;
 4001604:	00800044 	movi	r2,1
 4001608:	00003f06 	br	4001708 <xQueueGenericSend+0x1a0>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
 400160c:	e0bff817 	ldw	r2,-32(fp)
 4001610:	1000031e 	bne	r2,zero,4001620 <xQueueGenericSend+0xb8>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
 4001614:	400509c0 	call	400509c <vTaskExitCritical>

                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
 4001618:	0005883a 	mov	r2,zero
 400161c:	00003a06 	br	4001708 <xQueueGenericSend+0x1a0>
                }
                else if( xEntryTimeSet == pdFALSE )
 4001620:	e0bfff17 	ldw	r2,-4(fp)
 4001624:	1000051e 	bne	r2,zero,400163c <xQueueGenericSend+0xd4>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
 4001628:	e0bffb04 	addi	r2,fp,-20
 400162c:	1009883a 	mov	r4,r2
 4001630:	40048b40 	call	40048b4 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
 4001634:	00800044 	movi	r2,1
 4001638:	e0bfff15 	stw	r2,-4(fp)
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
 400163c:	400509c0 	call	400509c <vTaskExitCritical>

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
 4001640:	40041000 	call	4004100 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
 4001644:	40050480 	call	4005048 <vTaskEnterCritical>
 4001648:	e0bffe17 	ldw	r2,-8(fp)
 400164c:	10801103 	ldbu	r2,68(r2)
 4001650:	10803fcc 	andi	r2,r2,255
 4001654:	1080201c 	xori	r2,r2,128
 4001658:	10bfe004 	addi	r2,r2,-128
 400165c:	10bfffd8 	cmpnei	r2,r2,-1
 4001660:	1000021e 	bne	r2,zero,400166c <xQueueGenericSend+0x104>
 4001664:	e0bffe17 	ldw	r2,-8(fp)
 4001668:	10001105 	stb	zero,68(r2)
 400166c:	e0bffe17 	ldw	r2,-8(fp)
 4001670:	10801143 	ldbu	r2,69(r2)
 4001674:	10803fcc 	andi	r2,r2,255
 4001678:	1080201c 	xori	r2,r2,128
 400167c:	10bfe004 	addi	r2,r2,-128
 4001680:	10bfffd8 	cmpnei	r2,r2,-1
 4001684:	1000021e 	bne	r2,zero,4001690 <xQueueGenericSend+0x128>
 4001688:	e0bffe17 	ldw	r2,-8(fp)
 400168c:	10001145 	stb	zero,69(r2)
 4001690:	400509c0 	call	400509c <vTaskExitCritical>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 4001694:	e0fff804 	addi	r3,fp,-32
 4001698:	e0bffb04 	addi	r2,fp,-20
 400169c:	180b883a 	mov	r5,r3
 40016a0:	1009883a 	mov	r4,r2
 40016a4:	40048f00 	call	40048f0 <xTaskCheckForTimeOut>
 40016a8:	1000131e 	bne	r2,zero,40016f8 <xQueueGenericSend+0x190>
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
 40016ac:	e13ffe17 	ldw	r4,-8(fp)
 40016b0:	40024c00 	call	40024c0 <prvIsQueueFull>
 40016b4:	10000c26 	beq	r2,zero,40016e8 <xQueueGenericSend+0x180>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 40016b8:	e0bffe17 	ldw	r2,-8(fp)
 40016bc:	10800404 	addi	r2,r2,16
 40016c0:	e0fff817 	ldw	r3,-32(fp)
 40016c4:	180b883a 	mov	r5,r3
 40016c8:	1009883a 	mov	r4,r2
 40016cc:	40045f80 	call	40045f8 <vTaskPlaceOnEventList>
                /* Unlocking the queue means queue events can effect the
                 * event list.  It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready last instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
 40016d0:	e13ffe17 	ldw	r4,-8(fp)
 40016d4:	40023340 	call	4002334 <prvUnlockQueue>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in a ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
 40016d8:	400412c0 	call	400412c <xTaskResumeAll>
 40016dc:	103fad1e 	bne	r2,zero,4001594 <xQueueGenericSend+0x2c>
                {
                    portYIELD_WITHIN_API();
 40016e0:	003b683a 	trap	0
 40016e4:	003fab06 	br	4001594 <xQueueGenericSend+0x2c>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
 40016e8:	e13ffe17 	ldw	r4,-8(fp)
 40016ec:	40023340 	call	4002334 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
 40016f0:	400412c0 	call	400412c <xTaskResumeAll>
 40016f4:	003fa706 	br	4001594 <xQueueGenericSend+0x2c>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
 40016f8:	e13ffe17 	ldw	r4,-8(fp)
 40016fc:	40023340 	call	4002334 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
 4001700:	400412c0 	call	400412c <xTaskResumeAll>

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
 4001704:	0005883a 	mov	r2,zero
        }
    } /*lint -restore */
}
 4001708:	e037883a 	mov	sp,fp
 400170c:	dfc00117 	ldw	ra,4(sp)
 4001710:	df000017 	ldw	fp,0(sp)
 4001714:	dec00204 	addi	sp,sp,8
 4001718:	f800283a 	ret

0400171c <xQueueGenericSendFromISR>:

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
                                     const void * const pvItemToQueue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const BaseType_t xCopyPosition )
{
 400171c:	defff504 	addi	sp,sp,-44
 4001720:	dfc00a15 	stw	ra,40(sp)
 4001724:	df000915 	stw	fp,36(sp)
 4001728:	df000904 	addi	fp,sp,36
 400172c:	e13ffa15 	stw	r4,-24(fp)
 4001730:	e17ff915 	stw	r5,-28(fp)
 4001734:	e1bff815 	stw	r6,-32(fp)
 4001738:	e1fff715 	stw	r7,-36(fp)
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
 400173c:	e0bffa17 	ldw	r2,-24(fp)
 4001740:	e0bffe15 	stw	r2,-8(fp)
    /* Similar to xQueueGenericSend, except without blocking if there is no room
     * in the queue.  Also don't directly wake a task that was blocked on a queue
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 4001744:	e03ffd15 	stw	zero,-12(fp)
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 4001748:	e0bffe17 	ldw	r2,-8(fp)
 400174c:	10c00e17 	ldw	r3,56(r2)
 4001750:	e0bffe17 	ldw	r2,-8(fp)
 4001754:	10800f17 	ldw	r2,60(r2)
 4001758:	18800336 	bltu	r3,r2,4001768 <xQueueGenericSendFromISR+0x4c>
 400175c:	e0bff717 	ldw	r2,-36(fp)
 4001760:	10800098 	cmpnei	r2,r2,2
 4001764:	1000231e 	bne	r2,zero,40017f4 <xQueueGenericSendFromISR+0xd8>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
 4001768:	e0bffe17 	ldw	r2,-8(fp)
 400176c:	10801143 	ldbu	r2,69(r2)
 4001770:	e0bffcc5 	stb	r2,-13(fp)
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 4001774:	e0bffe17 	ldw	r2,-8(fp)
 4001778:	10800e17 	ldw	r2,56(r2)
 400177c:	e0bffb15 	stw	r2,-20(fp)
            /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
             *  in a task disinheriting a priority and prvCopyDataToQueue() can be
             *  called here even though the disinherit function does not check if
             *  the scheduler is suspended before accessing the ready lists. */
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 4001780:	e1bff717 	ldw	r6,-36(fp)
 4001784:	e17ff917 	ldw	r5,-28(fp)
 4001788:	e13ffe17 	ldw	r4,-8(fp)
 400178c:	400210c0 	call	400210c <prvCopyDataToQueue>

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
 4001790:	e0bffcc7 	ldb	r2,-13(fp)
 4001794:	10bfffd8 	cmpnei	r2,r2,-1
 4001798:	10000e1e 	bne	r2,zero,40017d4 <xQueueGenericSendFromISR+0xb8>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 400179c:	e0bffe17 	ldw	r2,-8(fp)
 40017a0:	10800917 	ldw	r2,36(r2)
 40017a4:	10001026 	beq	r2,zero,40017e8 <xQueueGenericSendFromISR+0xcc>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 40017a8:	e0bffe17 	ldw	r2,-8(fp)
 40017ac:	10800904 	addi	r2,r2,36
 40017b0:	1009883a 	mov	r4,r2
 40017b4:	40046ac0 	call	40046ac <xTaskRemoveFromEventList>
 40017b8:	10000b26 	beq	r2,zero,40017e8 <xQueueGenericSendFromISR+0xcc>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
 40017bc:	e0bff817 	ldw	r2,-32(fp)
 40017c0:	10000926 	beq	r2,zero,40017e8 <xQueueGenericSendFromISR+0xcc>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
 40017c4:	e0bff817 	ldw	r2,-32(fp)
 40017c8:	00c00044 	movi	r3,1
 40017cc:	10c00015 	stw	r3,0(r2)
 40017d0:	00000506 	br	40017e8 <xQueueGenericSendFromISR+0xcc>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 40017d4:	e0bffcc3 	ldbu	r2,-13(fp)
 40017d8:	10800044 	addi	r2,r2,1
 40017dc:	1007883a 	mov	r3,r2
 40017e0:	e0bffe17 	ldw	r2,-8(fp)
 40017e4:	10c01145 	stb	r3,69(r2)
            }

            xReturn = pdPASS;
 40017e8:	00800044 	movi	r2,1
 40017ec:	e0bfff15 	stw	r2,-4(fp)
        {
 40017f0:	00000106 	br	40017f8 <xQueueGenericSendFromISR+0xdc>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
 40017f4:	e03fff15 	stw	zero,-4(fp)
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
 40017f8:	e0bfff17 	ldw	r2,-4(fp)
}
 40017fc:	e037883a 	mov	sp,fp
 4001800:	dfc00117 	ldw	ra,4(sp)
 4001804:	df000017 	ldw	fp,0(sp)
 4001808:	dec00204 	addi	sp,sp,8
 400180c:	f800283a 	ret

04001810 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
                              BaseType_t * const pxHigherPriorityTaskWoken )
{
 4001810:	defff704 	addi	sp,sp,-36
 4001814:	dfc00815 	stw	ra,32(sp)
 4001818:	df000715 	stw	fp,28(sp)
 400181c:	df000704 	addi	fp,sp,28
 4001820:	e13ffa15 	stw	r4,-24(fp)
 4001824:	e17ff915 	stw	r5,-28(fp)
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
 4001828:	e0bffa17 	ldw	r2,-24(fp)
 400182c:	e0bffe15 	stw	r2,-8(fp)
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 4001830:	e03ffd15 	stw	zero,-12(fp)
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 4001834:	e0bffe17 	ldw	r2,-8(fp)
 4001838:	10800e17 	ldw	r2,56(r2)
 400183c:	e0bffc15 	stw	r2,-16(fp)

        /* When the queue is used to implement a semaphore no data is ever
         * moved through the queue but it is still valid to see if the queue 'has
         * space'. */
        if( uxMessagesWaiting < pxQueue->uxLength )
 4001840:	e0bffe17 	ldw	r2,-8(fp)
 4001844:	10800f17 	ldw	r2,60(r2)
 4001848:	e0fffc17 	ldw	r3,-16(fp)
 400184c:	1880202e 	bgeu	r3,r2,40018d0 <xQueueGiveFromISR+0xc0>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
 4001850:	e0bffe17 	ldw	r2,-8(fp)
 4001854:	10801143 	ldbu	r2,69(r2)
 4001858:	e0bffbc5 	stb	r2,-17(fp)
             * holder - and if there is a mutex holder then the mutex cannot be
             * given from an ISR.  As this is the ISR version of the function it
             * can be assumed there is no mutex holder and no need to determine if
             * priority disinheritance is needed.  Simply increase the count of
             * messages (semaphores) available. */
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 400185c:	e0bffc17 	ldw	r2,-16(fp)
 4001860:	10c00044 	addi	r3,r2,1
 4001864:	e0bffe17 	ldw	r2,-8(fp)
 4001868:	10c00e15 	stw	r3,56(r2)

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
 400186c:	e0bffbc7 	ldb	r2,-17(fp)
 4001870:	10bfffd8 	cmpnei	r2,r2,-1
 4001874:	10000e1e 	bne	r2,zero,40018b0 <xQueueGiveFromISR+0xa0>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 4001878:	e0bffe17 	ldw	r2,-8(fp)
 400187c:	10800917 	ldw	r2,36(r2)
 4001880:	10001026 	beq	r2,zero,40018c4 <xQueueGiveFromISR+0xb4>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 4001884:	e0bffe17 	ldw	r2,-8(fp)
 4001888:	10800904 	addi	r2,r2,36
 400188c:	1009883a 	mov	r4,r2
 4001890:	40046ac0 	call	40046ac <xTaskRemoveFromEventList>
 4001894:	10000b26 	beq	r2,zero,40018c4 <xQueueGiveFromISR+0xb4>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
 4001898:	e0bff917 	ldw	r2,-28(fp)
 400189c:	10000926 	beq	r2,zero,40018c4 <xQueueGiveFromISR+0xb4>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
 40018a0:	e0bff917 	ldw	r2,-28(fp)
 40018a4:	00c00044 	movi	r3,1
 40018a8:	10c00015 	stw	r3,0(r2)
 40018ac:	00000506 	br	40018c4 <xQueueGiveFromISR+0xb4>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 40018b0:	e0bffbc3 	ldbu	r2,-17(fp)
 40018b4:	10800044 	addi	r2,r2,1
 40018b8:	1007883a 	mov	r3,r2
 40018bc:	e0bffe17 	ldw	r2,-8(fp)
 40018c0:	10c01145 	stb	r3,69(r2)
            }

            xReturn = pdPASS;
 40018c4:	00800044 	movi	r2,1
 40018c8:	e0bfff15 	stw	r2,-4(fp)
 40018cc:	00000106 	br	40018d4 <xQueueGiveFromISR+0xc4>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
 40018d0:	e03fff15 	stw	zero,-4(fp)
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
 40018d4:	e0bfff17 	ldw	r2,-4(fp)
}
 40018d8:	e037883a 	mov	sp,fp
 40018dc:	dfc00117 	ldw	ra,4(sp)
 40018e0:	df000017 	ldw	fp,0(sp)
 40018e4:	dec00204 	addi	sp,sp,8
 40018e8:	f800283a 	ret

040018ec <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
 40018ec:	defff604 	addi	sp,sp,-40
 40018f0:	dfc00915 	stw	ra,36(sp)
 40018f4:	df000815 	stw	fp,32(sp)
 40018f8:	df000804 	addi	fp,sp,32
 40018fc:	e13ffa15 	stw	r4,-24(fp)
 4001900:	e17ff915 	stw	r5,-28(fp)
 4001904:	e1bff815 	stw	r6,-32(fp)
    BaseType_t xEntryTimeSet = pdFALSE;
 4001908:	e03fff15 	stw	zero,-4(fp)
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
 400190c:	e0bffa17 	ldw	r2,-24(fp)
 4001910:	e0bffe15 	stw	r2,-8(fp)
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
 4001914:	40050480 	call	4005048 <vTaskEnterCritical>
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 4001918:	e0bffe17 	ldw	r2,-8(fp)
 400191c:	10800e17 	ldw	r2,56(r2)
 4001920:	e0bffd15 	stw	r2,-12(fp)

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 4001924:	e0bffd17 	ldw	r2,-12(fp)
 4001928:	10001326 	beq	r2,zero,4001978 <xQueueReceive+0x8c>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
 400192c:	e17ff917 	ldw	r5,-28(fp)
 4001930:	e13ffe17 	ldw	r4,-8(fp)
 4001934:	40022980 	call	4002298 <prvCopyDataFromQueue>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 4001938:	e0bffd17 	ldw	r2,-12(fp)
 400193c:	10ffffc4 	addi	r3,r2,-1
 4001940:	e0bffe17 	ldw	r2,-8(fp)
 4001944:	10c00e15 	stw	r3,56(r2)

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 4001948:	e0bffe17 	ldw	r2,-8(fp)
 400194c:	10800417 	ldw	r2,16(r2)
 4001950:	10000626 	beq	r2,zero,400196c <xQueueReceive+0x80>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 4001954:	e0bffe17 	ldw	r2,-8(fp)
 4001958:	10800404 	addi	r2,r2,16
 400195c:	1009883a 	mov	r4,r2
 4001960:	40046ac0 	call	40046ac <xTaskRemoveFromEventList>
 4001964:	10000126 	beq	r2,zero,400196c <xQueueReceive+0x80>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
 4001968:	003b683a 	trap	0
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
 400196c:	400509c0 	call	400509c <vTaskExitCritical>
                return pdPASS;
 4001970:	00800044 	movi	r2,1
 4001974:	00004206 	br	4001a80 <xQueueReceive+0x194>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
 4001978:	e0bff817 	ldw	r2,-32(fp)
 400197c:	1000031e 	bne	r2,zero,400198c <xQueueReceive+0xa0>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
 4001980:	400509c0 	call	400509c <vTaskExitCritical>
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
 4001984:	0005883a 	mov	r2,zero
 4001988:	00003d06 	br	4001a80 <xQueueReceive+0x194>
                }
                else if( xEntryTimeSet == pdFALSE )
 400198c:	e0bfff17 	ldw	r2,-4(fp)
 4001990:	1000051e 	bne	r2,zero,40019a8 <xQueueReceive+0xbc>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
 4001994:	e0bffb04 	addi	r2,fp,-20
 4001998:	1009883a 	mov	r4,r2
 400199c:	40048b40 	call	40048b4 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
 40019a0:	00800044 	movi	r2,1
 40019a4:	e0bfff15 	stw	r2,-4(fp)
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
 40019a8:	400509c0 	call	400509c <vTaskExitCritical>

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
 40019ac:	40041000 	call	4004100 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
 40019b0:	40050480 	call	4005048 <vTaskEnterCritical>
 40019b4:	e0bffe17 	ldw	r2,-8(fp)
 40019b8:	10801103 	ldbu	r2,68(r2)
 40019bc:	10803fcc 	andi	r2,r2,255
 40019c0:	1080201c 	xori	r2,r2,128
 40019c4:	10bfe004 	addi	r2,r2,-128
 40019c8:	10bfffd8 	cmpnei	r2,r2,-1
 40019cc:	1000021e 	bne	r2,zero,40019d8 <xQueueReceive+0xec>
 40019d0:	e0bffe17 	ldw	r2,-8(fp)
 40019d4:	10001105 	stb	zero,68(r2)
 40019d8:	e0bffe17 	ldw	r2,-8(fp)
 40019dc:	10801143 	ldbu	r2,69(r2)
 40019e0:	10803fcc 	andi	r2,r2,255
 40019e4:	1080201c 	xori	r2,r2,128
 40019e8:	10bfe004 	addi	r2,r2,-128
 40019ec:	10bfffd8 	cmpnei	r2,r2,-1
 40019f0:	1000021e 	bne	r2,zero,40019fc <xQueueReceive+0x110>
 40019f4:	e0bffe17 	ldw	r2,-8(fp)
 40019f8:	10001145 	stb	zero,69(r2)
 40019fc:	400509c0 	call	400509c <vTaskExitCritical>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 4001a00:	e0fff804 	addi	r3,fp,-32
 4001a04:	e0bffb04 	addi	r2,fp,-20
 4001a08:	180b883a 	mov	r5,r3
 4001a0c:	1009883a 	mov	r4,r2
 4001a10:	40048f00 	call	40048f0 <xTaskCheckForTimeOut>
 4001a14:	1000131e 	bne	r2,zero,4001a64 <xQueueReceive+0x178>
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 4001a18:	e13ffe17 	ldw	r4,-8(fp)
 4001a1c:	40024280 	call	4002428 <prvIsQueueEmpty>
 4001a20:	10000c26 	beq	r2,zero,4001a54 <xQueueReceive+0x168>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 4001a24:	e0bffe17 	ldw	r2,-8(fp)
 4001a28:	10800904 	addi	r2,r2,36
 4001a2c:	e0fff817 	ldw	r3,-32(fp)
 4001a30:	180b883a 	mov	r5,r3
 4001a34:	1009883a 	mov	r4,r2
 4001a38:	40045f80 	call	40045f8 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
 4001a3c:	e13ffe17 	ldw	r4,-8(fp)
 4001a40:	40023340 	call	4002334 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
 4001a44:	400412c0 	call	400412c <xTaskResumeAll>
 4001a48:	103fb21e 	bne	r2,zero,4001914 <xQueueReceive+0x28>
                {
                    portYIELD_WITHIN_API();
 4001a4c:	003b683a 	trap	0
 4001a50:	003fb006 	br	4001914 <xQueueReceive+0x28>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
 4001a54:	e13ffe17 	ldw	r4,-8(fp)
 4001a58:	40023340 	call	4002334 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
 4001a5c:	400412c0 	call	400412c <xTaskResumeAll>
 4001a60:	003fac06 	br	4001914 <xQueueReceive+0x28>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
 4001a64:	e13ffe17 	ldw	r4,-8(fp)
 4001a68:	40023340 	call	4002334 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
 4001a6c:	400412c0 	call	400412c <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 4001a70:	e13ffe17 	ldw	r4,-8(fp)
 4001a74:	40024280 	call	4002428 <prvIsQueueEmpty>
 4001a78:	103fa626 	beq	r2,zero,4001914 <xQueueReceive+0x28>
            {
                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
 4001a7c:	0005883a 	mov	r2,zero
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
 4001a80:	e037883a 	mov	sp,fp
 4001a84:	dfc00117 	ldw	ra,4(sp)
 4001a88:	df000017 	ldw	fp,0(sp)
 4001a8c:	dec00204 	addi	sp,sp,8
 4001a90:	f800283a 	ret

04001a94 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
                                TickType_t xTicksToWait )
{
 4001a94:	defff504 	addi	sp,sp,-44
 4001a98:	dfc00a15 	stw	ra,40(sp)
 4001a9c:	df000915 	stw	fp,36(sp)
 4001aa0:	df000904 	addi	fp,sp,36
 4001aa4:	e13ff815 	stw	r4,-32(fp)
 4001aa8:	e17ff715 	stw	r5,-36(fp)
    BaseType_t xEntryTimeSet = pdFALSE;
 4001aac:	e03fff15 	stw	zero,-4(fp)
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
 4001ab0:	e0bff817 	ldw	r2,-32(fp)
 4001ab4:	e0bffd15 	stw	r2,-12(fp)

    #if ( configUSE_MUTEXES == 1 )
        BaseType_t xInheritanceOccurred = pdFALSE;
 4001ab8:	e03ffe15 	stw	zero,-8(fp)
    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
     * statements within the function itself.  This is done in the interest
     * of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
 4001abc:	40050480 	call	4005048 <vTaskEnterCritical>
        {
            /* Semaphores are queues with an item size of 0, and where the
             * number of messages in the queue is the semaphore's count value. */
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
 4001ac0:	e0bffd17 	ldw	r2,-12(fp)
 4001ac4:	10800e17 	ldw	r2,56(r2)
 4001ac8:	e0bffc15 	stw	r2,-16(fp)

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
 4001acc:	e0bffc17 	ldw	r2,-16(fp)
 4001ad0:	10001726 	beq	r2,zero,4001b30 <xQueueSemaphoreTake+0x9c>
            {
                traceQUEUE_RECEIVE( pxQueue );

                /* Semaphores are queues with a data size of zero and where the
                 * messages waiting is the semaphore's count.  Reduce the count. */
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
 4001ad4:	e0bffc17 	ldw	r2,-16(fp)
 4001ad8:	10ffffc4 	addi	r3,r2,-1
 4001adc:	e0bffd17 	ldw	r2,-12(fp)
 4001ae0:	10c00e15 	stw	r3,56(r2)

                #if ( configUSE_MUTEXES == 1 )
                    {
                        if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 4001ae4:	e0bffd17 	ldw	r2,-12(fp)
 4001ae8:	10800017 	ldw	r2,0(r2)
 4001aec:	1000041e 	bne	r2,zero,4001b00 <xQueueSemaphoreTake+0x6c>
                        {
                            /* Record the information required to implement
                             * priority inheritance should it become necessary. */
                            pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
 4001af0:	40051440 	call	4005144 <pvTaskIncrementMutexHeldCount>
 4001af4:	1007883a 	mov	r3,r2
 4001af8:	e0bffd17 	ldw	r2,-12(fp)
 4001afc:	10c00215 	stw	r3,8(r2)
                    }
                #endif /* configUSE_MUTEXES */

                /* Check to see if other tasks are blocked waiting to give the
                 * semaphore, and if so, unblock the highest priority such task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 4001b00:	e0bffd17 	ldw	r2,-12(fp)
 4001b04:	10800417 	ldw	r2,16(r2)
 4001b08:	10000626 	beq	r2,zero,4001b24 <xQueueSemaphoreTake+0x90>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 4001b0c:	e0bffd17 	ldw	r2,-12(fp)
 4001b10:	10800404 	addi	r2,r2,16
 4001b14:	1009883a 	mov	r4,r2
 4001b18:	40046ac0 	call	40046ac <xTaskRemoveFromEventList>
 4001b1c:	10000126 	beq	r2,zero,4001b24 <xQueueSemaphoreTake+0x90>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
 4001b20:	003b683a 	trap	0
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
 4001b24:	400509c0 	call	400509c <vTaskExitCritical>
                return pdPASS;
 4001b28:	00800044 	movi	r2,1
 4001b2c:	00005806 	br	4001c90 <xQueueSemaphoreTake+0x1fc>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
 4001b30:	e0bff717 	ldw	r2,-36(fp)
 4001b34:	1000031e 	bne	r2,zero,4001b44 <xQueueSemaphoreTake+0xb0>
                        }
                    #endif /* configUSE_MUTEXES */

                    /* The semaphore count was 0 and no block time is specified
                     * (or the block time has expired) so exit now. */
                    taskEXIT_CRITICAL();
 4001b38:	400509c0 	call	400509c <vTaskExitCritical>
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
 4001b3c:	0005883a 	mov	r2,zero
 4001b40:	00005306 	br	4001c90 <xQueueSemaphoreTake+0x1fc>
                }
                else if( xEntryTimeSet == pdFALSE )
 4001b44:	e0bfff17 	ldw	r2,-4(fp)
 4001b48:	1000051e 	bne	r2,zero,4001b60 <xQueueSemaphoreTake+0xcc>
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
 4001b4c:	e0bff904 	addi	r2,fp,-28
 4001b50:	1009883a 	mov	r4,r2
 4001b54:	40048b40 	call	40048b4 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
 4001b58:	00800044 	movi	r2,1
 4001b5c:	e0bfff15 	stw	r2,-4(fp)
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
 4001b60:	400509c0 	call	400509c <vTaskExitCritical>

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
 4001b64:	40041000 	call	4004100 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
 4001b68:	40050480 	call	4005048 <vTaskEnterCritical>
 4001b6c:	e0bffd17 	ldw	r2,-12(fp)
 4001b70:	10801103 	ldbu	r2,68(r2)
 4001b74:	10803fcc 	andi	r2,r2,255
 4001b78:	1080201c 	xori	r2,r2,128
 4001b7c:	10bfe004 	addi	r2,r2,-128
 4001b80:	10bfffd8 	cmpnei	r2,r2,-1
 4001b84:	1000021e 	bne	r2,zero,4001b90 <xQueueSemaphoreTake+0xfc>
 4001b88:	e0bffd17 	ldw	r2,-12(fp)
 4001b8c:	10001105 	stb	zero,68(r2)
 4001b90:	e0bffd17 	ldw	r2,-12(fp)
 4001b94:	10801143 	ldbu	r2,69(r2)
 4001b98:	10803fcc 	andi	r2,r2,255
 4001b9c:	1080201c 	xori	r2,r2,128
 4001ba0:	10bfe004 	addi	r2,r2,-128
 4001ba4:	10bfffd8 	cmpnei	r2,r2,-1
 4001ba8:	1000021e 	bne	r2,zero,4001bb4 <xQueueSemaphoreTake+0x120>
 4001bac:	e0bffd17 	ldw	r2,-12(fp)
 4001bb0:	10001145 	stb	zero,69(r2)
 4001bb4:	400509c0 	call	400509c <vTaskExitCritical>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 4001bb8:	e0fff704 	addi	r3,fp,-36
 4001bbc:	e0bff904 	addi	r2,fp,-28
 4001bc0:	180b883a 	mov	r5,r3
 4001bc4:	1009883a 	mov	r4,r2
 4001bc8:	40048f00 	call	40048f0 <xTaskCheckForTimeOut>
 4001bcc:	10001d1e 	bne	r2,zero,4001c44 <xQueueSemaphoreTake+0x1b0>
        {
            /* A block time is specified and not expired.  If the semaphore
             * count is 0 then enter the Blocked state to wait for a semaphore to
             * become available.  As semaphores are implemented with queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 4001bd0:	e13ffd17 	ldw	r4,-12(fp)
 4001bd4:	40024280 	call	4002428 <prvIsQueueEmpty>
 4001bd8:	10001626 	beq	r2,zero,4001c34 <xQueueSemaphoreTake+0x1a0>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

                #if ( configUSE_MUTEXES == 1 )
                    {
                        if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 4001bdc:	e0bffd17 	ldw	r2,-12(fp)
 4001be0:	10800017 	ldw	r2,0(r2)
 4001be4:	1000071e 	bne	r2,zero,4001c04 <xQueueSemaphoreTake+0x170>
                        {
                            taskENTER_CRITICAL();
 4001be8:	40050480 	call	4005048 <vTaskEnterCritical>
                            {
                                xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
 4001bec:	e0bffd17 	ldw	r2,-12(fp)
 4001bf0:	10800217 	ldw	r2,8(r2)
 4001bf4:	1009883a 	mov	r4,r2
 4001bf8:	4004ccc0 	call	4004ccc <xTaskPriorityInherit>
 4001bfc:	e0bffe15 	stw	r2,-8(fp)
                            }
                            taskEXIT_CRITICAL();
 4001c00:	400509c0 	call	400509c <vTaskExitCritical>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 4001c04:	e0bffd17 	ldw	r2,-12(fp)
 4001c08:	10800904 	addi	r2,r2,36
 4001c0c:	e0fff717 	ldw	r3,-36(fp)
 4001c10:	180b883a 	mov	r5,r3
 4001c14:	1009883a 	mov	r4,r2
 4001c18:	40045f80 	call	40045f8 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
 4001c1c:	e13ffd17 	ldw	r4,-12(fp)
 4001c20:	40023340 	call	4002334 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
 4001c24:	400412c0 	call	400412c <xTaskResumeAll>
 4001c28:	103fa41e 	bne	r2,zero,4001abc <xQueueSemaphoreTake+0x28>
                {
                    portYIELD_WITHIN_API();
 4001c2c:	003b683a 	trap	0
 4001c30:	003fa206 	br	4001abc <xQueueSemaphoreTake+0x28>
            }
            else
            {
                /* There was no timeout and the semaphore count was not 0, so
                 * attempt to take the semaphore again. */
                prvUnlockQueue( pxQueue );
 4001c34:	e13ffd17 	ldw	r4,-12(fp)
 4001c38:	40023340 	call	4002334 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
 4001c3c:	400412c0 	call	400412c <xTaskResumeAll>
 4001c40:	003f9e06 	br	4001abc <xQueueSemaphoreTake+0x28>
            }
        }
        else
        {
            /* Timed out. */
            prvUnlockQueue( pxQueue );
 4001c44:	e13ffd17 	ldw	r4,-12(fp)
 4001c48:	40023340 	call	4002334 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
 4001c4c:	400412c0 	call	400412c <xTaskResumeAll>

            /* If the semaphore count is 0 exit now as the timeout has
             * expired.  Otherwise return to attempt to take the semaphore that is
             * known to be available.  As semaphores are implemented by queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 4001c50:	e13ffd17 	ldw	r4,-12(fp)
 4001c54:	40024280 	call	4002428 <prvIsQueueEmpty>
 4001c58:	103f9826 	beq	r2,zero,4001abc <xQueueSemaphoreTake+0x28>
                #if ( configUSE_MUTEXES == 1 )
                    {
                        /* xInheritanceOccurred could only have be set if
                         * pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
                         * test the mutex type again to check it is actually a mutex. */
                        if( xInheritanceOccurred != pdFALSE )
 4001c5c:	e0bffe17 	ldw	r2,-8(fp)
 4001c60:	10000a26 	beq	r2,zero,4001c8c <xQueueSemaphoreTake+0x1f8>
                        {
                            taskENTER_CRITICAL();
 4001c64:	40050480 	call	4005048 <vTaskEnterCritical>
                                /* This task blocking on the mutex caused another
                                 * task to inherit this task's priority.  Now this task
                                 * has timed out the priority should be disinherited
                                 * again, but only as low as the next highest priority
                                 * task that is waiting for the same mutex. */
                                uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
 4001c68:	e13ffd17 	ldw	r4,-12(fp)
 4001c6c:	40020bc0 	call	40020bc <prvGetDisinheritPriorityAfterTimeout>
 4001c70:	e0bffb15 	stw	r2,-20(fp)
                                vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
 4001c74:	e0bffd17 	ldw	r2,-12(fp)
 4001c78:	10800217 	ldw	r2,8(r2)
 4001c7c:	e17ffb17 	ldw	r5,-20(fp)
 4001c80:	1009883a 	mov	r4,r2
 4001c84:	4004f080 	call	4004f08 <vTaskPriorityDisinheritAfterTimeout>
                            }
                            taskEXIT_CRITICAL();
 4001c88:	400509c0 	call	400509c <vTaskExitCritical>
                        }
                    }
                #endif /* configUSE_MUTEXES */

                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
 4001c8c:	0005883a 	mov	r2,zero
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
 4001c90:	e037883a 	mov	sp,fp
 4001c94:	dfc00117 	ldw	ra,4(sp)
 4001c98:	df000017 	ldw	fp,0(sp)
 4001c9c:	dec00204 	addi	sp,sp,8
 4001ca0:	f800283a 	ret

04001ca4 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue,
                       void * const pvBuffer,
                       TickType_t xTicksToWait )
{
 4001ca4:	defff504 	addi	sp,sp,-44
 4001ca8:	dfc00a15 	stw	ra,40(sp)
 4001cac:	df000915 	stw	fp,36(sp)
 4001cb0:	df000904 	addi	fp,sp,36
 4001cb4:	e13ff915 	stw	r4,-28(fp)
 4001cb8:	e17ff815 	stw	r5,-32(fp)
 4001cbc:	e1bff715 	stw	r6,-36(fp)
    BaseType_t xEntryTimeSet = pdFALSE;
 4001cc0:	e03fff15 	stw	zero,-4(fp)
    TimeOut_t xTimeOut;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
 4001cc4:	e0bff917 	ldw	r2,-28(fp)
 4001cc8:	e0bffe15 	stw	r2,-8(fp)
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
 4001ccc:	40050480 	call	4005048 <vTaskEnterCritical>
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 4001cd0:	e0bffe17 	ldw	r2,-8(fp)
 4001cd4:	10800e17 	ldw	r2,56(r2)
 4001cd8:	e0bffd15 	stw	r2,-12(fp)

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 4001cdc:	e0bffd17 	ldw	r2,-12(fp)
 4001ce0:	10001526 	beq	r2,zero,4001d38 <xQueuePeek+0x94>
            {
                /* Remember the read position so it can be reset after the data
                 * is read from the queue as this function is only peeking the
                 * data, not removing it. */
                pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
 4001ce4:	e0bffe17 	ldw	r2,-8(fp)
 4001ce8:	10800317 	ldw	r2,12(r2)
 4001cec:	e0bffc15 	stw	r2,-16(fp)

                prvCopyDataFromQueue( pxQueue, pvBuffer );
 4001cf0:	e17ff817 	ldw	r5,-32(fp)
 4001cf4:	e13ffe17 	ldw	r4,-8(fp)
 4001cf8:	40022980 	call	4002298 <prvCopyDataFromQueue>
                traceQUEUE_PEEK( pxQueue );

                /* The data is not being removed, so reset the read pointer. */
                pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 4001cfc:	e0bffe17 	ldw	r2,-8(fp)
 4001d00:	e0fffc17 	ldw	r3,-16(fp)
 4001d04:	10c00315 	stw	r3,12(r2)

                /* The data is being left in the queue, so see if there are
                 * any other tasks waiting for the data. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 4001d08:	e0bffe17 	ldw	r2,-8(fp)
 4001d0c:	10800917 	ldw	r2,36(r2)
 4001d10:	10000626 	beq	r2,zero,4001d2c <xQueuePeek+0x88>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 4001d14:	e0bffe17 	ldw	r2,-8(fp)
 4001d18:	10800904 	addi	r2,r2,36
 4001d1c:	1009883a 	mov	r4,r2
 4001d20:	40046ac0 	call	40046ac <xTaskRemoveFromEventList>
 4001d24:	10000126 	beq	r2,zero,4001d2c <xQueuePeek+0x88>
                    {
                        /* The task waiting has a higher priority than this task. */
                        queueYIELD_IF_USING_PREEMPTION();
 4001d28:	003b683a 	trap	0
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
 4001d2c:	400509c0 	call	400509c <vTaskExitCritical>
                return pdPASS;
 4001d30:	00800044 	movi	r2,1
 4001d34:	00004206 	br	4001e40 <xQueuePeek+0x19c>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
 4001d38:	e0bff717 	ldw	r2,-36(fp)
 4001d3c:	1000031e 	bne	r2,zero,4001d4c <xQueuePeek+0xa8>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
 4001d40:	400509c0 	call	400509c <vTaskExitCritical>
                    traceQUEUE_PEEK_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
 4001d44:	0005883a 	mov	r2,zero
 4001d48:	00003d06 	br	4001e40 <xQueuePeek+0x19c>
                }
                else if( xEntryTimeSet == pdFALSE )
 4001d4c:	e0bfff17 	ldw	r2,-4(fp)
 4001d50:	1000051e 	bne	r2,zero,4001d68 <xQueuePeek+0xc4>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
 4001d54:	e0bffa04 	addi	r2,fp,-24
 4001d58:	1009883a 	mov	r4,r2
 4001d5c:	40048b40 	call	40048b4 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
 4001d60:	00800044 	movi	r2,1
 4001d64:	e0bfff15 	stw	r2,-4(fp)
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
 4001d68:	400509c0 	call	400509c <vTaskExitCritical>

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
 4001d6c:	40041000 	call	4004100 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
 4001d70:	40050480 	call	4005048 <vTaskEnterCritical>
 4001d74:	e0bffe17 	ldw	r2,-8(fp)
 4001d78:	10801103 	ldbu	r2,68(r2)
 4001d7c:	10803fcc 	andi	r2,r2,255
 4001d80:	1080201c 	xori	r2,r2,128
 4001d84:	10bfe004 	addi	r2,r2,-128
 4001d88:	10bfffd8 	cmpnei	r2,r2,-1
 4001d8c:	1000021e 	bne	r2,zero,4001d98 <xQueuePeek+0xf4>
 4001d90:	e0bffe17 	ldw	r2,-8(fp)
 4001d94:	10001105 	stb	zero,68(r2)
 4001d98:	e0bffe17 	ldw	r2,-8(fp)
 4001d9c:	10801143 	ldbu	r2,69(r2)
 4001da0:	10803fcc 	andi	r2,r2,255
 4001da4:	1080201c 	xori	r2,r2,128
 4001da8:	10bfe004 	addi	r2,r2,-128
 4001dac:	10bfffd8 	cmpnei	r2,r2,-1
 4001db0:	1000021e 	bne	r2,zero,4001dbc <xQueuePeek+0x118>
 4001db4:	e0bffe17 	ldw	r2,-8(fp)
 4001db8:	10001145 	stb	zero,69(r2)
 4001dbc:	400509c0 	call	400509c <vTaskExitCritical>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 4001dc0:	e0fff704 	addi	r3,fp,-36
 4001dc4:	e0bffa04 	addi	r2,fp,-24
 4001dc8:	180b883a 	mov	r5,r3
 4001dcc:	1009883a 	mov	r4,r2
 4001dd0:	40048f00 	call	40048f0 <xTaskCheckForTimeOut>
 4001dd4:	1000131e 	bne	r2,zero,4001e24 <xQueuePeek+0x180>
        {
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 4001dd8:	e13ffe17 	ldw	r4,-8(fp)
 4001ddc:	40024280 	call	4002428 <prvIsQueueEmpty>
 4001de0:	10000c26 	beq	r2,zero,4001e14 <xQueuePeek+0x170>
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 4001de4:	e0bffe17 	ldw	r2,-8(fp)
 4001de8:	10800904 	addi	r2,r2,36
 4001dec:	e0fff717 	ldw	r3,-36(fp)
 4001df0:	180b883a 	mov	r5,r3
 4001df4:	1009883a 	mov	r4,r2
 4001df8:	40045f80 	call	40045f8 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
 4001dfc:	e13ffe17 	ldw	r4,-8(fp)
 4001e00:	40023340 	call	4002334 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
 4001e04:	400412c0 	call	400412c <xTaskResumeAll>
 4001e08:	103fb01e 	bne	r2,zero,4001ccc <xQueuePeek+0x28>
                {
                    portYIELD_WITHIN_API();
 4001e0c:	003b683a 	trap	0
 4001e10:	003fae06 	br	4001ccc <xQueuePeek+0x28>
            }
            else
            {
                /* There is data in the queue now, so don't enter the blocked
                 * state, instead return to try and obtain the data. */
                prvUnlockQueue( pxQueue );
 4001e14:	e13ffe17 	ldw	r4,-8(fp)
 4001e18:	40023340 	call	4002334 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
 4001e1c:	400412c0 	call	400412c <xTaskResumeAll>
 4001e20:	003faa06 	br	4001ccc <xQueuePeek+0x28>
        }
        else
        {
            /* The timeout has expired.  If there is still no data in the queue
             * exit, otherwise go back and try to read the data again. */
            prvUnlockQueue( pxQueue );
 4001e24:	e13ffe17 	ldw	r4,-8(fp)
 4001e28:	40023340 	call	4002334 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
 4001e2c:	400412c0 	call	400412c <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 4001e30:	e13ffe17 	ldw	r4,-8(fp)
 4001e34:	40024280 	call	4002428 <prvIsQueueEmpty>
 4001e38:	103fa426 	beq	r2,zero,4001ccc <xQueuePeek+0x28>
            {
                traceQUEUE_PEEK_FAILED( pxQueue );
                return errQUEUE_EMPTY;
 4001e3c:	0005883a 	mov	r2,zero
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
 4001e40:	e037883a 	mov	sp,fp
 4001e44:	dfc00117 	ldw	ra,4(sp)
 4001e48:	df000017 	ldw	fp,0(sp)
 4001e4c:	dec00204 	addi	sp,sp,8
 4001e50:	f800283a 	ret

04001e54 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
                                 void * const pvBuffer,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
 4001e54:	defff604 	addi	sp,sp,-40
 4001e58:	dfc00915 	stw	ra,36(sp)
 4001e5c:	df000815 	stw	fp,32(sp)
 4001e60:	df000804 	addi	fp,sp,32
 4001e64:	e13ffa15 	stw	r4,-24(fp)
 4001e68:	e17ff915 	stw	r5,-28(fp)
 4001e6c:	e1bff815 	stw	r6,-32(fp)
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
 4001e70:	e0bffa17 	ldw	r2,-24(fp)
 4001e74:	e0bffe15 	stw	r2,-8(fp)
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 4001e78:	e03ffd15 	stw	zero,-12(fp)
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 4001e7c:	e0bffe17 	ldw	r2,-8(fp)
 4001e80:	10800e17 	ldw	r2,56(r2)
 4001e84:	e0bffc15 	stw	r2,-16(fp)

        /* Cannot block in an ISR, so check there is data available. */
        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 4001e88:	e0bffc17 	ldw	r2,-16(fp)
 4001e8c:	10002326 	beq	r2,zero,4001f1c <xQueueReceiveFromISR+0xc8>
        {
            const int8_t cRxLock = pxQueue->cRxLock;
 4001e90:	e0bffe17 	ldw	r2,-8(fp)
 4001e94:	10801103 	ldbu	r2,68(r2)
 4001e98:	e0bffbc5 	stb	r2,-17(fp)

            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

            prvCopyDataFromQueue( pxQueue, pvBuffer );
 4001e9c:	e17ff917 	ldw	r5,-28(fp)
 4001ea0:	e13ffe17 	ldw	r4,-8(fp)
 4001ea4:	40022980 	call	4002298 <prvCopyDataFromQueue>
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 4001ea8:	e0bffc17 	ldw	r2,-16(fp)
 4001eac:	10ffffc4 	addi	r3,r2,-1
 4001eb0:	e0bffe17 	ldw	r2,-8(fp)
 4001eb4:	10c00e15 	stw	r3,56(r2)

            /* If the queue is locked the event list will not be modified.
             * Instead update the lock count so the task that unlocks the queue
             * will know that an ISR has removed data while the queue was
             * locked. */
            if( cRxLock == queueUNLOCKED )
 4001eb8:	e0bffbc7 	ldb	r2,-17(fp)
 4001ebc:	10bfffd8 	cmpnei	r2,r2,-1
 4001ec0:	10000e1e 	bne	r2,zero,4001efc <xQueueReceiveFromISR+0xa8>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 4001ec4:	e0bffe17 	ldw	r2,-8(fp)
 4001ec8:	10800417 	ldw	r2,16(r2)
 4001ecc:	10001026 	beq	r2,zero,4001f10 <xQueueReceiveFromISR+0xbc>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 4001ed0:	e0bffe17 	ldw	r2,-8(fp)
 4001ed4:	10800404 	addi	r2,r2,16
 4001ed8:	1009883a 	mov	r4,r2
 4001edc:	40046ac0 	call	40046ac <xTaskRemoveFromEventList>
 4001ee0:	10000b26 	beq	r2,zero,4001f10 <xQueueReceiveFromISR+0xbc>
                    {
                        /* The task waiting has a higher priority than us so
                         * force a context switch. */
                        if( pxHigherPriorityTaskWoken != NULL )
 4001ee4:	e0bff817 	ldw	r2,-32(fp)
 4001ee8:	10000926 	beq	r2,zero,4001f10 <xQueueReceiveFromISR+0xbc>
                        {
                            *pxHigherPriorityTaskWoken = pdTRUE;
 4001eec:	e0bff817 	ldw	r2,-32(fp)
 4001ef0:	00c00044 	movi	r3,1
 4001ef4:	10c00015 	stw	r3,0(r2)
 4001ef8:	00000506 	br	4001f10 <xQueueReceiveFromISR+0xbc>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was removed while it was locked. */
                configASSERT( cRxLock != queueINT8_MAX );

                pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
 4001efc:	e0bffbc3 	ldbu	r2,-17(fp)
 4001f00:	10800044 	addi	r2,r2,1
 4001f04:	1007883a 	mov	r3,r2
 4001f08:	e0bffe17 	ldw	r2,-8(fp)
 4001f0c:	10c01105 	stb	r3,68(r2)
            }

            xReturn = pdPASS;
 4001f10:	00800044 	movi	r2,1
 4001f14:	e0bfff15 	stw	r2,-4(fp)
 4001f18:	00000106 	br	4001f20 <xQueueReceiveFromISR+0xcc>
        }
        else
        {
            xReturn = pdFAIL;
 4001f1c:	e03fff15 	stw	zero,-4(fp)
            traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
 4001f20:	e0bfff17 	ldw	r2,-4(fp)
}
 4001f24:	e037883a 	mov	sp,fp
 4001f28:	dfc00117 	ldw	ra,4(sp)
 4001f2c:	df000017 	ldw	fp,0(sp)
 4001f30:	dec00204 	addi	sp,sp,8
 4001f34:	f800283a 	ret

04001f38 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
                              void * const pvBuffer )
{
 4001f38:	defff804 	addi	sp,sp,-32
 4001f3c:	dfc00715 	stw	ra,28(sp)
 4001f40:	df000615 	stw	fp,24(sp)
 4001f44:	df000604 	addi	fp,sp,24
 4001f48:	e13ffb15 	stw	r4,-20(fp)
 4001f4c:	e17ffa15 	stw	r5,-24(fp)
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
 4001f50:	e0bffb17 	ldw	r2,-20(fp)
 4001f54:	e0bffe15 	stw	r2,-8(fp)
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 4001f58:	e03ffd15 	stw	zero,-12(fp)
    {
        /* Cannot block in an ISR, so check there is data available. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 4001f5c:	e0bffe17 	ldw	r2,-8(fp)
 4001f60:	10800e17 	ldw	r2,56(r2)
 4001f64:	10000c26 	beq	r2,zero,4001f98 <xQueuePeekFromISR+0x60>
        {
            traceQUEUE_PEEK_FROM_ISR( pxQueue );

            /* Remember the read position so it can be reset as nothing is
             * actually being removed from the queue. */
            pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
 4001f68:	e0bffe17 	ldw	r2,-8(fp)
 4001f6c:	10800317 	ldw	r2,12(r2)
 4001f70:	e0bffc15 	stw	r2,-16(fp)
            prvCopyDataFromQueue( pxQueue, pvBuffer );
 4001f74:	e17ffa17 	ldw	r5,-24(fp)
 4001f78:	e13ffe17 	ldw	r4,-8(fp)
 4001f7c:	40022980 	call	4002298 <prvCopyDataFromQueue>
            pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 4001f80:	e0bffe17 	ldw	r2,-8(fp)
 4001f84:	e0fffc17 	ldw	r3,-16(fp)
 4001f88:	10c00315 	stw	r3,12(r2)

            xReturn = pdPASS;
 4001f8c:	00800044 	movi	r2,1
 4001f90:	e0bfff15 	stw	r2,-4(fp)
 4001f94:	00000106 	br	4001f9c <xQueuePeekFromISR+0x64>
        }
        else
        {
            xReturn = pdFAIL;
 4001f98:	e03fff15 	stw	zero,-4(fp)
            traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
 4001f9c:	e0bfff17 	ldw	r2,-4(fp)
}
 4001fa0:	e037883a 	mov	sp,fp
 4001fa4:	dfc00117 	ldw	ra,4(sp)
 4001fa8:	df000017 	ldw	fp,0(sp)
 4001fac:	dec00204 	addi	sp,sp,8
 4001fb0:	f800283a 	ret

04001fb4 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
 4001fb4:	defffc04 	addi	sp,sp,-16
 4001fb8:	dfc00315 	stw	ra,12(sp)
 4001fbc:	df000215 	stw	fp,8(sp)
 4001fc0:	df000204 	addi	fp,sp,8
 4001fc4:	e13ffe15 	stw	r4,-8(fp)
    UBaseType_t uxReturn;

    configASSERT( xQueue );

    taskENTER_CRITICAL();
 4001fc8:	40050480 	call	4005048 <vTaskEnterCritical>
    {
        uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 4001fcc:	e0bffe17 	ldw	r2,-8(fp)
 4001fd0:	10800e17 	ldw	r2,56(r2)
 4001fd4:	e0bfff15 	stw	r2,-4(fp)
    }
    taskEXIT_CRITICAL();
 4001fd8:	400509c0 	call	400509c <vTaskExitCritical>

    return uxReturn;
 4001fdc:	e0bfff17 	ldw	r2,-4(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 4001fe0:	e037883a 	mov	sp,fp
 4001fe4:	dfc00117 	ldw	ra,4(sp)
 4001fe8:	df000017 	ldw	fp,0(sp)
 4001fec:	dec00204 	addi	sp,sp,8
 4001ff0:	f800283a 	ret

04001ff4 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
 4001ff4:	defffb04 	addi	sp,sp,-20
 4001ff8:	dfc00415 	stw	ra,16(sp)
 4001ffc:	df000315 	stw	fp,12(sp)
 4002000:	df000304 	addi	fp,sp,12
 4002004:	e13ffd15 	stw	r4,-12(fp)
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
 4002008:	e0bffd17 	ldw	r2,-12(fp)
 400200c:	e0bfff15 	stw	r2,-4(fp)

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
 4002010:	40050480 	call	4005048 <vTaskEnterCritical>
    {
        uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
 4002014:	e0bfff17 	ldw	r2,-4(fp)
 4002018:	10c00f17 	ldw	r3,60(r2)
 400201c:	e0bfff17 	ldw	r2,-4(fp)
 4002020:	10800e17 	ldw	r2,56(r2)
 4002024:	1885c83a 	sub	r2,r3,r2
 4002028:	e0bffe15 	stw	r2,-8(fp)
    }
    taskEXIT_CRITICAL();
 400202c:	400509c0 	call	400509c <vTaskExitCritical>

    return uxReturn;
 4002030:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 4002034:	e037883a 	mov	sp,fp
 4002038:	dfc00117 	ldw	ra,4(sp)
 400203c:	df000017 	ldw	fp,0(sp)
 4002040:	dec00204 	addi	sp,sp,8
 4002044:	f800283a 	ret

04002048 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
 4002048:	defffc04 	addi	sp,sp,-16
 400204c:	df000315 	stw	fp,12(sp)
 4002050:	df000304 	addi	fp,sp,12
 4002054:	e13ffd15 	stw	r4,-12(fp)
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
 4002058:	e0bffd17 	ldw	r2,-12(fp)
 400205c:	e0bfff15 	stw	r2,-4(fp)

    configASSERT( pxQueue );
    uxReturn = pxQueue->uxMessagesWaiting;
 4002060:	e0bfff17 	ldw	r2,-4(fp)
 4002064:	10800e17 	ldw	r2,56(r2)
 4002068:	e0bffe15 	stw	r2,-8(fp)

    return uxReturn;
 400206c:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 4002070:	e037883a 	mov	sp,fp
 4002074:	df000017 	ldw	fp,0(sp)
 4002078:	dec00104 	addi	sp,sp,4
 400207c:	f800283a 	ret

04002080 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
 4002080:	defffc04 	addi	sp,sp,-16
 4002084:	dfc00315 	stw	ra,12(sp)
 4002088:	df000215 	stw	fp,8(sp)
 400208c:	df000204 	addi	fp,sp,8
 4002090:	e13ffe15 	stw	r4,-8(fp)
    Queue_t * const pxQueue = xQueue;
 4002094:	e0bffe17 	ldw	r2,-8(fp)
 4002098:	e0bfff15 	stw	r2,-4(fp)

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
        {
            /* The queue can only have been allocated dynamically - free it
             * again. */
            vPortFree( pxQueue );
 400209c:	e13fff17 	ldw	r4,-4(fp)
 40020a0:	40006f40 	call	40006f4 <vPortFree>
            /* The queue must have been statically allocated, so is not going to be
             * deleted.  Avoid compiler warnings about the unused parameter. */
            ( void ) pxQueue;
        }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
 40020a4:	0001883a 	nop
 40020a8:	e037883a 	mov	sp,fp
 40020ac:	dfc00117 	ldw	ra,4(sp)
 40020b0:	df000017 	ldw	fp,0(sp)
 40020b4:	dec00204 	addi	sp,sp,8
 40020b8:	f800283a 	ret

040020bc <prvGetDisinheritPriorityAfterTimeout>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
    {
 40020bc:	defffd04 	addi	sp,sp,-12
 40020c0:	df000215 	stw	fp,8(sp)
 40020c4:	df000204 	addi	fp,sp,8
 40020c8:	e13ffe15 	stw	r4,-8(fp)
         * priority, but the waiting task times out, then the holder should
         * disinherit the priority - but only down to the highest priority of any
         * other tasks that are waiting for the same mutex.  For this purpose,
         * return the priority of the highest priority task that is waiting for the
         * mutex. */
        if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
 40020cc:	e0bffe17 	ldw	r2,-8(fp)
 40020d0:	10800917 	ldw	r2,36(r2)
 40020d4:	10000726 	beq	r2,zero,40020f4 <prvGetDisinheritPriorityAfterTimeout+0x38>
        {
            uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
 40020d8:	e0bffe17 	ldw	r2,-8(fp)
 40020dc:	10800c17 	ldw	r2,48(r2)
 40020e0:	10800017 	ldw	r2,0(r2)
 40020e4:	00c00144 	movi	r3,5
 40020e8:	1885c83a 	sub	r2,r3,r2
 40020ec:	e0bfff15 	stw	r2,-4(fp)
 40020f0:	00000106 	br	40020f8 <prvGetDisinheritPriorityAfterTimeout+0x3c>
        }
        else
        {
            uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
 40020f4:	e03fff15 	stw	zero,-4(fp)
        }

        return uxHighestPriorityOfWaitingTasks;
 40020f8:	e0bfff17 	ldw	r2,-4(fp)
    }
 40020fc:	e037883a 	mov	sp,fp
 4002100:	df000017 	ldw	fp,0(sp)
 4002104:	dec00104 	addi	sp,sp,4
 4002108:	f800283a 	ret

0400210c <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
 400210c:	defff904 	addi	sp,sp,-28
 4002110:	dfc00615 	stw	ra,24(sp)
 4002114:	df000515 	stw	fp,20(sp)
 4002118:	df000504 	addi	fp,sp,20
 400211c:	e13ffd15 	stw	r4,-12(fp)
 4002120:	e17ffc15 	stw	r5,-16(fp)
 4002124:	e1bffb15 	stw	r6,-20(fp)
    BaseType_t xReturn = pdFALSE;
 4002128:	e03fff15 	stw	zero,-4(fp)
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 400212c:	e0bffd17 	ldw	r2,-12(fp)
 4002130:	10800e17 	ldw	r2,56(r2)
 4002134:	e0bffe15 	stw	r2,-8(fp)

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 4002138:	e0bffd17 	ldw	r2,-12(fp)
 400213c:	10801017 	ldw	r2,64(r2)
 4002140:	10000b1e 	bne	r2,zero,4002170 <prvCopyDataToQueue+0x64>
    {
        #if ( configUSE_MUTEXES == 1 )
            {
                if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 4002144:	e0bffd17 	ldw	r2,-12(fp)
 4002148:	10800017 	ldw	r2,0(r2)
 400214c:	1000481e 	bne	r2,zero,4002270 <prvCopyDataToQueue+0x164>
                {
                    /* The mutex is no longer being held. */
                    xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
 4002150:	e0bffd17 	ldw	r2,-12(fp)
 4002154:	10800217 	ldw	r2,8(r2)
 4002158:	1009883a 	mov	r4,r2
 400215c:	4004e0c0 	call	4004e0c <xTaskPriorityDisinherit>
 4002160:	e0bfff15 	stw	r2,-4(fp)
                    pxQueue->u.xSemaphore.xMutexHolder = NULL;
 4002164:	e0bffd17 	ldw	r2,-12(fp)
 4002168:	10000215 	stw	zero,8(r2)
 400216c:	00004006 	br	4002270 <prvCopyDataToQueue+0x164>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
 4002170:	e0bffb17 	ldw	r2,-20(fp)
 4002174:	1000191e 	bne	r2,zero,40021dc <prvCopyDataToQueue+0xd0>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 4002178:	e0bffd17 	ldw	r2,-12(fp)
 400217c:	10c00117 	ldw	r3,4(r2)
 4002180:	e0bffd17 	ldw	r2,-12(fp)
 4002184:	10801017 	ldw	r2,64(r2)
 4002188:	100d883a 	mov	r6,r2
 400218c:	e17ffc17 	ldw	r5,-16(fp)
 4002190:	1809883a 	mov	r4,r3
 4002194:	40062340 	call	4006234 <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 4002198:	e0bffd17 	ldw	r2,-12(fp)
 400219c:	10c00117 	ldw	r3,4(r2)
 40021a0:	e0bffd17 	ldw	r2,-12(fp)
 40021a4:	10801017 	ldw	r2,64(r2)
 40021a8:	1887883a 	add	r3,r3,r2
 40021ac:	e0bffd17 	ldw	r2,-12(fp)
 40021b0:	10c00115 	stw	r3,4(r2)

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 40021b4:	e0bffd17 	ldw	r2,-12(fp)
 40021b8:	10c00117 	ldw	r3,4(r2)
 40021bc:	e0bffd17 	ldw	r2,-12(fp)
 40021c0:	10800217 	ldw	r2,8(r2)
 40021c4:	18802a36 	bltu	r3,r2,4002270 <prvCopyDataToQueue+0x164>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
 40021c8:	e0bffd17 	ldw	r2,-12(fp)
 40021cc:	10c00017 	ldw	r3,0(r2)
 40021d0:	e0bffd17 	ldw	r2,-12(fp)
 40021d4:	10c00115 	stw	r3,4(r2)
 40021d8:	00002506 	br	4002270 <prvCopyDataToQueue+0x164>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
 40021dc:	e0bffd17 	ldw	r2,-12(fp)
 40021e0:	10c00317 	ldw	r3,12(r2)
 40021e4:	e0bffd17 	ldw	r2,-12(fp)
 40021e8:	10801017 	ldw	r2,64(r2)
 40021ec:	100d883a 	mov	r6,r2
 40021f0:	e17ffc17 	ldw	r5,-16(fp)
 40021f4:	1809883a 	mov	r4,r3
 40021f8:	40062340 	call	4006234 <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 40021fc:	e0bffd17 	ldw	r2,-12(fp)
 4002200:	10c00317 	ldw	r3,12(r2)
 4002204:	e0bffd17 	ldw	r2,-12(fp)
 4002208:	10801017 	ldw	r2,64(r2)
 400220c:	0085c83a 	sub	r2,zero,r2
 4002210:	1887883a 	add	r3,r3,r2
 4002214:	e0bffd17 	ldw	r2,-12(fp)
 4002218:	10c00315 	stw	r3,12(r2)

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 400221c:	e0bffd17 	ldw	r2,-12(fp)
 4002220:	10c00317 	ldw	r3,12(r2)
 4002224:	e0bffd17 	ldw	r2,-12(fp)
 4002228:	10800017 	ldw	r2,0(r2)
 400222c:	1880082e 	bgeu	r3,r2,4002250 <prvCopyDataToQueue+0x144>
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
 4002230:	e0bffd17 	ldw	r2,-12(fp)
 4002234:	10c00217 	ldw	r3,8(r2)
 4002238:	e0bffd17 	ldw	r2,-12(fp)
 400223c:	10801017 	ldw	r2,64(r2)
 4002240:	0085c83a 	sub	r2,zero,r2
 4002244:	1887883a 	add	r3,r3,r2
 4002248:	e0bffd17 	ldw	r2,-12(fp)
 400224c:	10c00315 	stw	r3,12(r2)
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
 4002250:	e0bffb17 	ldw	r2,-20(fp)
 4002254:	10800098 	cmpnei	r2,r2,2
 4002258:	1000051e 	bne	r2,zero,4002270 <prvCopyDataToQueue+0x164>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 400225c:	e0bffe17 	ldw	r2,-8(fp)
 4002260:	10000326 	beq	r2,zero,4002270 <prvCopyDataToQueue+0x164>
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
 4002264:	e0bffe17 	ldw	r2,-8(fp)
 4002268:	10bfffc4 	addi	r2,r2,-1
 400226c:	e0bffe15 	stw	r2,-8(fp)
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 4002270:	e0bffe17 	ldw	r2,-8(fp)
 4002274:	10c00044 	addi	r3,r2,1
 4002278:	e0bffd17 	ldw	r2,-12(fp)
 400227c:	10c00e15 	stw	r3,56(r2)

    return xReturn;
 4002280:	e0bfff17 	ldw	r2,-4(fp)
}
 4002284:	e037883a 	mov	sp,fp
 4002288:	dfc00117 	ldw	ra,4(sp)
 400228c:	df000017 	ldw	fp,0(sp)
 4002290:	dec00204 	addi	sp,sp,8
 4002294:	f800283a 	ret

04002298 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
 4002298:	defffc04 	addi	sp,sp,-16
 400229c:	dfc00315 	stw	ra,12(sp)
 40022a0:	df000215 	stw	fp,8(sp)
 40022a4:	df000204 	addi	fp,sp,8
 40022a8:	e13fff15 	stw	r4,-4(fp)
 40022ac:	e17ffe15 	stw	r5,-8(fp)
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 40022b0:	e0bfff17 	ldw	r2,-4(fp)
 40022b4:	10801017 	ldw	r2,64(r2)
 40022b8:	10001826 	beq	r2,zero,400231c <prvCopyDataFromQueue+0x84>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 40022bc:	e0bfff17 	ldw	r2,-4(fp)
 40022c0:	10c00317 	ldw	r3,12(r2)
 40022c4:	e0bfff17 	ldw	r2,-4(fp)
 40022c8:	10801017 	ldw	r2,64(r2)
 40022cc:	1887883a 	add	r3,r3,r2
 40022d0:	e0bfff17 	ldw	r2,-4(fp)
 40022d4:	10c00315 	stw	r3,12(r2)

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 40022d8:	e0bfff17 	ldw	r2,-4(fp)
 40022dc:	10c00317 	ldw	r3,12(r2)
 40022e0:	e0bfff17 	ldw	r2,-4(fp)
 40022e4:	10800217 	ldw	r2,8(r2)
 40022e8:	18800436 	bltu	r3,r2,40022fc <prvCopyDataFromQueue+0x64>
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 40022ec:	e0bfff17 	ldw	r2,-4(fp)
 40022f0:	10c00017 	ldw	r3,0(r2)
 40022f4:	e0bfff17 	ldw	r2,-4(fp)
 40022f8:	10c00315 	stw	r3,12(r2)
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 40022fc:	e0bfff17 	ldw	r2,-4(fp)
 4002300:	10c00317 	ldw	r3,12(r2)
 4002304:	e0bfff17 	ldw	r2,-4(fp)
 4002308:	10801017 	ldw	r2,64(r2)
 400230c:	100d883a 	mov	r6,r2
 4002310:	180b883a 	mov	r5,r3
 4002314:	e13ffe17 	ldw	r4,-8(fp)
 4002318:	40062340 	call	4006234 <memcpy>
    }
}
 400231c:	0001883a 	nop
 4002320:	e037883a 	mov	sp,fp
 4002324:	dfc00117 	ldw	ra,4(sp)
 4002328:	df000017 	ldw	fp,0(sp)
 400232c:	dec00204 	addi	sp,sp,8
 4002330:	f800283a 	ret

04002334 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
 4002334:	defffc04 	addi	sp,sp,-16
 4002338:	dfc00315 	stw	ra,12(sp)
 400233c:	df000215 	stw	fp,8(sp)
 4002340:	df000204 	addi	fp,sp,8
 4002344:	e13ffe15 	stw	r4,-8(fp)

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
 4002348:	40050480 	call	4005048 <vTaskEnterCritical>
    {
        int8_t cTxLock = pxQueue->cTxLock;
 400234c:	e0bffe17 	ldw	r2,-8(fp)
 4002350:	10801143 	ldbu	r2,69(r2)
 4002354:	e0bfffc5 	stb	r2,-1(fp)

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
 4002358:	00000c06 	br	400238c <prvUnlockQueue+0x58>
                }
            #else /* configUSE_QUEUE_SETS */
                {
                    /* Tasks that are removed from the event list will get added to
                     * the pending ready list as the scheduler is still suspended. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 400235c:	e0bffe17 	ldw	r2,-8(fp)
 4002360:	10800917 	ldw	r2,36(r2)
 4002364:	10000c26 	beq	r2,zero,4002398 <prvUnlockQueue+0x64>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 4002368:	e0bffe17 	ldw	r2,-8(fp)
 400236c:	10800904 	addi	r2,r2,36
 4002370:	1009883a 	mov	r4,r2
 4002374:	40046ac0 	call	40046ac <xTaskRemoveFromEventList>
 4002378:	10000126 	beq	r2,zero,4002380 <prvUnlockQueue+0x4c>
                        {
                            /* The task waiting has a higher priority so record that
                             * a context switch is required. */
                            vTaskMissedYield();
 400237c:	40049d80 	call	40049d8 <vTaskMissedYield>
                        break;
                    }
                }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
 4002380:	e0bfffc3 	ldbu	r2,-1(fp)
 4002384:	10bfffc4 	addi	r2,r2,-1
 4002388:	e0bfffc5 	stb	r2,-1(fp)
        while( cTxLock > queueLOCKED_UNMODIFIED )
 400238c:	e0bfffc7 	ldb	r2,-1(fp)
 4002390:	00bff216 	blt	zero,r2,400235c <prvUnlockQueue+0x28>
 4002394:	00000106 	br	400239c <prvUnlockQueue+0x68>
                        break;
 4002398:	0001883a 	nop
        }

        pxQueue->cTxLock = queueUNLOCKED;
 400239c:	e0bffe17 	ldw	r2,-8(fp)
 40023a0:	00ffffc4 	movi	r3,-1
 40023a4:	10c01145 	stb	r3,69(r2)
    }
    taskEXIT_CRITICAL();
 40023a8:	400509c0 	call	400509c <vTaskExitCritical>

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
 40023ac:	40050480 	call	4005048 <vTaskEnterCritical>
    {
        int8_t cRxLock = pxQueue->cRxLock;
 40023b0:	e0bffe17 	ldw	r2,-8(fp)
 40023b4:	10801103 	ldbu	r2,68(r2)
 40023b8:	e0bfff85 	stb	r2,-2(fp)

        while( cRxLock > queueLOCKED_UNMODIFIED )
 40023bc:	00000c06 	br	40023f0 <prvUnlockQueue+0xbc>
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 40023c0:	e0bffe17 	ldw	r2,-8(fp)
 40023c4:	10800417 	ldw	r2,16(r2)
 40023c8:	10000c26 	beq	r2,zero,40023fc <prvUnlockQueue+0xc8>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 40023cc:	e0bffe17 	ldw	r2,-8(fp)
 40023d0:	10800404 	addi	r2,r2,16
 40023d4:	1009883a 	mov	r4,r2
 40023d8:	40046ac0 	call	40046ac <xTaskRemoveFromEventList>
 40023dc:	10000126 	beq	r2,zero,40023e4 <prvUnlockQueue+0xb0>
                {
                    vTaskMissedYield();
 40023e0:	40049d80 	call	40049d8 <vTaskMissedYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
 40023e4:	e0bfff83 	ldbu	r2,-2(fp)
 40023e8:	10bfffc4 	addi	r2,r2,-1
 40023ec:	e0bfff85 	stb	r2,-2(fp)
        while( cRxLock > queueLOCKED_UNMODIFIED )
 40023f0:	e0bfff87 	ldb	r2,-2(fp)
 40023f4:	00bff216 	blt	zero,r2,40023c0 <prvUnlockQueue+0x8c>
 40023f8:	00000106 	br	4002400 <prvUnlockQueue+0xcc>
            }
            else
            {
                break;
 40023fc:	0001883a 	nop
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
 4002400:	e0bffe17 	ldw	r2,-8(fp)
 4002404:	00ffffc4 	movi	r3,-1
 4002408:	10c01105 	stb	r3,68(r2)
    }
    taskEXIT_CRITICAL();
 400240c:	400509c0 	call	400509c <vTaskExitCritical>
}
 4002410:	0001883a 	nop
 4002414:	e037883a 	mov	sp,fp
 4002418:	dfc00117 	ldw	ra,4(sp)
 400241c:	df000017 	ldw	fp,0(sp)
 4002420:	dec00204 	addi	sp,sp,8
 4002424:	f800283a 	ret

04002428 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
 4002428:	defffc04 	addi	sp,sp,-16
 400242c:	dfc00315 	stw	ra,12(sp)
 4002430:	df000215 	stw	fp,8(sp)
 4002434:	df000204 	addi	fp,sp,8
 4002438:	e13ffe15 	stw	r4,-8(fp)
    BaseType_t xReturn;

    taskENTER_CRITICAL();
 400243c:	40050480 	call	4005048 <vTaskEnterCritical>
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 4002440:	e0bffe17 	ldw	r2,-8(fp)
 4002444:	10800e17 	ldw	r2,56(r2)
 4002448:	1000031e 	bne	r2,zero,4002458 <prvIsQueueEmpty+0x30>
        {
            xReturn = pdTRUE;
 400244c:	00800044 	movi	r2,1
 4002450:	e0bfff15 	stw	r2,-4(fp)
 4002454:	00000106 	br	400245c <prvIsQueueEmpty+0x34>
        }
        else
        {
            xReturn = pdFALSE;
 4002458:	e03fff15 	stw	zero,-4(fp)
        }
    }
    taskEXIT_CRITICAL();
 400245c:	400509c0 	call	400509c <vTaskExitCritical>

    return xReturn;
 4002460:	e0bfff17 	ldw	r2,-4(fp)
}
 4002464:	e037883a 	mov	sp,fp
 4002468:	dfc00117 	ldw	ra,4(sp)
 400246c:	df000017 	ldw	fp,0(sp)
 4002470:	dec00204 	addi	sp,sp,8
 4002474:	f800283a 	ret

04002478 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
 4002478:	defffc04 	addi	sp,sp,-16
 400247c:	df000315 	stw	fp,12(sp)
 4002480:	df000304 	addi	fp,sp,12
 4002484:	e13ffd15 	stw	r4,-12(fp)
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
 4002488:	e0bffd17 	ldw	r2,-12(fp)
 400248c:	e0bffe15 	stw	r2,-8(fp)

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 4002490:	e0bffe17 	ldw	r2,-8(fp)
 4002494:	10800e17 	ldw	r2,56(r2)
 4002498:	1000031e 	bne	r2,zero,40024a8 <xQueueIsQueueEmptyFromISR+0x30>
    {
        xReturn = pdTRUE;
 400249c:	00800044 	movi	r2,1
 40024a0:	e0bfff15 	stw	r2,-4(fp)
 40024a4:	00000106 	br	40024ac <xQueueIsQueueEmptyFromISR+0x34>
    }
    else
    {
        xReturn = pdFALSE;
 40024a8:	e03fff15 	stw	zero,-4(fp)
    }

    return xReturn;
 40024ac:	e0bfff17 	ldw	r2,-4(fp)
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 40024b0:	e037883a 	mov	sp,fp
 40024b4:	df000017 	ldw	fp,0(sp)
 40024b8:	dec00104 	addi	sp,sp,4
 40024bc:	f800283a 	ret

040024c0 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
 40024c0:	defffc04 	addi	sp,sp,-16
 40024c4:	dfc00315 	stw	ra,12(sp)
 40024c8:	df000215 	stw	fp,8(sp)
 40024cc:	df000204 	addi	fp,sp,8
 40024d0:	e13ffe15 	stw	r4,-8(fp)
    BaseType_t xReturn;

    taskENTER_CRITICAL();
 40024d4:	40050480 	call	4005048 <vTaskEnterCritical>
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 40024d8:	e0bffe17 	ldw	r2,-8(fp)
 40024dc:	10c00e17 	ldw	r3,56(r2)
 40024e0:	e0bffe17 	ldw	r2,-8(fp)
 40024e4:	10800f17 	ldw	r2,60(r2)
 40024e8:	1880031e 	bne	r3,r2,40024f8 <prvIsQueueFull+0x38>
        {
            xReturn = pdTRUE;
 40024ec:	00800044 	movi	r2,1
 40024f0:	e0bfff15 	stw	r2,-4(fp)
 40024f4:	00000106 	br	40024fc <prvIsQueueFull+0x3c>
        }
        else
        {
            xReturn = pdFALSE;
 40024f8:	e03fff15 	stw	zero,-4(fp)
        }
    }
    taskEXIT_CRITICAL();
 40024fc:	400509c0 	call	400509c <vTaskExitCritical>

    return xReturn;
 4002500:	e0bfff17 	ldw	r2,-4(fp)
}
 4002504:	e037883a 	mov	sp,fp
 4002508:	dfc00117 	ldw	ra,4(sp)
 400250c:	df000017 	ldw	fp,0(sp)
 4002510:	dec00204 	addi	sp,sp,8
 4002514:	f800283a 	ret

04002518 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
 4002518:	defffc04 	addi	sp,sp,-16
 400251c:	df000315 	stw	fp,12(sp)
 4002520:	df000304 	addi	fp,sp,12
 4002524:	e13ffd15 	stw	r4,-12(fp)
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
 4002528:	e0bffd17 	ldw	r2,-12(fp)
 400252c:	e0bffe15 	stw	r2,-8(fp)

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 4002530:	e0bffe17 	ldw	r2,-8(fp)
 4002534:	10c00e17 	ldw	r3,56(r2)
 4002538:	e0bffe17 	ldw	r2,-8(fp)
 400253c:	10800f17 	ldw	r2,60(r2)
 4002540:	1880031e 	bne	r3,r2,4002550 <xQueueIsQueueFullFromISR+0x38>
    {
        xReturn = pdTRUE;
 4002544:	00800044 	movi	r2,1
 4002548:	e0bfff15 	stw	r2,-4(fp)
 400254c:	00000106 	br	4002554 <xQueueIsQueueFullFromISR+0x3c>
    }
    else
    {
        xReturn = pdFALSE;
 4002550:	e03fff15 	stw	zero,-4(fp)
    }

    return xReturn;
 4002554:	e0bfff17 	ldw	r2,-4(fp)
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 4002558:	e037883a 	mov	sp,fp
 400255c:	df000017 	ldw	fp,0(sp)
 4002560:	dec00104 	addi	sp,sp,4
 4002564:	f800283a 	ret

04002568 <xStreamBufferGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes,
                                                     size_t xTriggerLevelBytes,
                                                     BaseType_t xIsMessageBuffer )
    {
 4002568:	defff804 	addi	sp,sp,-32
 400256c:	dfc00715 	stw	ra,28(sp)
 4002570:	df000615 	stw	fp,24(sp)
 4002574:	df000604 	addi	fp,sp,24
 4002578:	e13ffd15 	stw	r4,-12(fp)
 400257c:	e17ffc15 	stw	r5,-16(fp)
 4002580:	e1bffb15 	stw	r6,-20(fp)

        /* In case the stream buffer is going to be used as a message buffer
         * (that is, it will hold discrete messages with a little meta data that
         * says how big the next message is) check the buffer will be large enough
         * to hold at least one message. */
        if( xIsMessageBuffer == pdTRUE )
 4002584:	e0bffb17 	ldw	r2,-20(fp)
 4002588:	10800058 	cmpnei	r2,r2,1
 400258c:	1000031e 	bne	r2,zero,400259c <xStreamBufferGenericCreate+0x34>
        {
            /* Is a message buffer but not statically allocated. */
            ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
 4002590:	00800044 	movi	r2,1
 4002594:	e0bfffc5 	stb	r2,-1(fp)
 4002598:	00000106 	br	40025a0 <xStreamBufferGenericCreate+0x38>
            configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
        }
        else
        {
            /* Not a message buffer and not statically allocated. */
            ucFlags = 0;
 400259c:	e03fffc5 	stb	zero,-1(fp)

        configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );

        /* A trigger level of 0 would cause a waiting task to unblock even when
         * the buffer was empty. */
        if( xTriggerLevelBytes == ( size_t ) 0 )
 40025a0:	e0bffc17 	ldw	r2,-16(fp)
 40025a4:	1000021e 	bne	r2,zero,40025b0 <xStreamBufferGenericCreate+0x48>
        {
            xTriggerLevelBytes = ( size_t ) 1;
 40025a8:	00800044 	movi	r2,1
 40025ac:	e0bffc15 	stw	r2,-16(fp)
         * and the buffer follows immediately after.  The requested size is
         * incremented so the free space is returned as the user would expect -
         * this is a quirk of the implementation that means otherwise the free
         * space would be reported as one byte smaller than would be logically
         * expected. */
        xBufferSizeBytes++;
 40025b0:	e0bffd17 	ldw	r2,-12(fp)
 40025b4:	10800044 	addi	r2,r2,1
 40025b8:	e0bffd15 	stw	r2,-12(fp)
        pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
 40025bc:	e0bffd17 	ldw	r2,-12(fp)
 40025c0:	10800804 	addi	r2,r2,32
 40025c4:	1009883a 	mov	r4,r2
 40025c8:	40006340 	call	4000634 <pvPortMalloc>
 40025cc:	e0bffe15 	stw	r2,-8(fp)

        if( pucAllocatedMemory != NULL )
 40025d0:	e0bffe17 	ldw	r2,-8(fp)
 40025d4:	10000926 	beq	r2,zero,40025fc <xStreamBufferGenericCreate+0x94>
        {
            prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory,       /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
 40025d8:	e0bffe17 	ldw	r2,-8(fp)
 40025dc:	10c00804 	addi	r3,r2,32
 40025e0:	e0bfffc3 	ldbu	r2,-1(fp)
 40025e4:	d8800015 	stw	r2,0(sp)
 40025e8:	e1fffc17 	ldw	r7,-16(fp)
 40025ec:	e1bffd17 	ldw	r6,-12(fp)
 40025f0:	180b883a 	mov	r5,r3
 40025f4:	e13ffe17 	ldw	r4,-8(fp)
 40025f8:	40034180 	call	4003418 <prvInitialiseNewStreamBuffer>
        else
        {
            traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
        }

        return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
 40025fc:	e0bffe17 	ldw	r2,-8(fp)
    }
 4002600:	e037883a 	mov	sp,fp
 4002604:	dfc00117 	ldw	ra,4(sp)
 4002608:	df000017 	ldw	fp,0(sp)
 400260c:	dec00204 	addi	sp,sp,8
 4002610:	f800283a 	ret

04002614 <vStreamBufferDelete>:

#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
/*-----------------------------------------------------------*/

void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
{
 4002614:	defffc04 	addi	sp,sp,-16
 4002618:	dfc00315 	stw	ra,12(sp)
 400261c:	df000215 	stw	fp,8(sp)
 4002620:	df000204 	addi	fp,sp,8
 4002624:	e13ffe15 	stw	r4,-8(fp)
    StreamBuffer_t * pxStreamBuffer = xStreamBuffer;
 4002628:	e0bffe17 	ldw	r2,-8(fp)
 400262c:	e0bfff15 	stw	r2,-4(fp)

    configASSERT( pxStreamBuffer );

    traceSTREAM_BUFFER_DELETE( xStreamBuffer );

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
 4002630:	e0bfff17 	ldw	r2,-4(fp)
 4002634:	10800703 	ldbu	r2,28(r2)
 4002638:	10803fcc 	andi	r2,r2,255
 400263c:	1080008c 	andi	r2,r2,2
 4002640:	1000031e 	bne	r2,zero,4002650 <vStreamBufferDelete+0x3c>
    {
        #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
            {
                /* Both the structure and the buffer were allocated using a single call
                * to pvPortMalloc(), hence only one call to vPortFree() is required. */
                vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
 4002644:	e13fff17 	ldw	r4,-4(fp)
 4002648:	40006f40 	call	40006f4 <vPortFree>
    {
        /* The structure and buffer were not allocated dynamically and cannot be
         * freed - just scrub the structure so future use will assert. */
        ( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
    }
}
 400264c:	00000406 	br	4002660 <vStreamBufferDelete+0x4c>
        ( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
 4002650:	01800804 	movi	r6,32
 4002654:	000b883a 	mov	r5,zero
 4002658:	e13fff17 	ldw	r4,-4(fp)
 400265c:	40063340 	call	4006334 <memset>
}
 4002660:	0001883a 	nop
 4002664:	e037883a 	mov	sp,fp
 4002668:	dfc00117 	ldw	ra,4(sp)
 400266c:	df000017 	ldw	fp,0(sp)
 4002670:	dec00204 	addi	sp,sp,8
 4002674:	f800283a 	ret

04002678 <xStreamBufferReset>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
 4002678:	defffa04 	addi	sp,sp,-24
 400267c:	dfc00515 	stw	ra,20(sp)
 4002680:	df000415 	stw	fp,16(sp)
 4002684:	df000404 	addi	fp,sp,16
 4002688:	e13ffd15 	stw	r4,-12(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 400268c:	e0bffd17 	ldw	r2,-12(fp)
 4002690:	e0bffe15 	stw	r2,-8(fp)
    BaseType_t xReturn = pdFAIL;
 4002694:	e03fff15 	stw	zero,-4(fp)
            uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
        }
    #endif

    /* Can only reset a message buffer if there are no tasks blocked on it. */
    taskENTER_CRITICAL();
 4002698:	40050480 	call	4005048 <vTaskEnterCritical>
    {
        if( pxStreamBuffer->xTaskWaitingToReceive == NULL )
 400269c:	e0bffe17 	ldw	r2,-8(fp)
 40026a0:	10800417 	ldw	r2,16(r2)
 40026a4:	1000141e 	bne	r2,zero,40026f8 <xStreamBufferReset+0x80>
        {
            if( pxStreamBuffer->xTaskWaitingToSend == NULL )
 40026a8:	e0bffe17 	ldw	r2,-8(fp)
 40026ac:	10800517 	ldw	r2,20(r2)
 40026b0:	1000111e 	bne	r2,zero,40026f8 <xStreamBufferReset+0x80>
            {
                prvInitialiseNewStreamBuffer( pxStreamBuffer,
 40026b4:	e0bffe17 	ldw	r2,-8(fp)
 40026b8:	10c00617 	ldw	r3,24(r2)
 40026bc:	e0bffe17 	ldw	r2,-8(fp)
 40026c0:	11000217 	ldw	r4,8(r2)
 40026c4:	e0bffe17 	ldw	r2,-8(fp)
 40026c8:	11400317 	ldw	r5,12(r2)
                                              pxStreamBuffer->pucBuffer,
                                              pxStreamBuffer->xLength,
                                              pxStreamBuffer->xTriggerLevelBytes,
                                              pxStreamBuffer->ucFlags );
 40026cc:	e0bffe17 	ldw	r2,-8(fp)
 40026d0:	10800703 	ldbu	r2,28(r2)
                prvInitialiseNewStreamBuffer( pxStreamBuffer,
 40026d4:	10803fcc 	andi	r2,r2,255
 40026d8:	d8800015 	stw	r2,0(sp)
 40026dc:	280f883a 	mov	r7,r5
 40026e0:	200d883a 	mov	r6,r4
 40026e4:	180b883a 	mov	r5,r3
 40026e8:	e13ffe17 	ldw	r4,-8(fp)
 40026ec:	40034180 	call	4003418 <prvInitialiseNewStreamBuffer>
                xReturn = pdPASS;
 40026f0:	00800044 	movi	r2,1
 40026f4:	e0bfff15 	stw	r2,-4(fp)

                traceSTREAM_BUFFER_RESET( xStreamBuffer );
            }
        }
    }
    taskEXIT_CRITICAL();
 40026f8:	400509c0 	call	400509c <vTaskExitCritical>

    return xReturn;
 40026fc:	e0bfff17 	ldw	r2,-4(fp)
}
 4002700:	e037883a 	mov	sp,fp
 4002704:	dfc00117 	ldw	ra,4(sp)
 4002708:	df000017 	ldw	fp,0(sp)
 400270c:	dec00204 	addi	sp,sp,8
 4002710:	f800283a 	ret

04002714 <xStreamBufferSetTriggerLevel>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer,
                                         size_t xTriggerLevel )
{
 4002714:	defffb04 	addi	sp,sp,-20
 4002718:	df000415 	stw	fp,16(sp)
 400271c:	df000404 	addi	fp,sp,16
 4002720:	e13ffd15 	stw	r4,-12(fp)
 4002724:	e17ffc15 	stw	r5,-16(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 4002728:	e0bffd17 	ldw	r2,-12(fp)
 400272c:	e0bffe15 	stw	r2,-8(fp)
    BaseType_t xReturn;

    configASSERT( pxStreamBuffer );

    /* It is not valid for the trigger level to be 0. */
    if( xTriggerLevel == ( size_t ) 0 )
 4002730:	e0bffc17 	ldw	r2,-16(fp)
 4002734:	1000021e 	bne	r2,zero,4002740 <xStreamBufferSetTriggerLevel+0x2c>
    {
        xTriggerLevel = ( size_t ) 1;
 4002738:	00800044 	movi	r2,1
 400273c:	e0bffc15 	stw	r2,-16(fp)
    }

    /* The trigger level is the number of bytes that must be in the stream
     * buffer before a task that is waiting for data is unblocked. */
    if( xTriggerLevel <= pxStreamBuffer->xLength )
 4002740:	e0bffe17 	ldw	r2,-8(fp)
 4002744:	10c00217 	ldw	r3,8(r2)
 4002748:	e0bffc17 	ldw	r2,-16(fp)
 400274c:	18800636 	bltu	r3,r2,4002768 <xStreamBufferSetTriggerLevel+0x54>
    {
        pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
 4002750:	e0bffe17 	ldw	r2,-8(fp)
 4002754:	e0fffc17 	ldw	r3,-16(fp)
 4002758:	10c00315 	stw	r3,12(r2)
        xReturn = pdPASS;
 400275c:	00800044 	movi	r2,1
 4002760:	e0bfff15 	stw	r2,-4(fp)
 4002764:	00000106 	br	400276c <xStreamBufferSetTriggerLevel+0x58>
    }
    else
    {
        xReturn = pdFALSE;
 4002768:	e03fff15 	stw	zero,-4(fp)
    }

    return xReturn;
 400276c:	e0bfff17 	ldw	r2,-4(fp)
}
 4002770:	e037883a 	mov	sp,fp
 4002774:	df000017 	ldw	fp,0(sp)
 4002778:	dec00104 	addi	sp,sp,4
 400277c:	f800283a 	ret

04002780 <xStreamBufferSpacesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
{
 4002780:	defffc04 	addi	sp,sp,-16
 4002784:	df000315 	stw	fp,12(sp)
 4002788:	df000304 	addi	fp,sp,12
 400278c:	e13ffd15 	stw	r4,-12(fp)
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 4002790:	e0bffd17 	ldw	r2,-12(fp)
 4002794:	e0bffe15 	stw	r2,-8(fp)
    size_t xSpace;

    configASSERT( pxStreamBuffer );

    xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
 4002798:	e0bffe17 	ldw	r2,-8(fp)
 400279c:	10c00217 	ldw	r3,8(r2)
 40027a0:	e0bffe17 	ldw	r2,-8(fp)
 40027a4:	10800017 	ldw	r2,0(r2)
 40027a8:	1885883a 	add	r2,r3,r2
 40027ac:	e0bfff15 	stw	r2,-4(fp)
    xSpace -= pxStreamBuffer->xHead;
 40027b0:	e0bffe17 	ldw	r2,-8(fp)
 40027b4:	10800117 	ldw	r2,4(r2)
 40027b8:	e0ffff17 	ldw	r3,-4(fp)
 40027bc:	1885c83a 	sub	r2,r3,r2
 40027c0:	e0bfff15 	stw	r2,-4(fp)
    xSpace -= ( size_t ) 1;
 40027c4:	e0bfff17 	ldw	r2,-4(fp)
 40027c8:	10bfffc4 	addi	r2,r2,-1
 40027cc:	e0bfff15 	stw	r2,-4(fp)

    if( xSpace >= pxStreamBuffer->xLength )
 40027d0:	e0bffe17 	ldw	r2,-8(fp)
 40027d4:	10800217 	ldw	r2,8(r2)
 40027d8:	e0ffff17 	ldw	r3,-4(fp)
 40027dc:	18800536 	bltu	r3,r2,40027f4 <xStreamBufferSpacesAvailable+0x74>
    {
        xSpace -= pxStreamBuffer->xLength;
 40027e0:	e0bffe17 	ldw	r2,-8(fp)
 40027e4:	10800217 	ldw	r2,8(r2)
 40027e8:	e0ffff17 	ldw	r3,-4(fp)
 40027ec:	1885c83a 	sub	r2,r3,r2
 40027f0:	e0bfff15 	stw	r2,-4(fp)
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xSpace;
 40027f4:	e0bfff17 	ldw	r2,-4(fp)
}
 40027f8:	e037883a 	mov	sp,fp
 40027fc:	df000017 	ldw	fp,0(sp)
 4002800:	dec00104 	addi	sp,sp,4
 4002804:	f800283a 	ret

04002808 <xStreamBufferBytesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
{
 4002808:	defffb04 	addi	sp,sp,-20
 400280c:	dfc00415 	stw	ra,16(sp)
 4002810:	df000315 	stw	fp,12(sp)
 4002814:	df000304 	addi	fp,sp,12
 4002818:	e13ffd15 	stw	r4,-12(fp)
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 400281c:	e0bffd17 	ldw	r2,-12(fp)
 4002820:	e0bfff15 	stw	r2,-4(fp)
    size_t xReturn;

    configASSERT( pxStreamBuffer );

    xReturn = prvBytesInBuffer( pxStreamBuffer );
 4002824:	e13fff17 	ldw	r4,-4(fp)
 4002828:	40033a40 	call	40033a4 <prvBytesInBuffer>
 400282c:	e0bffe15 	stw	r2,-8(fp)
    return xReturn;
 4002830:	e0bffe17 	ldw	r2,-8(fp)
}
 4002834:	e037883a 	mov	sp,fp
 4002838:	dfc00117 	ldw	ra,4(sp)
 400283c:	df000017 	ldw	fp,0(sp)
 4002840:	dec00204 	addi	sp,sp,8
 4002844:	f800283a 	ret

04002848 <xStreamBufferSend>:

size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
                          const void * pvTxData,
                          size_t xDataLengthBytes,
                          TickType_t xTicksToWait )
{
 4002848:	defff204 	addi	sp,sp,-56
 400284c:	dfc00d15 	stw	ra,52(sp)
 4002850:	df000c15 	stw	fp,48(sp)
 4002854:	df000c04 	addi	fp,sp,48
 4002858:	e13ff815 	stw	r4,-32(fp)
 400285c:	e17ff715 	stw	r5,-36(fp)
 4002860:	e1bff615 	stw	r6,-40(fp)
 4002864:	e1fff515 	stw	r7,-44(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 4002868:	e0bff817 	ldw	r2,-32(fp)
 400286c:	e0bffc15 	stw	r2,-16(fp)
    size_t xReturn, xSpace = 0;
 4002870:	e03fff15 	stw	zero,-4(fp)
    size_t xRequiredSpace = xDataLengthBytes;
 4002874:	e0bff617 	ldw	r2,-40(fp)
 4002878:	e0bffe15 	stw	r2,-8(fp)

    /* This send function is used to write to both message buffers and stream
     * buffers.  If this is a message buffer then the space needed must be
     * increased by the amount of bytes needed to store the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 400287c:	e0bffc17 	ldw	r2,-16(fp)
 4002880:	10800703 	ldbu	r2,28(r2)
 4002884:	10803fcc 	andi	r2,r2,255
 4002888:	1080004c 	andi	r2,r2,1
 400288c:	10000c26 	beq	r2,zero,40028c0 <xStreamBufferSend+0x78>
    {
        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
 4002890:	e0bffe17 	ldw	r2,-8(fp)
 4002894:	10800104 	addi	r2,r2,4
 4002898:	e0bffe15 	stw	r2,-8(fp)
        configASSERT( xRequiredSpace > xDataLengthBytes );

        /* In the case of the message buffer, one has to be able to write the complete message as opposed to
         * a stream buffer for semantic reasons. Check if it is physically possible to write the message given
         * the length of the buffer. */
        if( xRequiredSpace > pxStreamBuffer->xLength )
 400289c:	e0bffc17 	ldw	r2,-16(fp)
 40028a0:	10c00217 	ldw	r3,8(r2)
 40028a4:	e0bffe17 	ldw	r2,-8(fp)
 40028a8:	1880022e 	bgeu	r3,r2,40028b4 <xStreamBufferSend+0x6c>
             * Now, the function will return 0 because the message could not be written. Should an error code be
             * returned instead ??? In my opinion, probably.. But the return type doesn't allow for negative
             * values to be returned. A confusion could exist to the caller. Returning 0 because a timeout occurred
             * and a subsequent send attempts could eventually succeed, and returning 0 because a write could never
             * happen because of the size are two scenarios to me :/ */
            xIsFeasible = pdFALSE;
 40028ac:	e03ffd15 	stw	zero,-12(fp)
 40028b0:	00000f06 	br	40028f0 <xStreamBufferSend+0xa8>
        }
        else
        {
            /* It is possible to write the message completely in the buffer. This is the intended route.
             * Let's continue with the regular timeout logic. */
            xIsFeasible = pdTRUE;
 40028b4:	00800044 	movi	r2,1
 40028b8:	e0bffd15 	stw	r2,-12(fp)
 40028bc:	00000c06 	br	40028f0 <xStreamBufferSend+0xa8>
    }
    else
    {
        /* In the case of the stream buffer, not being able to completely write the message in the buffer
         * is an acceptable scenario, but it has to be dealt with properly */
        if( xRequiredSpace > pxStreamBuffer->xLength )
 40028c0:	e0bffc17 	ldw	r2,-16(fp)
 40028c4:	10c00217 	ldw	r3,8(r2)
 40028c8:	e0bffe17 	ldw	r2,-8(fp)
 40028cc:	1880062e 	bgeu	r3,r2,40028e8 <xStreamBufferSend+0xa0>
        {
            /* Not enough buffer space. We will attempt to write as much as we can in this run
             * so that the caller can send the remaining in subsequent calls. We avoid a deadlock by
             * offering the possibility to take the 'else' branch in the  'if( xSpace < xRequiredSpace )'
             * condition inside the following do..while loop */
            xRequiredSpace = pxStreamBuffer->xLength;
 40028d0:	e0bffc17 	ldw	r2,-16(fp)
 40028d4:	10800217 	ldw	r2,8(r2)
 40028d8:	e0bffe15 	stw	r2,-8(fp)

            /* TODO FIXME: Is there a check we should do with the xTriggerLevelBytes value ? */

            /* With the adjustment to 'xRequiredSpace', the deadlock is avoided, thus it's now feasible. */
            xIsFeasible = pdTRUE;
 40028dc:	00800044 	movi	r2,1
 40028e0:	e0bffd15 	stw	r2,-12(fp)
 40028e4:	00000206 	br	40028f0 <xStreamBufferSend+0xa8>
        }
        else
        {
            /* It is possible to write the message completely in the buffer. */
            xIsFeasible = pdTRUE;
 40028e8:	00800044 	movi	r2,1
 40028ec:	e0bffd15 	stw	r2,-12(fp)
        }
    }

    /* Added check against xIsFeasible. If it's not feasible, don't even wait for notification, let the call to 'prvWriteMessageToBuffer' do nothing and return 0 */
    if( ( xTicksToWait != ( TickType_t ) 0 ) && ( xIsFeasible == pdTRUE ) )
 40028f0:	e0bff517 	ldw	r2,-44(fp)
 40028f4:	10002726 	beq	r2,zero,4002994 <xStreamBufferSend+0x14c>
 40028f8:	e0bffd17 	ldw	r2,-12(fp)
 40028fc:	10800058 	cmpnei	r2,r2,1
 4002900:	1000241e 	bne	r2,zero,4002994 <xStreamBufferSend+0x14c>
    {
        vTaskSetTimeOutState( &xTimeOut );
 4002904:	e0bff904 	addi	r2,fp,-28
 4002908:	1009883a 	mov	r4,r2
 400290c:	40048680 	call	4004868 <vTaskSetTimeOutState>

        do
        {
            /* Wait until the required number of bytes are free in the message
             * buffer. */
            taskENTER_CRITICAL();
 4002910:	40050480 	call	4005048 <vTaskEnterCritical>
            {
                xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
 4002914:	e13ffc17 	ldw	r4,-16(fp)
 4002918:	40027800 	call	4002780 <xStreamBufferSpacesAvailable>
 400291c:	e0bfff15 	stw	r2,-4(fp)

                if( xSpace < xRequiredSpace )
 4002920:	e0ffff17 	ldw	r3,-4(fp)
 4002924:	e0bffe17 	ldw	r2,-8(fp)
 4002928:	1880082e 	bgeu	r3,r2,400294c <xStreamBufferSend+0x104>
                {
                    /* Clear notification state as going to wait for space. */
                    ( void ) xTaskNotifyStateClear( NULL );
 400292c:	000b883a 	mov	r5,zero
 4002930:	0009883a 	mov	r4,zero
 4002934:	40059c00 	call	40059c0 <xTaskGenericNotifyStateClear>

                    /* Should only be one writer. */
                    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
                    pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
 4002938:	4004ca40 	call	4004ca4 <xTaskGetCurrentTaskHandle>
 400293c:	1007883a 	mov	r3,r2
 4002940:	e0bffc17 	ldw	r2,-16(fp)
 4002944:	10c00515 	stw	r3,20(r2)
 4002948:	00000206 	br	4002954 <xStreamBufferSend+0x10c>
                }
                else
                {
                    taskEXIT_CRITICAL();
 400294c:	400509c0 	call	400509c <vTaskExitCritical>
                    break;
 4002950:	00001006 	br	4002994 <xStreamBufferSend+0x14c>
                }
            }
            taskEXIT_CRITICAL();
 4002954:	400509c0 	call	400509c <vTaskExitCritical>

            traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
 4002958:	e0bff517 	ldw	r2,-44(fp)
 400295c:	d8800015 	stw	r2,0(sp)
 4002960:	000f883a 	mov	r7,zero
 4002964:	000d883a 	mov	r6,zero
 4002968:	000b883a 	mov	r5,zero
 400296c:	0009883a 	mov	r4,zero
 4002970:	40052800 	call	4005280 <xTaskGenericNotifyWait>
            pxStreamBuffer->xTaskWaitingToSend = NULL;
 4002974:	e0bffc17 	ldw	r2,-16(fp)
 4002978:	10000515 	stw	zero,20(r2)
        } while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
 400297c:	e0fff504 	addi	r3,fp,-44
 4002980:	e0bff904 	addi	r2,fp,-28
 4002984:	180b883a 	mov	r5,r3
 4002988:	1009883a 	mov	r4,r2
 400298c:	40048f00 	call	40048f0 <xTaskCheckForTimeOut>
 4002990:	103fdf26 	beq	r2,zero,4002910 <xStreamBufferSend+0xc8>
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    if( xSpace == ( size_t ) 0 )
 4002994:	e0bfff17 	ldw	r2,-4(fp)
 4002998:	1000031e 	bne	r2,zero,40029a8 <xStreamBufferSend+0x160>
    {
        xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
 400299c:	e13ffc17 	ldw	r4,-16(fp)
 40029a0:	40027800 	call	4002780 <xStreamBufferSpacesAvailable>
 40029a4:	e0bfff15 	stw	r2,-4(fp)
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
 40029a8:	e0bffe17 	ldw	r2,-8(fp)
 40029ac:	d8800015 	stw	r2,0(sp)
 40029b0:	e1ffff17 	ldw	r7,-4(fp)
 40029b4:	e1bff617 	ldw	r6,-40(fp)
 40029b8:	e17ff717 	ldw	r5,-36(fp)
 40029bc:	e13ffc17 	ldw	r4,-16(fp)
 40029c0:	4002b300 	call	4002b30 <prvWriteMessageToBuffer>
 40029c4:	e0bffb15 	stw	r2,-20(fp)

    if( xReturn > ( size_t ) 0 )
 40029c8:	e0bffb17 	ldw	r2,-20(fp)
 40029cc:	10001526 	beq	r2,zero,4002a24 <xStreamBufferSend+0x1dc>
    {
        traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );

        /* Was a task waiting for the data? */
        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
 40029d0:	e13ffc17 	ldw	r4,-16(fp)
 40029d4:	40033a40 	call	40033a4 <prvBytesInBuffer>
 40029d8:	1007883a 	mov	r3,r2
 40029dc:	e0bffc17 	ldw	r2,-16(fp)
 40029e0:	10800317 	ldw	r2,12(r2)
 40029e4:	18800f36 	bltu	r3,r2,4002a24 <xStreamBufferSend+0x1dc>
        {
            sbSEND_COMPLETED( pxStreamBuffer );
 40029e8:	40041000 	call	4004100 <vTaskSuspendAll>
 40029ec:	e0bffc17 	ldw	r2,-16(fp)
 40029f0:	10800417 	ldw	r2,16(r2)
 40029f4:	10000a26 	beq	r2,zero,4002a20 <xStreamBufferSend+0x1d8>
 40029f8:	e0bffc17 	ldw	r2,-16(fp)
 40029fc:	10800417 	ldw	r2,16(r2)
 4002a00:	d8000015 	stw	zero,0(sp)
 4002a04:	000f883a 	mov	r7,zero
 4002a08:	000d883a 	mov	r6,zero
 4002a0c:	000b883a 	mov	r5,zero
 4002a10:	1009883a 	mov	r4,r2
 4002a14:	40053e40 	call	40053e4 <xTaskGenericNotify>
 4002a18:	e0bffc17 	ldw	r2,-16(fp)
 4002a1c:	10000415 	stw	zero,16(r2)
 4002a20:	400412c0 	call	400412c <xTaskResumeAll>
    {
        mtCOVERAGE_TEST_MARKER();
        traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
    }

    return xReturn;
 4002a24:	e0bffb17 	ldw	r2,-20(fp)
}
 4002a28:	e037883a 	mov	sp,fp
 4002a2c:	dfc00117 	ldw	ra,4(sp)
 4002a30:	df000017 	ldw	fp,0(sp)
 4002a34:	dec00204 	addi	sp,sp,8
 4002a38:	f800283a 	ret

04002a3c <xStreamBufferSendFromISR>:

size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
                                 const void * pvTxData,
                                 size_t xDataLengthBytes,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
 4002a3c:	defff304 	addi	sp,sp,-52
 4002a40:	dfc00c15 	stw	ra,48(sp)
 4002a44:	df000b15 	stw	fp,44(sp)
 4002a48:	df000b04 	addi	fp,sp,44
 4002a4c:	e13ffa15 	stw	r4,-24(fp)
 4002a50:	e17ff915 	stw	r5,-28(fp)
 4002a54:	e1bff815 	stw	r6,-32(fp)
 4002a58:	e1fff715 	stw	r7,-36(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 4002a5c:	e0bffa17 	ldw	r2,-24(fp)
 4002a60:	e0bffe15 	stw	r2,-8(fp)
    size_t xReturn, xSpace;
    size_t xRequiredSpace = xDataLengthBytes;
 4002a64:	e0bff817 	ldw	r2,-32(fp)
 4002a68:	e0bfff15 	stw	r2,-4(fp)

    /* This send function is used to write to both message buffers and stream
     * buffers.  If this is a message buffer then the space needed must be
     * increased by the amount of bytes needed to store the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 4002a6c:	e0bffe17 	ldw	r2,-8(fp)
 4002a70:	10800703 	ldbu	r2,28(r2)
 4002a74:	10803fcc 	andi	r2,r2,255
 4002a78:	1080004c 	andi	r2,r2,1
 4002a7c:	10000326 	beq	r2,zero,4002a8c <xStreamBufferSendFromISR+0x50>
    {
        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
 4002a80:	e0bfff17 	ldw	r2,-4(fp)
 4002a84:	10800104 	addi	r2,r2,4
 4002a88:	e0bfff15 	stw	r2,-4(fp)
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
 4002a8c:	e13ffe17 	ldw	r4,-8(fp)
 4002a90:	40027800 	call	4002780 <xStreamBufferSpacesAvailable>
 4002a94:	e0bffd15 	stw	r2,-12(fp)
    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
 4002a98:	e0bfff17 	ldw	r2,-4(fp)
 4002a9c:	d8800015 	stw	r2,0(sp)
 4002aa0:	e1fffd17 	ldw	r7,-12(fp)
 4002aa4:	e1bff817 	ldw	r6,-32(fp)
 4002aa8:	e17ff917 	ldw	r5,-28(fp)
 4002aac:	e13ffe17 	ldw	r4,-8(fp)
 4002ab0:	4002b300 	call	4002b30 <prvWriteMessageToBuffer>
 4002ab4:	e0bffc15 	stw	r2,-16(fp)

    if( xReturn > ( size_t ) 0 )
 4002ab8:	e0bffc17 	ldw	r2,-16(fp)
 4002abc:	10001626 	beq	r2,zero,4002b18 <xStreamBufferSendFromISR+0xdc>
    {
        /* Was a task waiting for the data? */
        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
 4002ac0:	e13ffe17 	ldw	r4,-8(fp)
 4002ac4:	40033a40 	call	40033a4 <prvBytesInBuffer>
 4002ac8:	1007883a 	mov	r3,r2
 4002acc:	e0bffe17 	ldw	r2,-8(fp)
 4002ad0:	10800317 	ldw	r2,12(r2)
 4002ad4:	18801036 	bltu	r3,r2,4002b18 <xStreamBufferSendFromISR+0xdc>
        {
            sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
 4002ad8:	e03ffb15 	stw	zero,-20(fp)
 4002adc:	e0bffe17 	ldw	r2,-8(fp)
 4002ae0:	10800417 	ldw	r2,16(r2)
 4002ae4:	10000c26 	beq	r2,zero,4002b18 <xStreamBufferSendFromISR+0xdc>
 4002ae8:	e0bffe17 	ldw	r2,-8(fp)
 4002aec:	10c00417 	ldw	r3,16(r2)
 4002af0:	e0bff717 	ldw	r2,-36(fp)
 4002af4:	d8800115 	stw	r2,4(sp)
 4002af8:	d8000015 	stw	zero,0(sp)
 4002afc:	000f883a 	mov	r7,zero
 4002b00:	000d883a 	mov	r6,zero
 4002b04:	000b883a 	mov	r5,zero
 4002b08:	1809883a 	mov	r4,r3
 4002b0c:	400560c0 	call	400560c <xTaskGenericNotifyFromISR>
 4002b10:	e0bffe17 	ldw	r2,-8(fp)
 4002b14:	10000415 	stw	zero,16(r2)
        mtCOVERAGE_TEST_MARKER();
    }

    traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

    return xReturn;
 4002b18:	e0bffc17 	ldw	r2,-16(fp)
}
 4002b1c:	e037883a 	mov	sp,fp
 4002b20:	dfc00117 	ldw	ra,4(sp)
 4002b24:	df000017 	ldw	fp,0(sp)
 4002b28:	dec00204 	addi	sp,sp,8
 4002b2c:	f800283a 	ret

04002b30 <prvWriteMessageToBuffer>:
static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
                                       const void * pvTxData,
                                       size_t xDataLengthBytes,
                                       size_t xSpace,
                                       size_t xRequiredSpace )
{
 4002b30:	defff804 	addi	sp,sp,-32
 4002b34:	dfc00715 	stw	ra,28(sp)
 4002b38:	df000615 	stw	fp,24(sp)
 4002b3c:	df000604 	addi	fp,sp,24
 4002b40:	e13ffd15 	stw	r4,-12(fp)
 4002b44:	e17ffc15 	stw	r5,-16(fp)
 4002b48:	e1bffb15 	stw	r6,-20(fp)
 4002b4c:	e1fffa15 	stw	r7,-24(fp)
    BaseType_t xShouldWrite;
    size_t xReturn;

    if( xSpace == ( size_t ) 0 )
 4002b50:	e0bffa17 	ldw	r2,-24(fp)
 4002b54:	1000021e 	bne	r2,zero,4002b60 <prvWriteMessageToBuffer+0x30>
    {
        /* Doesn't matter if this is a stream buffer or a message buffer, there
         * is no space to write. */
        xShouldWrite = pdFALSE;
 4002b58:	e03fff15 	stw	zero,-4(fp)
 4002b5c:	00001906 	br	4002bc4 <prvWriteMessageToBuffer+0x94>
    }
    else if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) == ( uint8_t ) 0 )
 4002b60:	e0bffd17 	ldw	r2,-12(fp)
 4002b64:	10800703 	ldbu	r2,28(r2)
 4002b68:	10803fcc 	andi	r2,r2,255
 4002b6c:	1080004c 	andi	r2,r2,1
 4002b70:	1000081e 	bne	r2,zero,4002b94 <prvWriteMessageToBuffer+0x64>
    {
        /* This is a stream buffer, as opposed to a message buffer, so writing a
         * stream of bytes rather than discrete messages.  Write as many bytes as
         * possible. */
        xShouldWrite = pdTRUE;
 4002b74:	00800044 	movi	r2,1
 4002b78:	e0bfff15 	stw	r2,-4(fp)
        xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
 4002b7c:	e0fffb17 	ldw	r3,-20(fp)
 4002b80:	e0bffa17 	ldw	r2,-24(fp)
 4002b84:	1880012e 	bgeu	r3,r2,4002b8c <prvWriteMessageToBuffer+0x5c>
 4002b88:	1805883a 	mov	r2,r3
 4002b8c:	e0bffb15 	stw	r2,-20(fp)
 4002b90:	00000c06 	br	4002bc4 <prvWriteMessageToBuffer+0x94>
    }
    else if( xSpace >= xRequiredSpace )
 4002b94:	e0fffa17 	ldw	r3,-24(fp)
 4002b98:	e0800217 	ldw	r2,8(fp)
 4002b9c:	18800836 	bltu	r3,r2,4002bc0 <prvWriteMessageToBuffer+0x90>
    {
        /* This is a message buffer, as opposed to a stream buffer, and there
         * is enough space to write both the message length and the message itself
         * into the buffer.  Start by writing the length of the data, the data
         * itself will be written later in this function. */
        xShouldWrite = pdTRUE;
 4002ba0:	00800044 	movi	r2,1
 4002ba4:	e0bfff15 	stw	r2,-4(fp)
        ( void ) prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH );
 4002ba8:	e0bffb04 	addi	r2,fp,-20
 4002bac:	01800104 	movi	r6,4
 4002bb0:	100b883a 	mov	r5,r2
 4002bb4:	e13ffd17 	ldw	r4,-12(fp)
 4002bb8:	400319c0 	call	400319c <prvWriteBytesToBuffer>
 4002bbc:	00000106 	br	4002bc4 <prvWriteMessageToBuffer+0x94>
    }
    else
    {
        /* There is space available, but not enough space. */
        xShouldWrite = pdFALSE;
 4002bc0:	e03fff15 	stw	zero,-4(fp)
    }

    if( xShouldWrite != pdFALSE )
 4002bc4:	e0bfff17 	ldw	r2,-4(fp)
 4002bc8:	10000726 	beq	r2,zero,4002be8 <prvWriteMessageToBuffer+0xb8>
    {
        /* Writes the data itself. */
        xReturn = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alignment and access. */
 4002bcc:	e0bffb17 	ldw	r2,-20(fp)
 4002bd0:	100d883a 	mov	r6,r2
 4002bd4:	e17ffc17 	ldw	r5,-16(fp)
 4002bd8:	e13ffd17 	ldw	r4,-12(fp)
 4002bdc:	400319c0 	call	400319c <prvWriteBytesToBuffer>
 4002be0:	e0bffe15 	stw	r2,-8(fp)
 4002be4:	00000106 	br	4002bec <prvWriteMessageToBuffer+0xbc>
    }
    else
    {
        xReturn = 0;
 4002be8:	e03ffe15 	stw	zero,-8(fp)
    }

    return xReturn;
 4002bec:	e0bffe17 	ldw	r2,-8(fp)
}
 4002bf0:	e037883a 	mov	sp,fp
 4002bf4:	dfc00117 	ldw	ra,4(sp)
 4002bf8:	df000017 	ldw	fp,0(sp)
 4002bfc:	dec00204 	addi	sp,sp,8
 4002c00:	f800283a 	ret

04002c04 <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
                             void * pvRxData,
                             size_t xBufferLengthBytes,
                             TickType_t xTicksToWait )
{
 4002c04:	defff504 	addi	sp,sp,-44
 4002c08:	dfc00a15 	stw	ra,40(sp)
 4002c0c:	df000915 	stw	fp,36(sp)
 4002c10:	df000904 	addi	fp,sp,36
 4002c14:	e13ffb15 	stw	r4,-20(fp)
 4002c18:	e17ffa15 	stw	r5,-24(fp)
 4002c1c:	e1bff915 	stw	r6,-28(fp)
 4002c20:	e1fff815 	stw	r7,-32(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 4002c24:	e0bffb17 	ldw	r2,-20(fp)
 4002c28:	e0bffc15 	stw	r2,-16(fp)
    size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
 4002c2c:	e03fff15 	stw	zero,-4(fp)
    /* This receive function is used by both message buffers, which store
     * discrete messages, and stream buffers, which store a continuous stream of
     * bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 4002c30:	e0bffc17 	ldw	r2,-16(fp)
 4002c34:	10800703 	ldbu	r2,28(r2)
 4002c38:	10803fcc 	andi	r2,r2,255
 4002c3c:	1080004c 	andi	r2,r2,1
 4002c40:	10000326 	beq	r2,zero,4002c50 <xStreamBufferReceive+0x4c>
    {
        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
 4002c44:	00800104 	movi	r2,4
 4002c48:	e0bffd15 	stw	r2,-12(fp)
 4002c4c:	00000106 	br	4002c54 <xStreamBufferReceive+0x50>
    }
    else
    {
        xBytesToStoreMessageLength = 0;
 4002c50:	e03ffd15 	stw	zero,-12(fp)
    }

    if( xTicksToWait != ( TickType_t ) 0 )
 4002c54:	e0bff817 	ldw	r2,-32(fp)
 4002c58:	10001f26 	beq	r2,zero,4002cd8 <xStreamBufferReceive+0xd4>
    {
        /* Checking if there is data and clearing the notification state must be
         * performed atomically. */
        taskENTER_CRITICAL();
 4002c5c:	40050480 	call	4005048 <vTaskEnterCritical>
        {
            xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 4002c60:	e13ffc17 	ldw	r4,-16(fp)
 4002c64:	40033a40 	call	40033a4 <prvBytesInBuffer>
 4002c68:	e0bffe15 	stw	r2,-8(fp)
            /* If this function was invoked by a message buffer read then
             * xBytesToStoreMessageLength holds the number of bytes used to hold
             * the length of the next discrete message.  If this function was
             * invoked by a stream buffer read then xBytesToStoreMessageLength will
             * be 0. */
            if( xBytesAvailable <= xBytesToStoreMessageLength )
 4002c6c:	e0bffe17 	ldw	r2,-8(fp)
 4002c70:	e0fffd17 	ldw	r3,-12(fp)
 4002c74:	18800736 	bltu	r3,r2,4002c94 <xStreamBufferReceive+0x90>
            {
                /* Clear notification state as going to wait for data. */
                ( void ) xTaskNotifyStateClear( NULL );
 4002c78:	000b883a 	mov	r5,zero
 4002c7c:	0009883a 	mov	r4,zero
 4002c80:	40059c00 	call	40059c0 <xTaskGenericNotifyStateClear>

                /* Should only be one reader. */
                configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
                pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
 4002c84:	4004ca40 	call	4004ca4 <xTaskGetCurrentTaskHandle>
 4002c88:	1007883a 	mov	r3,r2
 4002c8c:	e0bffc17 	ldw	r2,-16(fp)
 4002c90:	10c00415 	stw	r3,16(r2)
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
 4002c94:	400509c0 	call	400509c <vTaskExitCritical>

        if( xBytesAvailable <= xBytesToStoreMessageLength )
 4002c98:	e0bffe17 	ldw	r2,-8(fp)
 4002c9c:	e0fffd17 	ldw	r3,-12(fp)
 4002ca0:	18801036 	bltu	r3,r2,4002ce4 <xStreamBufferReceive+0xe0>
        {
            /* Wait for data to be available. */
            traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
 4002ca4:	e0bff817 	ldw	r2,-32(fp)
 4002ca8:	d8800015 	stw	r2,0(sp)
 4002cac:	000f883a 	mov	r7,zero
 4002cb0:	000d883a 	mov	r6,zero
 4002cb4:	000b883a 	mov	r5,zero
 4002cb8:	0009883a 	mov	r4,zero
 4002cbc:	40052800 	call	4005280 <xTaskGenericNotifyWait>
            pxStreamBuffer->xTaskWaitingToReceive = NULL;
 4002cc0:	e0bffc17 	ldw	r2,-16(fp)
 4002cc4:	10000415 	stw	zero,16(r2)

            /* Recheck the data available after blocking. */
            xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 4002cc8:	e13ffc17 	ldw	r4,-16(fp)
 4002ccc:	40033a40 	call	40033a4 <prvBytesInBuffer>
 4002cd0:	e0bffe15 	stw	r2,-8(fp)
 4002cd4:	00000306 	br	4002ce4 <xStreamBufferReceive+0xe0>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 4002cd8:	e13ffc17 	ldw	r4,-16(fp)
 4002cdc:	40033a40 	call	40033a4 <prvBytesInBuffer>
 4002ce0:	e0bffe15 	stw	r2,-8(fp)
    /* Whether receiving a discrete message (where xBytesToStoreMessageLength
     * holds the number of bytes used to store the message length) or a stream of
     * bytes (where xBytesToStoreMessageLength is zero), the number of bytes
     * available must be greater than xBytesToStoreMessageLength to be able to
     * read bytes from the buffer. */
    if( xBytesAvailable > xBytesToStoreMessageLength )
 4002ce4:	e0bffe17 	ldw	r2,-8(fp)
 4002ce8:	e0fffd17 	ldw	r3,-12(fp)
 4002cec:	1880192e 	bgeu	r3,r2,4002d54 <xStreamBufferReceive+0x150>
    {
        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
 4002cf0:	e0bffd17 	ldw	r2,-12(fp)
 4002cf4:	d8800015 	stw	r2,0(sp)
 4002cf8:	e1fffe17 	ldw	r7,-8(fp)
 4002cfc:	e1bff917 	ldw	r6,-28(fp)
 4002d00:	e17ffa17 	ldw	r5,-24(fp)
 4002d04:	e13ffc17 	ldw	r4,-16(fp)
 4002d08:	4002efc0 	call	4002efc <prvReadMessageFromBuffer>
 4002d0c:	e0bfff15 	stw	r2,-4(fp)

        /* Was a task waiting for space in the buffer? */
        if( xReceivedLength != ( size_t ) 0 )
 4002d10:	e0bfff17 	ldw	r2,-4(fp)
 4002d14:	10000f26 	beq	r2,zero,4002d54 <xStreamBufferReceive+0x150>
        {
            traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
            sbRECEIVE_COMPLETED( pxStreamBuffer );
 4002d18:	40041000 	call	4004100 <vTaskSuspendAll>
 4002d1c:	e0bffc17 	ldw	r2,-16(fp)
 4002d20:	10800517 	ldw	r2,20(r2)
 4002d24:	10000a26 	beq	r2,zero,4002d50 <xStreamBufferReceive+0x14c>
 4002d28:	e0bffc17 	ldw	r2,-16(fp)
 4002d2c:	10800517 	ldw	r2,20(r2)
 4002d30:	d8000015 	stw	zero,0(sp)
 4002d34:	000f883a 	mov	r7,zero
 4002d38:	000d883a 	mov	r6,zero
 4002d3c:	000b883a 	mov	r5,zero
 4002d40:	1009883a 	mov	r4,r2
 4002d44:	40053e40 	call	40053e4 <xTaskGenericNotify>
 4002d48:	e0bffc17 	ldw	r2,-16(fp)
 4002d4c:	10000515 	stw	zero,20(r2)
 4002d50:	400412c0 	call	400412c <xTaskResumeAll>
    {
        traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
        mtCOVERAGE_TEST_MARKER();
    }

    return xReceivedLength;
 4002d54:	e0bfff17 	ldw	r2,-4(fp)
}
 4002d58:	e037883a 	mov	sp,fp
 4002d5c:	dfc00117 	ldw	ra,4(sp)
 4002d60:	df000017 	ldw	fp,0(sp)
 4002d64:	dec00204 	addi	sp,sp,8
 4002d68:	f800283a 	ret

04002d6c <xStreamBufferNextMessageLengthBytes>:
/*-----------------------------------------------------------*/

size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
{
 4002d6c:	defff804 	addi	sp,sp,-32
 4002d70:	dfc00715 	stw	ra,28(sp)
 4002d74:	df000615 	stw	fp,24(sp)
 4002d78:	df000604 	addi	fp,sp,24
 4002d7c:	e13ffa15 	stw	r4,-24(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 4002d80:	e0bffa17 	ldw	r2,-24(fp)
 4002d84:	e0bffe15 	stw	r2,-8(fp)
    configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;

    configASSERT( pxStreamBuffer );

    /* Ensure the stream buffer is being used as a message buffer. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 4002d88:	e0bffe17 	ldw	r2,-8(fp)
 4002d8c:	10800703 	ldbu	r2,28(r2)
 4002d90:	10803fcc 	andi	r2,r2,255
 4002d94:	1080004c 	andi	r2,r2,1
 4002d98:	10001726 	beq	r2,zero,4002df8 <xStreamBufferNextMessageLengthBytes+0x8c>
    {
        xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 4002d9c:	e13ffe17 	ldw	r4,-8(fp)
 4002da0:	40033a40 	call	40033a4 <prvBytesInBuffer>
 4002da4:	e0bffd15 	stw	r2,-12(fp)

        if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
 4002da8:	e0bffd17 	ldw	r2,-12(fp)
 4002dac:	10800170 	cmpltui	r2,r2,5
 4002db0:	10000f1e 	bne	r2,zero,4002df0 <xStreamBufferNextMessageLengthBytes+0x84>
             * required to hold the length of the next message, so another message
             * is available.  Return its length without removing the length bytes
             * from the buffer.  A copy of the tail is stored so the buffer can be
             * returned to its prior state as the message is not actually being
             * removed from the buffer. */
            xOriginalTail = pxStreamBuffer->xTail;
 4002db4:	e0bffe17 	ldw	r2,-8(fp)
 4002db8:	10800017 	ldw	r2,0(r2)
 4002dbc:	e0bffc15 	stw	r2,-16(fp)
            ( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, xBytesAvailable );
 4002dc0:	e0bffb04 	addi	r2,fp,-20
 4002dc4:	e1fffd17 	ldw	r7,-12(fp)
 4002dc8:	01800104 	movi	r6,4
 4002dcc:	100b883a 	mov	r5,r2
 4002dd0:	e13ffe17 	ldw	r4,-8(fp)
 4002dd4:	40032900 	call	4003290 <prvReadBytesFromBuffer>
            xReturn = ( size_t ) xTempReturn;
 4002dd8:	e0bffb17 	ldw	r2,-20(fp)
 4002ddc:	e0bfff15 	stw	r2,-4(fp)
            pxStreamBuffer->xTail = xOriginalTail;
 4002de0:	e0bffe17 	ldw	r2,-8(fp)
 4002de4:	e0fffc17 	ldw	r3,-16(fp)
 4002de8:	10c00015 	stw	r3,0(r2)
 4002dec:	00000306 	br	4002dfc <xStreamBufferNextMessageLengthBytes+0x90>
            /* The minimum amount of bytes in a message buffer is
             * ( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
             * less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
             * value is 0. */
            configASSERT( xBytesAvailable == 0 );
            xReturn = 0;
 4002df0:	e03fff15 	stw	zero,-4(fp)
 4002df4:	00000106 	br	4002dfc <xStreamBufferNextMessageLengthBytes+0x90>
        }
    }
    else
    {
        xReturn = 0;
 4002df8:	e03fff15 	stw	zero,-4(fp)
    }

    return xReturn;
 4002dfc:	e0bfff17 	ldw	r2,-4(fp)
}
 4002e00:	e037883a 	mov	sp,fp
 4002e04:	dfc00117 	ldw	ra,4(sp)
 4002e08:	df000017 	ldw	fp,0(sp)
 4002e0c:	dec00204 	addi	sp,sp,8
 4002e10:	f800283a 	ret

04002e14 <xStreamBufferReceiveFromISR>:

size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
                                    void * pvRxData,
                                    size_t xBufferLengthBytes,
                                    BaseType_t * const pxHigherPriorityTaskWoken )
{
 4002e14:	defff304 	addi	sp,sp,-52
 4002e18:	dfc00c15 	stw	ra,48(sp)
 4002e1c:	df000b15 	stw	fp,44(sp)
 4002e20:	df000b04 	addi	fp,sp,44
 4002e24:	e13ffa15 	stw	r4,-24(fp)
 4002e28:	e17ff915 	stw	r5,-28(fp)
 4002e2c:	e1bff815 	stw	r6,-32(fp)
 4002e30:	e1fff715 	stw	r7,-36(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 4002e34:	e0bffa17 	ldw	r2,-24(fp)
 4002e38:	e0bffd15 	stw	r2,-12(fp)
    size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
 4002e3c:	e03fff15 	stw	zero,-4(fp)
    /* This receive function is used by both message buffers, which store
     * discrete messages, and stream buffers, which store a continuous stream of
     * bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 4002e40:	e0bffd17 	ldw	r2,-12(fp)
 4002e44:	10800703 	ldbu	r2,28(r2)
 4002e48:	10803fcc 	andi	r2,r2,255
 4002e4c:	1080004c 	andi	r2,r2,1
 4002e50:	10000326 	beq	r2,zero,4002e60 <xStreamBufferReceiveFromISR+0x4c>
    {
        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
 4002e54:	00800104 	movi	r2,4
 4002e58:	e0bffe15 	stw	r2,-8(fp)
 4002e5c:	00000106 	br	4002e64 <xStreamBufferReceiveFromISR+0x50>
    }
    else
    {
        xBytesToStoreMessageLength = 0;
 4002e60:	e03ffe15 	stw	zero,-8(fp)
    }

    xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 4002e64:	e13ffd17 	ldw	r4,-12(fp)
 4002e68:	40033a40 	call	40033a4 <prvBytesInBuffer>
 4002e6c:	e0bffc15 	stw	r2,-16(fp)
    /* Whether receiving a discrete message (where xBytesToStoreMessageLength
     * holds the number of bytes used to store the message length) or a stream of
     * bytes (where xBytesToStoreMessageLength is zero), the number of bytes
     * available must be greater than xBytesToStoreMessageLength to be able to
     * read bytes from the buffer. */
    if( xBytesAvailable > xBytesToStoreMessageLength )
 4002e70:	e0bffc17 	ldw	r2,-16(fp)
 4002e74:	e0fffe17 	ldw	r3,-8(fp)
 4002e78:	18801a2e 	bgeu	r3,r2,4002ee4 <xStreamBufferReceiveFromISR+0xd0>
    {
        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
 4002e7c:	e0bffe17 	ldw	r2,-8(fp)
 4002e80:	d8800015 	stw	r2,0(sp)
 4002e84:	e1fffc17 	ldw	r7,-16(fp)
 4002e88:	e1bff817 	ldw	r6,-32(fp)
 4002e8c:	e17ff917 	ldw	r5,-28(fp)
 4002e90:	e13ffd17 	ldw	r4,-12(fp)
 4002e94:	4002efc0 	call	4002efc <prvReadMessageFromBuffer>
 4002e98:	e0bfff15 	stw	r2,-4(fp)

        /* Was a task waiting for space in the buffer? */
        if( xReceivedLength != ( size_t ) 0 )
 4002e9c:	e0bfff17 	ldw	r2,-4(fp)
 4002ea0:	10001026 	beq	r2,zero,4002ee4 <xStreamBufferReceiveFromISR+0xd0>
        {
            sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
 4002ea4:	e03ffb15 	stw	zero,-20(fp)
 4002ea8:	e0bffd17 	ldw	r2,-12(fp)
 4002eac:	10800517 	ldw	r2,20(r2)
 4002eb0:	10000c26 	beq	r2,zero,4002ee4 <xStreamBufferReceiveFromISR+0xd0>
 4002eb4:	e0bffd17 	ldw	r2,-12(fp)
 4002eb8:	10c00517 	ldw	r3,20(r2)
 4002ebc:	e0bff717 	ldw	r2,-36(fp)
 4002ec0:	d8800115 	stw	r2,4(sp)
 4002ec4:	d8000015 	stw	zero,0(sp)
 4002ec8:	000f883a 	mov	r7,zero
 4002ecc:	000d883a 	mov	r6,zero
 4002ed0:	000b883a 	mov	r5,zero
 4002ed4:	1809883a 	mov	r4,r3
 4002ed8:	400560c0 	call	400560c <xTaskGenericNotifyFromISR>
 4002edc:	e0bffd17 	ldw	r2,-12(fp)
 4002ee0:	10000515 	stw	zero,20(r2)
        mtCOVERAGE_TEST_MARKER();
    }

    traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );

    return xReceivedLength;
 4002ee4:	e0bfff17 	ldw	r2,-4(fp)
}
 4002ee8:	e037883a 	mov	sp,fp
 4002eec:	dfc00117 	ldw	ra,4(sp)
 4002ef0:	df000017 	ldw	fp,0(sp)
 4002ef4:	dec00204 	addi	sp,sp,8
 4002ef8:	f800283a 	ret

04002efc <prvReadMessageFromBuffer>:
static size_t prvReadMessageFromBuffer( StreamBuffer_t * pxStreamBuffer,
                                        void * pvRxData,
                                        size_t xBufferLengthBytes,
                                        size_t xBytesAvailable,
                                        size_t xBytesToStoreMessageLength )
{
 4002efc:	defff604 	addi	sp,sp,-40
 4002f00:	dfc00915 	stw	ra,36(sp)
 4002f04:	df000815 	stw	fp,32(sp)
 4002f08:	df000804 	addi	fp,sp,32
 4002f0c:	e13ffb15 	stw	r4,-20(fp)
 4002f10:	e17ffa15 	stw	r5,-24(fp)
 4002f14:	e1bff915 	stw	r6,-28(fp)
 4002f18:	e1fff815 	stw	r7,-32(fp)
    size_t xOriginalTail, xReceivedLength, xNextMessageLength;
    configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;

    if( xBytesToStoreMessageLength != ( size_t ) 0 )
 4002f1c:	e0800217 	ldw	r2,8(fp)
 4002f20:	10001726 	beq	r2,zero,4002f80 <prvReadMessageFromBuffer+0x84>
    {
        /* A discrete message is being received.  First receive the length
         * of the message.  A copy of the tail is stored so the buffer can be
         * returned to its prior state if the length of the message is too
         * large for the provided buffer. */
        xOriginalTail = pxStreamBuffer->xTail;
 4002f24:	e0bffb17 	ldw	r2,-20(fp)
 4002f28:	10800017 	ldw	r2,0(r2)
 4002f2c:	e0bffe15 	stw	r2,-8(fp)
        ( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, xBytesToStoreMessageLength, xBytesAvailable );
 4002f30:	e0bffc04 	addi	r2,fp,-16
 4002f34:	e1fff817 	ldw	r7,-32(fp)
 4002f38:	e1800217 	ldw	r6,8(fp)
 4002f3c:	100b883a 	mov	r5,r2
 4002f40:	e13ffb17 	ldw	r4,-20(fp)
 4002f44:	40032900 	call	4003290 <prvReadBytesFromBuffer>
        xNextMessageLength = ( size_t ) xTempNextMessageLength;
 4002f48:	e0bffc17 	ldw	r2,-16(fp)
 4002f4c:	e0bfff15 	stw	r2,-4(fp)

        /* Reduce the number of bytes available by the number of bytes just
         * read out. */
        xBytesAvailable -= xBytesToStoreMessageLength;
 4002f50:	e0fff817 	ldw	r3,-32(fp)
 4002f54:	e0800217 	ldw	r2,8(fp)
 4002f58:	1885c83a 	sub	r2,r3,r2
 4002f5c:	e0bff815 	stw	r2,-32(fp)

        /* Check there is enough space in the buffer provided by the
         * user. */
        if( xNextMessageLength > xBufferLengthBytes )
 4002f60:	e0bfff17 	ldw	r2,-4(fp)
 4002f64:	e0fff917 	ldw	r3,-28(fp)
 4002f68:	1880072e 	bgeu	r3,r2,4002f88 <prvReadMessageFromBuffer+0x8c>
        {
            /* The user has provided insufficient space to read the message
             * so return the buffer to its previous state (so the length of
             * the message is in the buffer again). */
            pxStreamBuffer->xTail = xOriginalTail;
 4002f6c:	e0bffb17 	ldw	r2,-20(fp)
 4002f70:	e0fffe17 	ldw	r3,-8(fp)
 4002f74:	10c00015 	stw	r3,0(r2)
            xNextMessageLength = 0;
 4002f78:	e03fff15 	stw	zero,-4(fp)
 4002f7c:	00000206 	br	4002f88 <prvReadMessageFromBuffer+0x8c>
    }
    else
    {
        /* A stream of bytes is being received (as opposed to a discrete
         * message), so read as many bytes as possible. */
        xNextMessageLength = xBufferLengthBytes;
 4002f80:	e0bff917 	ldw	r2,-28(fp)
 4002f84:	e0bfff15 	stw	r2,-4(fp)
    }

    /* Read the actual data. */
    xReceivedLength = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xNextMessageLength, xBytesAvailable ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
 4002f88:	e1fff817 	ldw	r7,-32(fp)
 4002f8c:	e1bfff17 	ldw	r6,-4(fp)
 4002f90:	e17ffa17 	ldw	r5,-24(fp)
 4002f94:	e13ffb17 	ldw	r4,-20(fp)
 4002f98:	40032900 	call	4003290 <prvReadBytesFromBuffer>
 4002f9c:	e0bffd15 	stw	r2,-12(fp)

    return xReceivedLength;
 4002fa0:	e0bffd17 	ldw	r2,-12(fp)
}
 4002fa4:	e037883a 	mov	sp,fp
 4002fa8:	dfc00117 	ldw	ra,4(sp)
 4002fac:	df000017 	ldw	fp,0(sp)
 4002fb0:	dec00204 	addi	sp,sp,8
 4002fb4:	f800283a 	ret

04002fb8 <xStreamBufferIsEmpty>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
{
 4002fb8:	defffb04 	addi	sp,sp,-20
 4002fbc:	df000415 	stw	fp,16(sp)
 4002fc0:	df000404 	addi	fp,sp,16
 4002fc4:	e13ffc15 	stw	r4,-16(fp)
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 4002fc8:	e0bffc17 	ldw	r2,-16(fp)
 4002fcc:	e0bffe15 	stw	r2,-8(fp)
    size_t xTail;

    configASSERT( pxStreamBuffer );

    /* True if no bytes are available. */
    xTail = pxStreamBuffer->xTail;
 4002fd0:	e0bffe17 	ldw	r2,-8(fp)
 4002fd4:	10800017 	ldw	r2,0(r2)
 4002fd8:	e0bffd15 	stw	r2,-12(fp)

    if( pxStreamBuffer->xHead == xTail )
 4002fdc:	e0bffe17 	ldw	r2,-8(fp)
 4002fe0:	10800117 	ldw	r2,4(r2)
 4002fe4:	e0fffd17 	ldw	r3,-12(fp)
 4002fe8:	1880031e 	bne	r3,r2,4002ff8 <xStreamBufferIsEmpty+0x40>
    {
        xReturn = pdTRUE;
 4002fec:	00800044 	movi	r2,1
 4002ff0:	e0bfff15 	stw	r2,-4(fp)
 4002ff4:	00000106 	br	4002ffc <xStreamBufferIsEmpty+0x44>
    }
    else
    {
        xReturn = pdFALSE;
 4002ff8:	e03fff15 	stw	zero,-4(fp)
    }

    return xReturn;
 4002ffc:	e0bfff17 	ldw	r2,-4(fp)
}
 4003000:	e037883a 	mov	sp,fp
 4003004:	df000017 	ldw	fp,0(sp)
 4003008:	dec00104 	addi	sp,sp,4
 400300c:	f800283a 	ret

04003010 <xStreamBufferIsFull>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
{
 4003010:	defffa04 	addi	sp,sp,-24
 4003014:	dfc00515 	stw	ra,20(sp)
 4003018:	df000415 	stw	fp,16(sp)
 400301c:	df000404 	addi	fp,sp,16
 4003020:	e13ffc15 	stw	r4,-16(fp)
    BaseType_t xReturn;
    size_t xBytesToStoreMessageLength;
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 4003024:	e0bffc17 	ldw	r2,-16(fp)
 4003028:	e0bffd15 	stw	r2,-12(fp)

    /* This generic version of the receive function is used by both message
     * buffers, which store discrete messages, and stream buffers, which store a
     * continuous stream of bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 400302c:	e0bffd17 	ldw	r2,-12(fp)
 4003030:	10800703 	ldbu	r2,28(r2)
 4003034:	10803fcc 	andi	r2,r2,255
 4003038:	1080004c 	andi	r2,r2,1
 400303c:	10000326 	beq	r2,zero,400304c <xStreamBufferIsFull+0x3c>
    {
        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
 4003040:	00800104 	movi	r2,4
 4003044:	e0bffe15 	stw	r2,-8(fp)
 4003048:	00000106 	br	4003050 <xStreamBufferIsFull+0x40>
    }
    else
    {
        xBytesToStoreMessageLength = 0;
 400304c:	e03ffe15 	stw	zero,-8(fp)
    }

    /* True if the available space equals zero. */
    if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
 4003050:	e13ffc17 	ldw	r4,-16(fp)
 4003054:	40027800 	call	4002780 <xStreamBufferSpacesAvailable>
 4003058:	1007883a 	mov	r3,r2
 400305c:	e0bffe17 	ldw	r2,-8(fp)
 4003060:	10c00336 	bltu	r2,r3,4003070 <xStreamBufferIsFull+0x60>
    {
        xReturn = pdTRUE;
 4003064:	00800044 	movi	r2,1
 4003068:	e0bfff15 	stw	r2,-4(fp)
 400306c:	00000106 	br	4003074 <xStreamBufferIsFull+0x64>
    }
    else
    {
        xReturn = pdFALSE;
 4003070:	e03fff15 	stw	zero,-4(fp)
    }

    return xReturn;
 4003074:	e0bfff17 	ldw	r2,-4(fp)
}
 4003078:	e037883a 	mov	sp,fp
 400307c:	dfc00117 	ldw	ra,4(sp)
 4003080:	df000017 	ldw	fp,0(sp)
 4003084:	dec00204 	addi	sp,sp,8
 4003088:	f800283a 	ret

0400308c <xStreamBufferSendCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer,
                                              BaseType_t * pxHigherPriorityTaskWoken )
{
 400308c:	defff704 	addi	sp,sp,-36
 4003090:	dfc00815 	stw	ra,32(sp)
 4003094:	df000715 	stw	fp,28(sp)
 4003098:	df000704 	addi	fp,sp,28
 400309c:	e13ffc15 	stw	r4,-16(fp)
 40030a0:	e17ffb15 	stw	r5,-20(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 40030a4:	e0bffc17 	ldw	r2,-16(fp)
 40030a8:	e0bffe15 	stw	r2,-8(fp)
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;

    configASSERT( pxStreamBuffer );

    uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
 40030ac:	e03ffd15 	stw	zero,-12(fp)
    {
        if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
 40030b0:	e0bffe17 	ldw	r2,-8(fp)
 40030b4:	10800417 	ldw	r2,16(r2)
 40030b8:	10000f26 	beq	r2,zero,40030f8 <xStreamBufferSendCompletedFromISR+0x6c>
        {
            ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
 40030bc:	e0bffe17 	ldw	r2,-8(fp)
 40030c0:	10c00417 	ldw	r3,16(r2)
 40030c4:	e0bffb17 	ldw	r2,-20(fp)
 40030c8:	d8800115 	stw	r2,4(sp)
 40030cc:	d8000015 	stw	zero,0(sp)
 40030d0:	000f883a 	mov	r7,zero
 40030d4:	000d883a 	mov	r6,zero
 40030d8:	000b883a 	mov	r5,zero
 40030dc:	1809883a 	mov	r4,r3
 40030e0:	400560c0 	call	400560c <xTaskGenericNotifyFromISR>
                                         ( uint32_t ) 0,
                                         eNoAction,
                                         pxHigherPriorityTaskWoken );
            ( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
 40030e4:	e0bffe17 	ldw	r2,-8(fp)
 40030e8:	10000415 	stw	zero,16(r2)
            xReturn = pdTRUE;
 40030ec:	00800044 	movi	r2,1
 40030f0:	e0bfff15 	stw	r2,-4(fp)
 40030f4:	00000106 	br	40030fc <xStreamBufferSendCompletedFromISR+0x70>
        }
        else
        {
            xReturn = pdFALSE;
 40030f8:	e03fff15 	stw	zero,-4(fp)
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
 40030fc:	e0bfff17 	ldw	r2,-4(fp)
}
 4003100:	e037883a 	mov	sp,fp
 4003104:	dfc00117 	ldw	ra,4(sp)
 4003108:	df000017 	ldw	fp,0(sp)
 400310c:	dec00204 	addi	sp,sp,8
 4003110:	f800283a 	ret

04003114 <xStreamBufferReceiveCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer,
                                                 BaseType_t * pxHigherPriorityTaskWoken )
{
 4003114:	defff704 	addi	sp,sp,-36
 4003118:	dfc00815 	stw	ra,32(sp)
 400311c:	df000715 	stw	fp,28(sp)
 4003120:	df000704 	addi	fp,sp,28
 4003124:	e13ffc15 	stw	r4,-16(fp)
 4003128:	e17ffb15 	stw	r5,-20(fp)
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 400312c:	e0bffc17 	ldw	r2,-16(fp)
 4003130:	e0bffe15 	stw	r2,-8(fp)
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;

    configASSERT( pxStreamBuffer );

    uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
 4003134:	e03ffd15 	stw	zero,-12(fp)
    {
        if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
 4003138:	e0bffe17 	ldw	r2,-8(fp)
 400313c:	10800517 	ldw	r2,20(r2)
 4003140:	10000f26 	beq	r2,zero,4003180 <xStreamBufferReceiveCompletedFromISR+0x6c>
        {
            ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
 4003144:	e0bffe17 	ldw	r2,-8(fp)
 4003148:	10c00517 	ldw	r3,20(r2)
 400314c:	e0bffb17 	ldw	r2,-20(fp)
 4003150:	d8800115 	stw	r2,4(sp)
 4003154:	d8000015 	stw	zero,0(sp)
 4003158:	000f883a 	mov	r7,zero
 400315c:	000d883a 	mov	r6,zero
 4003160:	000b883a 	mov	r5,zero
 4003164:	1809883a 	mov	r4,r3
 4003168:	400560c0 	call	400560c <xTaskGenericNotifyFromISR>
                                         ( uint32_t ) 0,
                                         eNoAction,
                                         pxHigherPriorityTaskWoken );
            ( pxStreamBuffer )->xTaskWaitingToSend = NULL;
 400316c:	e0bffe17 	ldw	r2,-8(fp)
 4003170:	10000515 	stw	zero,20(r2)
            xReturn = pdTRUE;
 4003174:	00800044 	movi	r2,1
 4003178:	e0bfff15 	stw	r2,-4(fp)
 400317c:	00000106 	br	4003184 <xStreamBufferReceiveCompletedFromISR+0x70>
        }
        else
        {
            xReturn = pdFALSE;
 4003180:	e03fff15 	stw	zero,-4(fp)
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
 4003184:	e0bfff17 	ldw	r2,-4(fp)
}
 4003188:	e037883a 	mov	sp,fp
 400318c:	dfc00117 	ldw	ra,4(sp)
 4003190:	df000017 	ldw	fp,0(sp)
 4003194:	dec00204 	addi	sp,sp,8
 4003198:	f800283a 	ret

0400319c <prvWriteBytesToBuffer>:
/*-----------------------------------------------------------*/

static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer,
                                     const uint8_t * pucData,
                                     size_t xCount )
{
 400319c:	defff904 	addi	sp,sp,-28
 40031a0:	dfc00615 	stw	ra,24(sp)
 40031a4:	df000515 	stw	fp,20(sp)
 40031a8:	df000504 	addi	fp,sp,20
 40031ac:	e13ffd15 	stw	r4,-12(fp)
 40031b0:	e17ffc15 	stw	r5,-16(fp)
 40031b4:	e1bffb15 	stw	r6,-20(fp)
    size_t xNextHead, xFirstLength;

    configASSERT( xCount > ( size_t ) 0 );

    xNextHead = pxStreamBuffer->xHead;
 40031b8:	e0bffd17 	ldw	r2,-12(fp)
 40031bc:	10800117 	ldw	r2,4(r2)
 40031c0:	e0bfff15 	stw	r2,-4(fp)

    /* Calculate the number of bytes that can be added in the first write -
     * which may be less than the total number of bytes that need to be added if
     * the buffer will wrap back to the beginning. */
    xFirstLength = configMIN( pxStreamBuffer->xLength - xNextHead, xCount );
 40031c4:	e0bffd17 	ldw	r2,-12(fp)
 40031c8:	10c00217 	ldw	r3,8(r2)
 40031cc:	e0bfff17 	ldw	r2,-4(fp)
 40031d0:	1887c83a 	sub	r3,r3,r2
 40031d4:	e0bffb17 	ldw	r2,-20(fp)
 40031d8:	1880012e 	bgeu	r3,r2,40031e0 <prvWriteBytesToBuffer+0x44>
 40031dc:	1805883a 	mov	r2,r3
 40031e0:	e0bffe15 	stw	r2,-8(fp)

    /* Write as many bytes as can be written in the first write. */
    configASSERT( ( xNextHead + xFirstLength ) <= pxStreamBuffer->xLength );
    ( void ) memcpy( ( void * ) ( &( pxStreamBuffer->pucBuffer[ xNextHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
 40031e4:	e0bffd17 	ldw	r2,-12(fp)
 40031e8:	10c00617 	ldw	r3,24(r2)
 40031ec:	e0bfff17 	ldw	r2,-4(fp)
 40031f0:	1885883a 	add	r2,r3,r2
 40031f4:	e1bffe17 	ldw	r6,-8(fp)
 40031f8:	e17ffc17 	ldw	r5,-16(fp)
 40031fc:	1009883a 	mov	r4,r2
 4003200:	40062340 	call	4006234 <memcpy>

    /* If the number of bytes written was less than the number that could be
     * written in the first write... */
    if( xCount > xFirstLength )
 4003204:	e0bffb17 	ldw	r2,-20(fp)
 4003208:	e0fffe17 	ldw	r3,-8(fp)
 400320c:	18800a2e 	bgeu	r3,r2,4003238 <prvWriteBytesToBuffer+0x9c>
    {
        /* ...then write the remaining bytes to the start of the buffer. */
        configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
        ( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
 4003210:	e0bffd17 	ldw	r2,-12(fp)
 4003214:	11000617 	ldw	r4,24(r2)
 4003218:	e0fffc17 	ldw	r3,-16(fp)
 400321c:	e0bffe17 	ldw	r2,-8(fp)
 4003220:	188b883a 	add	r5,r3,r2
 4003224:	e0fffb17 	ldw	r3,-20(fp)
 4003228:	e0bffe17 	ldw	r2,-8(fp)
 400322c:	1885c83a 	sub	r2,r3,r2
 4003230:	100d883a 	mov	r6,r2
 4003234:	40062340 	call	4006234 <memcpy>
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xNextHead += xCount;
 4003238:	e0ffff17 	ldw	r3,-4(fp)
 400323c:	e0bffb17 	ldw	r2,-20(fp)
 4003240:	1885883a 	add	r2,r3,r2
 4003244:	e0bfff15 	stw	r2,-4(fp)

    if( xNextHead >= pxStreamBuffer->xLength )
 4003248:	e0bffd17 	ldw	r2,-12(fp)
 400324c:	10800217 	ldw	r2,8(r2)
 4003250:	e0ffff17 	ldw	r3,-4(fp)
 4003254:	18800536 	bltu	r3,r2,400326c <prvWriteBytesToBuffer+0xd0>
    {
        xNextHead -= pxStreamBuffer->xLength;
 4003258:	e0bffd17 	ldw	r2,-12(fp)
 400325c:	10800217 	ldw	r2,8(r2)
 4003260:	e0ffff17 	ldw	r3,-4(fp)
 4003264:	1885c83a 	sub	r2,r3,r2
 4003268:	e0bfff15 	stw	r2,-4(fp)
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxStreamBuffer->xHead = xNextHead;
 400326c:	e0bffd17 	ldw	r2,-12(fp)
 4003270:	e0ffff17 	ldw	r3,-4(fp)
 4003274:	10c00115 	stw	r3,4(r2)

    return xCount;
 4003278:	e0bffb17 	ldw	r2,-20(fp)
}
 400327c:	e037883a 	mov	sp,fp
 4003280:	dfc00117 	ldw	ra,4(sp)
 4003284:	df000017 	ldw	fp,0(sp)
 4003288:	dec00204 	addi	sp,sp,8
 400328c:	f800283a 	ret

04003290 <prvReadBytesFromBuffer>:

static size_t prvReadBytesFromBuffer( StreamBuffer_t * pxStreamBuffer,
                                      uint8_t * pucData,
                                      size_t xMaxCount,
                                      size_t xBytesAvailable )
{
 4003290:	defff704 	addi	sp,sp,-36
 4003294:	dfc00815 	stw	ra,32(sp)
 4003298:	df000715 	stw	fp,28(sp)
 400329c:	df000704 	addi	fp,sp,28
 40032a0:	e13ffc15 	stw	r4,-16(fp)
 40032a4:	e17ffb15 	stw	r5,-20(fp)
 40032a8:	e1bffa15 	stw	r6,-24(fp)
 40032ac:	e1fff915 	stw	r7,-28(fp)
    size_t xCount, xFirstLength, xNextTail;

    /* Use the minimum of the wanted bytes and the available bytes. */
    xCount = configMIN( xBytesAvailable, xMaxCount );
 40032b0:	e0fff917 	ldw	r3,-28(fp)
 40032b4:	e0bffa17 	ldw	r2,-24(fp)
 40032b8:	1880012e 	bgeu	r3,r2,40032c0 <prvReadBytesFromBuffer+0x30>
 40032bc:	1805883a 	mov	r2,r3
 40032c0:	e0bffe15 	stw	r2,-8(fp)

    if( xCount > ( size_t ) 0 )
 40032c4:	e0bffe17 	ldw	r2,-8(fp)
 40032c8:	10003026 	beq	r2,zero,400338c <prvReadBytesFromBuffer+0xfc>
    {
        xNextTail = pxStreamBuffer->xTail;
 40032cc:	e0bffc17 	ldw	r2,-16(fp)
 40032d0:	10800017 	ldw	r2,0(r2)
 40032d4:	e0bfff15 	stw	r2,-4(fp)

        /* Calculate the number of bytes that can be read - which may be
         * less than the number wanted if the data wraps around to the start of
         * the buffer. */
        xFirstLength = configMIN( pxStreamBuffer->xLength - xNextTail, xCount );
 40032d8:	e0bffc17 	ldw	r2,-16(fp)
 40032dc:	10c00217 	ldw	r3,8(r2)
 40032e0:	e0bfff17 	ldw	r2,-4(fp)
 40032e4:	1887c83a 	sub	r3,r3,r2
 40032e8:	e0bffe17 	ldw	r2,-8(fp)
 40032ec:	1880012e 	bgeu	r3,r2,40032f4 <prvReadBytesFromBuffer+0x64>
 40032f0:	1805883a 	mov	r2,r3
 40032f4:	e0bffd15 	stw	r2,-12(fp)

        /* Obtain the number of bytes it is possible to obtain in the first
         * read.  Asserts check bounds of read and write. */
        configASSERT( xFirstLength <= xMaxCount );
        configASSERT( ( xNextTail + xFirstLength ) <= pxStreamBuffer->xLength );
        ( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xNextTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
 40032f8:	e0bffc17 	ldw	r2,-16(fp)
 40032fc:	10c00617 	ldw	r3,24(r2)
 4003300:	e0bfff17 	ldw	r2,-4(fp)
 4003304:	1885883a 	add	r2,r3,r2
 4003308:	e1bffd17 	ldw	r6,-12(fp)
 400330c:	100b883a 	mov	r5,r2
 4003310:	e13ffb17 	ldw	r4,-20(fp)
 4003314:	40062340 	call	4006234 <memcpy>

        /* If the total number of wanted bytes is greater than the number
         * that could be read in the first read... */
        if( xCount > xFirstLength )
 4003318:	e0bffe17 	ldw	r2,-8(fp)
 400331c:	e0fffd17 	ldw	r3,-12(fp)
 4003320:	18800a2e 	bgeu	r3,r2,400334c <prvReadBytesFromBuffer+0xbc>
        {
            /*...then read the remaining bytes from the start of the buffer. */
            configASSERT( xCount <= xMaxCount );
            ( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
 4003324:	e0fffb17 	ldw	r3,-20(fp)
 4003328:	e0bffd17 	ldw	r2,-12(fp)
 400332c:	1889883a 	add	r4,r3,r2
 4003330:	e0bffc17 	ldw	r2,-16(fp)
 4003334:	11400617 	ldw	r5,24(r2)
 4003338:	e0fffe17 	ldw	r3,-8(fp)
 400333c:	e0bffd17 	ldw	r2,-12(fp)
 4003340:	1885c83a 	sub	r2,r3,r2
 4003344:	100d883a 	mov	r6,r2
 4003348:	40062340 	call	4006234 <memcpy>
            mtCOVERAGE_TEST_MARKER();
        }

        /* Move the tail pointer to effectively remove the data read from
         * the buffer. */
        xNextTail += xCount;
 400334c:	e0ffff17 	ldw	r3,-4(fp)
 4003350:	e0bffe17 	ldw	r2,-8(fp)
 4003354:	1885883a 	add	r2,r3,r2
 4003358:	e0bfff15 	stw	r2,-4(fp)

        if( xNextTail >= pxStreamBuffer->xLength )
 400335c:	e0bffc17 	ldw	r2,-16(fp)
 4003360:	10800217 	ldw	r2,8(r2)
 4003364:	e0ffff17 	ldw	r3,-4(fp)
 4003368:	18800536 	bltu	r3,r2,4003380 <prvReadBytesFromBuffer+0xf0>
        {
            xNextTail -= pxStreamBuffer->xLength;
 400336c:	e0bffc17 	ldw	r2,-16(fp)
 4003370:	10800217 	ldw	r2,8(r2)
 4003374:	e0ffff17 	ldw	r3,-4(fp)
 4003378:	1885c83a 	sub	r2,r3,r2
 400337c:	e0bfff15 	stw	r2,-4(fp)
        }

        pxStreamBuffer->xTail = xNextTail;
 4003380:	e0bffc17 	ldw	r2,-16(fp)
 4003384:	e0ffff17 	ldw	r3,-4(fp)
 4003388:	10c00015 	stw	r3,0(r2)
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xCount;
 400338c:	e0bffe17 	ldw	r2,-8(fp)
}
 4003390:	e037883a 	mov	sp,fp
 4003394:	dfc00117 	ldw	ra,4(sp)
 4003398:	df000017 	ldw	fp,0(sp)
 400339c:	dec00204 	addi	sp,sp,8
 40033a0:	f800283a 	ret

040033a4 <prvBytesInBuffer>:
/*-----------------------------------------------------------*/

static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
 40033a4:	defffd04 	addi	sp,sp,-12
 40033a8:	df000215 	stw	fp,8(sp)
 40033ac:	df000204 	addi	fp,sp,8
 40033b0:	e13ffe15 	stw	r4,-8(fp)
/* Returns the distance between xTail and xHead. */
    size_t xCount;

    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
 40033b4:	e0bffe17 	ldw	r2,-8(fp)
 40033b8:	10c00217 	ldw	r3,8(r2)
 40033bc:	e0bffe17 	ldw	r2,-8(fp)
 40033c0:	10800117 	ldw	r2,4(r2)
 40033c4:	1885883a 	add	r2,r3,r2
 40033c8:	e0bfff15 	stw	r2,-4(fp)
    xCount -= pxStreamBuffer->xTail;
 40033cc:	e0bffe17 	ldw	r2,-8(fp)
 40033d0:	10800017 	ldw	r2,0(r2)
 40033d4:	e0ffff17 	ldw	r3,-4(fp)
 40033d8:	1885c83a 	sub	r2,r3,r2
 40033dc:	e0bfff15 	stw	r2,-4(fp)

    if( xCount >= pxStreamBuffer->xLength )
 40033e0:	e0bffe17 	ldw	r2,-8(fp)
 40033e4:	10800217 	ldw	r2,8(r2)
 40033e8:	e0ffff17 	ldw	r3,-4(fp)
 40033ec:	18800536 	bltu	r3,r2,4003404 <prvBytesInBuffer+0x60>
    {
        xCount -= pxStreamBuffer->xLength;
 40033f0:	e0bffe17 	ldw	r2,-8(fp)
 40033f4:	10800217 	ldw	r2,8(r2)
 40033f8:	e0ffff17 	ldw	r3,-4(fp)
 40033fc:	1885c83a 	sub	r2,r3,r2
 4003400:	e0bfff15 	stw	r2,-4(fp)
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xCount;
 4003404:	e0bfff17 	ldw	r2,-4(fp)
}
 4003408:	e037883a 	mov	sp,fp
 400340c:	df000017 	ldw	fp,0(sp)
 4003410:	dec00104 	addi	sp,sp,4
 4003414:	f800283a 	ret

04003418 <prvInitialiseNewStreamBuffer>:
static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
                                          uint8_t * const pucBuffer,
                                          size_t xBufferSizeBytes,
                                          size_t xTriggerLevelBytes,
                                          uint8_t ucFlags )
{
 4003418:	defff904 	addi	sp,sp,-28
 400341c:	dfc00615 	stw	ra,24(sp)
 4003420:	df000515 	stw	fp,20(sp)
 4003424:	df000504 	addi	fp,sp,20
 4003428:	e13fff15 	stw	r4,-4(fp)
 400342c:	e17ffe15 	stw	r5,-8(fp)
 4003430:	e1bffd15 	stw	r6,-12(fp)
 4003434:	e1fffc15 	stw	r7,-16(fp)
 4003438:	e0800217 	ldw	r2,8(fp)
 400343c:	e0bffb05 	stb	r2,-20(fp)
            const BaseType_t xWriteValue = 0x55;
            configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
        } /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
    #endif

    ( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
 4003440:	01800804 	movi	r6,32
 4003444:	000b883a 	mov	r5,zero
 4003448:	e13fff17 	ldw	r4,-4(fp)
 400344c:	40063340 	call	4006334 <memset>
    pxStreamBuffer->pucBuffer = pucBuffer;
 4003450:	e0bfff17 	ldw	r2,-4(fp)
 4003454:	e0fffe17 	ldw	r3,-8(fp)
 4003458:	10c00615 	stw	r3,24(r2)
    pxStreamBuffer->xLength = xBufferSizeBytes;
 400345c:	e0bfff17 	ldw	r2,-4(fp)
 4003460:	e0fffd17 	ldw	r3,-12(fp)
 4003464:	10c00215 	stw	r3,8(r2)
    pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
 4003468:	e0bfff17 	ldw	r2,-4(fp)
 400346c:	e0fffc17 	ldw	r3,-16(fp)
 4003470:	10c00315 	stw	r3,12(r2)
    pxStreamBuffer->ucFlags = ucFlags;
 4003474:	e0bfff17 	ldw	r2,-4(fp)
 4003478:	e0fffb03 	ldbu	r3,-20(fp)
 400347c:	10c00705 	stb	r3,28(r2)
}
 4003480:	0001883a 	nop
 4003484:	e037883a 	mov	sp,fp
 4003488:	dfc00117 	ldw	ra,4(sp)
 400348c:	df000017 	ldw	fp,0(sp)
 4003490:	dec00204 	addi	sp,sp,8
 4003494:	f800283a 	ret

04003498 <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
 4003498:	defff304 	addi	sp,sp,-52
 400349c:	dfc00c15 	stw	ra,48(sp)
 40034a0:	df000b15 	stw	fp,44(sp)
 40034a4:	df000b04 	addi	fp,sp,44
 40034a8:	e13ffc15 	stw	r4,-16(fp)
 40034ac:	e17ffb15 	stw	r5,-20(fp)
 40034b0:	3005883a 	mov	r2,r6
 40034b4:	e1fff915 	stw	r7,-28(fp)
 40034b8:	e0bffa0d 	sth	r2,-24(fp)
        #else /* portSTACK_GROWTH */
            {
                StackType_t * pxStack;

                /* Allocate space for the stack used by the task being created. */
                pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 40034bc:	e0bffa0b 	ldhu	r2,-24(fp)
 40034c0:	100490ba 	slli	r2,r2,2
 40034c4:	1009883a 	mov	r4,r2
 40034c8:	40006340 	call	4000634 <pvPortMalloc>
 40034cc:	e0bffd15 	stw	r2,-12(fp)

                if( pxStack != NULL )
 40034d0:	e0bffd17 	ldw	r2,-12(fp)
 40034d4:	10000c26 	beq	r2,zero,4003508 <xTaskCreate+0x70>
                {
                    /* Allocate space for the TCB. */
                    pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
 40034d8:	01001404 	movi	r4,80
 40034dc:	40006340 	call	4000634 <pvPortMalloc>
 40034e0:	e0bfff15 	stw	r2,-4(fp)

                    if( pxNewTCB != NULL )
 40034e4:	e0bfff17 	ldw	r2,-4(fp)
 40034e8:	10000426 	beq	r2,zero,40034fc <xTaskCreate+0x64>
                    {
                        /* Store the stack location in the TCB. */
                        pxNewTCB->pxStack = pxStack;
 40034ec:	e0bfff17 	ldw	r2,-4(fp)
 40034f0:	e0fffd17 	ldw	r3,-12(fp)
 40034f4:	10c00c15 	stw	r3,48(r2)
 40034f8:	00000406 	br	400350c <xTaskCreate+0x74>
                    }
                    else
                    {
                        /* The stack cannot be used as the TCB was not created.  Free
                         * it again. */
                        vPortFree( pxStack );
 40034fc:	e13ffd17 	ldw	r4,-12(fp)
 4003500:	40006f40 	call	40006f4 <vPortFree>
 4003504:	00000106 	br	400350c <xTaskCreate+0x74>
                    }
                }
                else
                {
                    pxNewTCB = NULL;
 4003508:	e03fff15 	stw	zero,-4(fp)
                }
            }
        #endif /* portSTACK_GROWTH */

        if( pxNewTCB != NULL )
 400350c:	e0bfff17 	ldw	r2,-4(fp)
 4003510:	10001226 	beq	r2,zero,400355c <xTaskCreate+0xc4>
                     * task was created dynamically in case it is later deleted. */
                    pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
                }
            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

            prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 4003514:	e0fffa0b 	ldhu	r3,-24(fp)
 4003518:	d8000315 	stw	zero,12(sp)
 400351c:	e0bfff17 	ldw	r2,-4(fp)
 4003520:	d8800215 	stw	r2,8(sp)
 4003524:	e0800317 	ldw	r2,12(fp)
 4003528:	d8800115 	stw	r2,4(sp)
 400352c:	e0800217 	ldw	r2,8(fp)
 4003530:	d8800015 	stw	r2,0(sp)
 4003534:	e1fff917 	ldw	r7,-28(fp)
 4003538:	180d883a 	mov	r6,r3
 400353c:	e17ffb17 	ldw	r5,-20(fp)
 4003540:	e13ffc17 	ldw	r4,-16(fp)
 4003544:	400357c0 	call	400357c <prvInitialiseNewTask>
            prvAddNewTaskToReadyList( pxNewTCB );
 4003548:	e13fff17 	ldw	r4,-4(fp)
 400354c:	40037740 	call	4003774 <prvAddNewTaskToReadyList>
            xReturn = pdPASS;
 4003550:	00800044 	movi	r2,1
 4003554:	e0bffe15 	stw	r2,-8(fp)
 4003558:	00000206 	br	4003564 <xTaskCreate+0xcc>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 400355c:	00bfffc4 	movi	r2,-1
 4003560:	e0bffe15 	stw	r2,-8(fp)
        }

        return xReturn;
 4003564:	e0bffe17 	ldw	r2,-8(fp)
    }
 4003568:	e037883a 	mov	sp,fp
 400356c:	dfc00117 	ldw	ra,4(sp)
 4003570:	df000017 	ldw	fp,0(sp)
 4003574:	dec00204 	addi	sp,sp,8
 4003578:	f800283a 	ret

0400357c <prvInitialiseNewTask>:
                                  void * const pvParameters,
                                  UBaseType_t uxPriority,
                                  TaskHandle_t * const pxCreatedTask,
                                  TCB_t * pxNewTCB,
                                  const MemoryRegion_t * const xRegions )
{
 400357c:	defff804 	addi	sp,sp,-32
 4003580:	dfc00715 	stw	ra,28(sp)
 4003584:	df000615 	stw	fp,24(sp)
 4003588:	df000604 	addi	fp,sp,24
 400358c:	e13ffd15 	stw	r4,-12(fp)
 4003590:	e17ffc15 	stw	r5,-16(fp)
 4003594:	e1bffb15 	stw	r6,-20(fp)
 4003598:	e1fffa15 	stw	r7,-24(fp)

    /* Avoid dependency on memset() if it is not required. */
    #if ( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
        {
            /* Fill the stack with a known value to assist debugging. */
            ( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 400359c:	e0800417 	ldw	r2,16(fp)
 40035a0:	10c00c17 	ldw	r3,48(r2)
 40035a4:	e0bffb17 	ldw	r2,-20(fp)
 40035a8:	100490ba 	slli	r2,r2,2
 40035ac:	100d883a 	mov	r6,r2
 40035b0:	01402944 	movi	r5,165
 40035b4:	1809883a 	mov	r4,r3
 40035b8:	40063340 	call	4006334 <memset>
     * grows from high memory to low (as per the 80x86) or vice versa.
     * portSTACK_GROWTH is used to make the result positive or negative as required
     * by the port. */
    #if ( portSTACK_GROWTH < 0 )
        {
            pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 40035bc:	e0800417 	ldw	r2,16(fp)
 40035c0:	10c00c17 	ldw	r3,48(r2)
 40035c4:	e13ffb17 	ldw	r4,-20(fp)
 40035c8:	00900034 	movhi	r2,16384
 40035cc:	10bfffc4 	addi	r2,r2,-1
 40035d0:	2085883a 	add	r2,r4,r2
 40035d4:	100490ba 	slli	r2,r2,2
 40035d8:	1885883a 	add	r2,r3,r2
 40035dc:	e0bffe15 	stw	r2,-8(fp)
            pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
 40035e0:	e0fffe17 	ldw	r3,-8(fp)
 40035e4:	00bfff04 	movi	r2,-4
 40035e8:	1884703a 	and	r2,r3,r2
 40035ec:	e0bffe15 	stw	r2,-8(fp)
            pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
        }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
 40035f0:	e0bffc17 	ldw	r2,-16(fp)
 40035f4:	10001d26 	beq	r2,zero,400366c <prvInitialiseNewTask+0xf0>
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 40035f8:	e03fff15 	stw	zero,-4(fp)
 40035fc:	00001306 	br	400364c <prvInitialiseNewTask+0xd0>
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 4003600:	e0fffc17 	ldw	r3,-16(fp)
 4003604:	e0bfff17 	ldw	r2,-4(fp)
 4003608:	1885883a 	add	r2,r3,r2
 400360c:	10c00003 	ldbu	r3,0(r2)
 4003610:	e1000417 	ldw	r4,16(fp)
 4003614:	e0bfff17 	ldw	r2,-4(fp)
 4003618:	2085883a 	add	r2,r4,r2
 400361c:	10c00d05 	stb	r3,52(r2)

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
 4003620:	e0fffc17 	ldw	r3,-16(fp)
 4003624:	e0bfff17 	ldw	r2,-4(fp)
 4003628:	1885883a 	add	r2,r3,r2
 400362c:	10800003 	ldbu	r2,0(r2)
 4003630:	10803fcc 	andi	r2,r2,255
 4003634:	1080201c 	xori	r2,r2,128
 4003638:	10bfe004 	addi	r2,r2,-128
 400363c:	10000726 	beq	r2,zero,400365c <prvInitialiseNewTask+0xe0>
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 4003640:	e0bfff17 	ldw	r2,-4(fp)
 4003644:	10800044 	addi	r2,r2,1
 4003648:	e0bfff15 	stw	r2,-4(fp)
 400364c:	e0bfff17 	ldw	r2,-4(fp)
 4003650:	10800230 	cmpltui	r2,r2,8
 4003654:	103fea1e 	bne	r2,zero,4003600 <prvInitialiseNewTask+0x84>
 4003658:	00000106 	br	4003660 <prvInitialiseNewTask+0xe4>
            {
                break;
 400365c:	0001883a 	nop
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 4003660:	e0800417 	ldw	r2,16(fp)
 4003664:	10000ec5 	stb	zero,59(r2)
 4003668:	00000206 	br	4003674 <prvInitialiseNewTask+0xf8>
    }
    else
    {
        /* The task has not been given a name, so just ensure there is a NULL
         * terminator when it is read out. */
        pxNewTCB->pcTaskName[ 0 ] = 0x00;
 400366c:	e0800417 	ldw	r2,16(fp)
 4003670:	10000d05 	stb	zero,52(r2)
    }

    /* This is used as an array index so must ensure it's not too large.  First
     * remove the privilege bit if one is present. */
    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 4003674:	e0800217 	ldw	r2,8(fp)
 4003678:	10800170 	cmpltui	r2,r2,5
 400367c:	1000021e 	bne	r2,zero,4003688 <prvInitialiseNewTask+0x10c>
    {
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 4003680:	00800104 	movi	r2,4
 4003684:	e0800215 	stw	r2,8(fp)
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
 4003688:	e0800417 	ldw	r2,16(fp)
 400368c:	e0c00217 	ldw	r3,8(fp)
 4003690:	10c00b15 	stw	r3,44(r2)
    #if ( configUSE_MUTEXES == 1 )
        {
            pxNewTCB->uxBasePriority = uxPriority;
 4003694:	e0800417 	ldw	r2,16(fp)
 4003698:	e0c00217 	ldw	r3,8(fp)
 400369c:	10c01015 	stw	r3,64(r2)
            pxNewTCB->uxMutexesHeld = 0;
 40036a0:	e0800417 	ldw	r2,16(fp)
 40036a4:	10001115 	stw	zero,68(r2)
        }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 40036a8:	e0800417 	ldw	r2,16(fp)
 40036ac:	10800104 	addi	r2,r2,4
 40036b0:	1009883a 	mov	r4,r2
 40036b4:	4000ed00 	call	4000ed0 <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 40036b8:	e0800417 	ldw	r2,16(fp)
 40036bc:	10800604 	addi	r2,r2,24
 40036c0:	1009883a 	mov	r4,r2
 40036c4:	4000ed00 	call	4000ed0 <vListInitialiseItem>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 40036c8:	e0800417 	ldw	r2,16(fp)
 40036cc:	e0c00417 	ldw	r3,16(fp)
 40036d0:	10c00415 	stw	r3,16(r2)

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 40036d4:	00c00144 	movi	r3,5
 40036d8:	e0800217 	ldw	r2,8(fp)
 40036dc:	1887c83a 	sub	r3,r3,r2
 40036e0:	e0800417 	ldw	r2,16(fp)
 40036e4:	10c00615 	stw	r3,24(r2)
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 40036e8:	e0800417 	ldw	r2,16(fp)
 40036ec:	e0c00417 	ldw	r3,16(fp)
 40036f0:	10c00915 	stw	r3,36(r2)

    #if ( portCRITICAL_NESTING_IN_TCB == 1 )
        {
            pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
 40036f4:	e0800417 	ldw	r2,16(fp)
 40036f8:	10000f15 	stw	zero,60(r2)
        }
    #endif

    #if ( configUSE_TASK_NOTIFICATIONS == 1 )
        {
            memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
 40036fc:	e0800417 	ldw	r2,16(fp)
 4003700:	10801204 	addi	r2,r2,72
 4003704:	01800104 	movi	r6,4
 4003708:	000b883a 	mov	r5,zero
 400370c:	1009883a 	mov	r4,r2
 4003710:	40063340 	call	4006334 <memset>
            memset( ( void * ) &( pxNewTCB->ucNotifyState[ 0 ] ), 0x00, sizeof( pxNewTCB->ucNotifyState ) );
 4003714:	e0800417 	ldw	r2,16(fp)
 4003718:	10801304 	addi	r2,r2,76
 400371c:	01800044 	movi	r6,1
 4003720:	000b883a 	mov	r5,zero
 4003724:	1009883a 	mov	r4,r2
 4003728:	40063340 	call	4006334 <memset>
                        }
                    #endif /* portSTACK_GROWTH */
                }
            #else /* portHAS_STACK_OVERFLOW_CHECKING */
                {
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 400372c:	e1bffa17 	ldw	r6,-24(fp)
 4003730:	e17ffd17 	ldw	r5,-12(fp)
 4003734:	e13ffe17 	ldw	r4,-8(fp)
 4003738:	40002c00 	call	40002c0 <pxPortInitialiseStack>
 400373c:	1007883a 	mov	r3,r2
 4003740:	e0800417 	ldw	r2,16(fp)
 4003744:	10c00015 	stw	r3,0(r2)
                }
            #endif /* portHAS_STACK_OVERFLOW_CHECKING */
        }
    #endif /* portUSING_MPU_WRAPPERS */

    if( pxCreatedTask != NULL )
 4003748:	e0800317 	ldw	r2,12(fp)
 400374c:	10000326 	beq	r2,zero,400375c <prvInitialiseNewTask+0x1e0>
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 4003750:	e0800317 	ldw	r2,12(fp)
 4003754:	e0c00417 	ldw	r3,16(fp)
 4003758:	10c00015 	stw	r3,0(r2)
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
 400375c:	0001883a 	nop
 4003760:	e037883a 	mov	sp,fp
 4003764:	dfc00117 	ldw	ra,4(sp)
 4003768:	df000017 	ldw	fp,0(sp)
 400376c:	dec00204 	addi	sp,sp,8
 4003770:	f800283a 	ret

04003774 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
 4003774:	defffd04 	addi	sp,sp,-12
 4003778:	dfc00215 	stw	ra,8(sp)
 400377c:	df000115 	stw	fp,4(sp)
 4003780:	df000104 	addi	fp,sp,4
 4003784:	e13fff15 	stw	r4,-4(fp)
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
 4003788:	40050480 	call	4005048 <vTaskEnterCritical>
    {
        uxCurrentNumberOfTasks++;
 400378c:	d0a5a917 	ldw	r2,-26972(gp)
 4003790:	10800044 	addi	r2,r2,1
 4003794:	d0a5a915 	stw	r2,-26972(gp)

        if( pxCurrentTCB == NULL )
 4003798:	d0a5a517 	ldw	r2,-26988(gp)
 400379c:	1000071e 	bne	r2,zero,40037bc <prvAddNewTaskToReadyList+0x48>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
 40037a0:	e0bfff17 	ldw	r2,-4(fp)
 40037a4:	d0a5a515 	stw	r2,-26988(gp)

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 40037a8:	d0a5a917 	ldw	r2,-26972(gp)
 40037ac:	10800058 	cmpnei	r2,r2,1
 40037b0:	10000b1e 	bne	r2,zero,40037e0 <prvAddNewTaskToReadyList+0x6c>
            {
                /* This is the first task to be created so do the preliminary
                 * initialisation required.  We will not recover if this call
                 * fails, but we will report the failure. */
                prvInitialiseTaskLists();
 40037b4:	4004a1c0 	call	4004a1c <prvInitialiseTaskLists>
 40037b8:	00000906 	br	40037e0 <prvAddNewTaskToReadyList+0x6c>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
 40037bc:	d0a5ac17 	ldw	r2,-26960(gp)
 40037c0:	1000071e 	bne	r2,zero,40037e0 <prvAddNewTaskToReadyList+0x6c>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 40037c4:	d0a5a517 	ldw	r2,-26988(gp)
 40037c8:	10800b17 	ldw	r2,44(r2)
 40037cc:	e0ffff17 	ldw	r3,-4(fp)
 40037d0:	18c00b17 	ldw	r3,44(r3)
 40037d4:	18800236 	bltu	r3,r2,40037e0 <prvAddNewTaskToReadyList+0x6c>
                {
                    pxCurrentTCB = pxNewTCB;
 40037d8:	e0bfff17 	ldw	r2,-4(fp)
 40037dc:	d0a5a515 	stw	r2,-26988(gp)
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
 40037e0:	d0a5b017 	ldw	r2,-26944(gp)
 40037e4:	10800044 	addi	r2,r2,1
 40037e8:	d0a5b015 	stw	r2,-26944(gp)
                pxNewTCB->uxTCBNumber = uxTaskNumber;
            }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
 40037ec:	e0bfff17 	ldw	r2,-4(fp)
 40037f0:	10800b17 	ldw	r2,44(r2)
 40037f4:	d0e5ab17 	ldw	r3,-26964(gp)
 40037f8:	1880032e 	bgeu	r3,r2,4003808 <prvAddNewTaskToReadyList+0x94>
 40037fc:	e0bfff17 	ldw	r2,-4(fp)
 4003800:	10800b17 	ldw	r2,44(r2)
 4003804:	d0a5ab15 	stw	r2,-26964(gp)
 4003808:	e0bfff17 	ldw	r2,-4(fp)
 400380c:	10800b17 	ldw	r2,44(r2)
 4003810:	10c00524 	muli	r3,r2,20
 4003814:	00812074 	movhi	r2,1153
 4003818:	10abdc04 	addi	r2,r2,-20624
 400381c:	1887883a 	add	r3,r3,r2
 4003820:	e0bfff17 	ldw	r2,-4(fp)
 4003824:	10800104 	addi	r2,r2,4
 4003828:	100b883a 	mov	r5,r2
 400382c:	1809883a 	mov	r4,r3
 4003830:	4000efc0 	call	4000efc <vListInsertEnd>

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
 4003834:	400509c0 	call	400509c <vTaskExitCritical>

    if( xSchedulerRunning != pdFALSE )
 4003838:	d0a5ac17 	ldw	r2,-26960(gp)
 400383c:	10000626 	beq	r2,zero,4003858 <prvAddNewTaskToReadyList+0xe4>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 4003840:	d0a5a517 	ldw	r2,-26988(gp)
 4003844:	10c00b17 	ldw	r3,44(r2)
 4003848:	e0bfff17 	ldw	r2,-4(fp)
 400384c:	10800b17 	ldw	r2,44(r2)
 4003850:	1880012e 	bgeu	r3,r2,4003858 <prvAddNewTaskToReadyList+0xe4>
        {
            taskYIELD_IF_USING_PREEMPTION();
 4003854:	003b683a 	trap	0
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
 4003858:	0001883a 	nop
 400385c:	e037883a 	mov	sp,fp
 4003860:	dfc00117 	ldw	ra,4(sp)
 4003864:	df000017 	ldw	fp,0(sp)
 4003868:	dec00204 	addi	sp,sp,8
 400386c:	f800283a 	ret

04003870 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    void vTaskDelete( TaskHandle_t xTaskToDelete )
    {
 4003870:	defffc04 	addi	sp,sp,-16
 4003874:	dfc00315 	stw	ra,12(sp)
 4003878:	df000215 	stw	fp,8(sp)
 400387c:	df000204 	addi	fp,sp,8
 4003880:	e13ffe15 	stw	r4,-8(fp)
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
 4003884:	40050480 	call	4005048 <vTaskEnterCritical>
        {
            /* If null is passed in here then it is the calling task that is
             * being deleted. */
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 4003888:	e0bffe17 	ldw	r2,-8(fp)
 400388c:	1000021e 	bne	r2,zero,4003898 <vTaskDelete+0x28>
 4003890:	d0a5a517 	ldw	r2,-26988(gp)
 4003894:	00000106 	br	400389c <vTaskDelete+0x2c>
 4003898:	e0bffe17 	ldw	r2,-8(fp)
 400389c:	e0bfff15 	stw	r2,-4(fp)

            /* Remove task from the ready/delayed list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 40038a0:	e0bfff17 	ldw	r2,-4(fp)
 40038a4:	10800104 	addi	r2,r2,4
 40038a8:	1009883a 	mov	r4,r2
 40038ac:	40010600 	call	4001060 <uxListRemove>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 40038b0:	e0bfff17 	ldw	r2,-4(fp)
 40038b4:	10800a17 	ldw	r2,40(r2)
 40038b8:	10000426 	beq	r2,zero,40038cc <vTaskDelete+0x5c>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 40038bc:	e0bfff17 	ldw	r2,-4(fp)
 40038c0:	10800604 	addi	r2,r2,24
 40038c4:	1009883a 	mov	r4,r2
 40038c8:	40010600 	call	4001060 <uxListRemove>

            /* Increment the uxTaskNumber also so kernel aware debuggers can
             * detect that the task lists need re-generating.  This is done before
             * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
             * not return. */
            uxTaskNumber++;
 40038cc:	d0a5b017 	ldw	r2,-26944(gp)
 40038d0:	10800044 	addi	r2,r2,1
 40038d4:	d0a5b015 	stw	r2,-26944(gp)

            if( pxTCB == pxCurrentTCB )
 40038d8:	d0a5a517 	ldw	r2,-26988(gp)
 40038dc:	e0ffff17 	ldw	r3,-4(fp)
 40038e0:	18800a1e 	bne	r3,r2,400390c <vTaskDelete+0x9c>
                /* A task is deleting itself.  This cannot complete within the
                 * task itself, as a context switch to another task is required.
                 * Place the task in the termination list.  The idle task will
                 * check the termination list and free up any memory allocated by
                 * the scheduler for the TCB and stack of the deleted task. */
                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
 40038e4:	e0bfff17 	ldw	r2,-4(fp)
 40038e8:	10800104 	addi	r2,r2,4
 40038ec:	100b883a 	mov	r5,r2
 40038f0:	01012074 	movhi	r4,1153
 40038f4:	212c0404 	addi	r4,r4,-20464
 40038f8:	4000efc0 	call	4000efc <vListInsertEnd>

                /* Increment the ucTasksDeleted variable so the idle task knows
                 * there is a task that has been deleted and that it should therefore
                 * check the xTasksWaitingTermination list. */
                ++uxDeletedTasksWaitingCleanUp;
 40038fc:	d0a5a817 	ldw	r2,-26976(gp)
 4003900:	10800044 	addi	r2,r2,1
 4003904:	d0a5a815 	stw	r2,-26976(gp)
 4003908:	00000606 	br	4003924 <vTaskDelete+0xb4>
                 * required. */
                portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
            }
            else
            {
                --uxCurrentNumberOfTasks;
 400390c:	d0a5a917 	ldw	r2,-26972(gp)
 4003910:	10bfffc4 	addi	r2,r2,-1
 4003914:	d0a5a915 	stw	r2,-26972(gp)
                traceTASK_DELETE( pxTCB );
                prvDeleteTCB( pxTCB );
 4003918:	e13fff17 	ldw	r4,-4(fp)
 400391c:	4004c180 	call	4004c18 <prvDeleteTCB>

                /* Reset the next expected unblock time in case it referred to
                 * the task that has just been deleted. */
                prvResetNextTaskUnblockTime();
 4003920:	4004c5c0 	call	4004c5c <prvResetNextTaskUnblockTime>
            }
        }
        taskEXIT_CRITICAL();
 4003924:	400509c0 	call	400509c <vTaskExitCritical>

        /* Force a reschedule if it is the currently running task that has just
         * been deleted. */
        if( xSchedulerRunning != pdFALSE )
 4003928:	d0a5ac17 	ldw	r2,-26960(gp)
 400392c:	10000426 	beq	r2,zero,4003940 <vTaskDelete+0xd0>
        {
            if( pxTCB == pxCurrentTCB )
 4003930:	d0a5a517 	ldw	r2,-26988(gp)
 4003934:	e0ffff17 	ldw	r3,-4(fp)
 4003938:	1880011e 	bne	r3,r2,4003940 <vTaskDelete+0xd0>
            {
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
 400393c:	003b683a 	trap	0
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
 4003940:	0001883a 	nop
 4003944:	e037883a 	mov	sp,fp
 4003948:	dfc00117 	ldw	ra,4(sp)
 400394c:	df000017 	ldw	fp,0(sp)
 4003950:	dec00204 	addi	sp,sp,8
 4003954:	f800283a 	ret

04003958 <vTaskDelayUntil>:

#if ( INCLUDE_vTaskDelayUntil == 1 )

    void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
                          const TickType_t xTimeIncrement )
    {
 4003958:	defff804 	addi	sp,sp,-32
 400395c:	dfc00715 	stw	ra,28(sp)
 4003960:	df000615 	stw	fp,24(sp)
 4003964:	df000604 	addi	fp,sp,24
 4003968:	e13ffb15 	stw	r4,-20(fp)
 400396c:	e17ffa15 	stw	r5,-24(fp)
        TickType_t xTimeToWake;
        BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
 4003970:	e03fff15 	stw	zero,-4(fp)

        configASSERT( pxPreviousWakeTime );
        configASSERT( ( xTimeIncrement > 0U ) );
        configASSERT( uxSchedulerSuspended == 0 );

        vTaskSuspendAll();
 4003974:	40041000 	call	4004100 <vTaskSuspendAll>
        {
            /* Minor optimisation.  The tick count cannot change in this
             * block. */
            const TickType_t xConstTickCount = xTickCount;
 4003978:	d0a5aa17 	ldw	r2,-26968(gp)
 400397c:	e0bffe15 	stw	r2,-8(fp)

            /* Generate the tick time at which the task wants to wake. */
            xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 4003980:	e0bffb17 	ldw	r2,-20(fp)
 4003984:	10800017 	ldw	r2,0(r2)
 4003988:	e0fffa17 	ldw	r3,-24(fp)
 400398c:	1885883a 	add	r2,r3,r2
 4003990:	e0bffd15 	stw	r2,-12(fp)

            if( xConstTickCount < *pxPreviousWakeTime )
 4003994:	e0bffb17 	ldw	r2,-20(fp)
 4003998:	10800017 	ldw	r2,0(r2)
 400399c:	e0fffe17 	ldw	r3,-8(fp)
 40039a0:	18800a2e 	bgeu	r3,r2,40039cc <vTaskDelayUntil+0x74>
                /* The tick count has overflowed since this function was
                 * lasted called.  In this case the only time we should ever
                 * actually delay is if the wake time has also  overflowed,
                 * and the wake time is greater than the tick time.  When this
                 * is the case it is as if neither time had overflowed. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 40039a4:	e0bffb17 	ldw	r2,-20(fp)
 40039a8:	10800017 	ldw	r2,0(r2)
 40039ac:	e0fffd17 	ldw	r3,-12(fp)
 40039b0:	18800f2e 	bgeu	r3,r2,40039f0 <vTaskDelayUntil+0x98>
 40039b4:	e0bffd17 	ldw	r2,-12(fp)
 40039b8:	e0fffe17 	ldw	r3,-8(fp)
 40039bc:	18800c2e 	bgeu	r3,r2,40039f0 <vTaskDelayUntil+0x98>
                {
                    xShouldDelay = pdTRUE;
 40039c0:	00800044 	movi	r2,1
 40039c4:	e0bfff15 	stw	r2,-4(fp)
 40039c8:	00000906 	br	40039f0 <vTaskDelayUntil+0x98>
            else
            {
                /* The tick time has not overflowed.  In this case we will
                 * delay if either the wake time has overflowed, and/or the
                 * tick time is less than the wake time. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 40039cc:	e0bffb17 	ldw	r2,-20(fp)
 40039d0:	10800017 	ldw	r2,0(r2)
 40039d4:	e0fffd17 	ldw	r3,-12(fp)
 40039d8:	18800336 	bltu	r3,r2,40039e8 <vTaskDelayUntil+0x90>
 40039dc:	e0bffd17 	ldw	r2,-12(fp)
 40039e0:	e0fffe17 	ldw	r3,-8(fp)
 40039e4:	1880022e 	bgeu	r3,r2,40039f0 <vTaskDelayUntil+0x98>
                {
                    xShouldDelay = pdTRUE;
 40039e8:	00800044 	movi	r2,1
 40039ec:	e0bfff15 	stw	r2,-4(fp)
                    mtCOVERAGE_TEST_MARKER();
                }
            }

            /* Update the wake time ready for the next call. */
            *pxPreviousWakeTime = xTimeToWake;
 40039f0:	e0bffb17 	ldw	r2,-20(fp)
 40039f4:	e0fffd17 	ldw	r3,-12(fp)
 40039f8:	10c00015 	stw	r3,0(r2)

            if( xShouldDelay != pdFALSE )
 40039fc:	e0bfff17 	ldw	r2,-4(fp)
 4003a00:	10000626 	beq	r2,zero,4003a1c <vTaskDelayUntil+0xc4>
            {
                traceTASK_DELAY_UNTIL( xTimeToWake );

                /* prvAddCurrentTaskToDelayedList() needs the block time, not
                 * the time to wake, so subtract the current tick count. */
                prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
 4003a04:	e0fffd17 	ldw	r3,-12(fp)
 4003a08:	e0bffe17 	ldw	r2,-8(fp)
 4003a0c:	1885c83a 	sub	r2,r3,r2
 4003a10:	000b883a 	mov	r5,zero
 4003a14:	1009883a 	mov	r4,r2
 4003a18:	4005af80 	call	4005af8 <prvAddCurrentTaskToDelayedList>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        xAlreadyYielded = xTaskResumeAll();
 4003a1c:	400412c0 	call	400412c <xTaskResumeAll>
 4003a20:	e0bffc15 	stw	r2,-16(fp)

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
 4003a24:	e0bffc17 	ldw	r2,-16(fp)
 4003a28:	1000011e 	bne	r2,zero,4003a30 <vTaskDelayUntil+0xd8>
        {
            portYIELD_WITHIN_API();
 4003a2c:	003b683a 	trap	0
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
 4003a30:	0001883a 	nop
 4003a34:	e037883a 	mov	sp,fp
 4003a38:	dfc00117 	ldw	ra,4(sp)
 4003a3c:	df000017 	ldw	fp,0(sp)
 4003a40:	dec00204 	addi	sp,sp,8
 4003a44:	f800283a 	ret

04003a48 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
 4003a48:	defffc04 	addi	sp,sp,-16
 4003a4c:	dfc00315 	stw	ra,12(sp)
 4003a50:	df000215 	stw	fp,8(sp)
 4003a54:	df000204 	addi	fp,sp,8
 4003a58:	e13ffe15 	stw	r4,-8(fp)
        BaseType_t xAlreadyYielded = pdFALSE;
 4003a5c:	e03fff15 	stw	zero,-4(fp)

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
 4003a60:	e0bffe17 	ldw	r2,-8(fp)
 4003a64:	10000626 	beq	r2,zero,4003a80 <vTaskDelay+0x38>
        {
            configASSERT( uxSchedulerSuspended == 0 );
            vTaskSuspendAll();
 4003a68:	40041000 	call	4004100 <vTaskSuspendAll>
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 4003a6c:	000b883a 	mov	r5,zero
 4003a70:	e13ffe17 	ldw	r4,-8(fp)
 4003a74:	4005af80 	call	4005af8 <prvAddCurrentTaskToDelayedList>
            }
            xAlreadyYielded = xTaskResumeAll();
 4003a78:	400412c0 	call	400412c <xTaskResumeAll>
 4003a7c:	e0bfff15 	stw	r2,-4(fp)
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
 4003a80:	e0bfff17 	ldw	r2,-4(fp)
 4003a84:	1000011e 	bne	r2,zero,4003a8c <vTaskDelay+0x44>
        {
            portYIELD_WITHIN_API();
 4003a88:	003b683a 	trap	0
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
 4003a8c:	0001883a 	nop
 4003a90:	e037883a 	mov	sp,fp
 4003a94:	dfc00117 	ldw	ra,4(sp)
 4003a98:	df000017 	ldw	fp,0(sp)
 4003a9c:	dec00204 	addi	sp,sp,8
 4003aa0:	f800283a 	ret

04003aa4 <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

    UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )
    {
 4003aa4:	defffb04 	addi	sp,sp,-20
 4003aa8:	dfc00415 	stw	ra,16(sp)
 4003aac:	df000315 	stw	fp,12(sp)
 4003ab0:	df000304 	addi	fp,sp,12
 4003ab4:	e13ffd15 	stw	r4,-12(fp)
        TCB_t const * pxTCB;
        UBaseType_t uxReturn;

        taskENTER_CRITICAL();
 4003ab8:	40050480 	call	4005048 <vTaskEnterCritical>
        {
            /* If null is passed in here then it is the priority of the task
             * that called uxTaskPriorityGet() that is being queried. */
            pxTCB = prvGetTCBFromHandle( xTask );
 4003abc:	e0bffd17 	ldw	r2,-12(fp)
 4003ac0:	1000021e 	bne	r2,zero,4003acc <uxTaskPriorityGet+0x28>
 4003ac4:	d0a5a517 	ldw	r2,-26988(gp)
 4003ac8:	00000106 	br	4003ad0 <uxTaskPriorityGet+0x2c>
 4003acc:	e0bffd17 	ldw	r2,-12(fp)
 4003ad0:	e0bfff15 	stw	r2,-4(fp)
            uxReturn = pxTCB->uxPriority;
 4003ad4:	e0bfff17 	ldw	r2,-4(fp)
 4003ad8:	10800b17 	ldw	r2,44(r2)
 4003adc:	e0bffe15 	stw	r2,-8(fp)
        }
        taskEXIT_CRITICAL();
 4003ae0:	400509c0 	call	400509c <vTaskExitCritical>

        return uxReturn;
 4003ae4:	e0bffe17 	ldw	r2,-8(fp)
    }
 4003ae8:	e037883a 	mov	sp,fp
 4003aec:	dfc00117 	ldw	ra,4(sp)
 4003af0:	df000017 	ldw	fp,0(sp)
 4003af4:	dec00204 	addi	sp,sp,8
 4003af8:	f800283a 	ret

04003afc <uxTaskPriorityGetFromISR>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

    UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )
    {
 4003afc:	defffb04 	addi	sp,sp,-20
 4003b00:	df000415 	stw	fp,16(sp)
 4003b04:	df000404 	addi	fp,sp,16
 4003b08:	e13ffc15 	stw	r4,-16(fp)
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
 4003b0c:	e03fff15 	stw	zero,-4(fp)
        {
            /* If null is passed in here then it is the priority of the calling
             * task that is being queried. */
            pxTCB = prvGetTCBFromHandle( xTask );
 4003b10:	e0bffc17 	ldw	r2,-16(fp)
 4003b14:	1000021e 	bne	r2,zero,4003b20 <uxTaskPriorityGetFromISR+0x24>
 4003b18:	d0a5a517 	ldw	r2,-26988(gp)
 4003b1c:	00000106 	br	4003b24 <uxTaskPriorityGetFromISR+0x28>
 4003b20:	e0bffc17 	ldw	r2,-16(fp)
 4003b24:	e0bffe15 	stw	r2,-8(fp)
            uxReturn = pxTCB->uxPriority;
 4003b28:	e0bffe17 	ldw	r2,-8(fp)
 4003b2c:	10800b17 	ldw	r2,44(r2)
 4003b30:	e0bffd15 	stw	r2,-12(fp)
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );

        return uxReturn;
 4003b34:	e0bffd17 	ldw	r2,-12(fp)
    }
 4003b38:	e037883a 	mov	sp,fp
 4003b3c:	df000017 	ldw	fp,0(sp)
 4003b40:	dec00104 	addi	sp,sp,4
 4003b44:	f800283a 	ret

04003b48 <vTaskPrioritySet>:

#if ( INCLUDE_vTaskPrioritySet == 1 )

    void vTaskPrioritySet( TaskHandle_t xTask,
                           UBaseType_t uxNewPriority )
    {
 4003b48:	defff804 	addi	sp,sp,-32
 4003b4c:	dfc00715 	stw	ra,28(sp)
 4003b50:	df000615 	stw	fp,24(sp)
 4003b54:	df000604 	addi	fp,sp,24
 4003b58:	e13ffb15 	stw	r4,-20(fp)
 4003b5c:	e17ffa15 	stw	r5,-24(fp)
        TCB_t * pxTCB;
        UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
        BaseType_t xYieldRequired = pdFALSE;
 4003b60:	e03fff15 	stw	zero,-4(fp)

        configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );

        /* Ensure the new priority is valid. */
        if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 4003b64:	e0bffa17 	ldw	r2,-24(fp)
 4003b68:	10800170 	cmpltui	r2,r2,5
 4003b6c:	1000021e 	bne	r2,zero,4003b78 <vTaskPrioritySet+0x30>
        {
            uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 4003b70:	00800104 	movi	r2,4
 4003b74:	e0bffa15 	stw	r2,-24(fp)
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        taskENTER_CRITICAL();
 4003b78:	40050480 	call	4005048 <vTaskEnterCritical>
        {
            /* If null is passed in here then it is the priority of the calling
             * task that is being changed. */
            pxTCB = prvGetTCBFromHandle( xTask );
 4003b7c:	e0bffb17 	ldw	r2,-20(fp)
 4003b80:	1000021e 	bne	r2,zero,4003b8c <vTaskPrioritySet+0x44>
 4003b84:	d0a5a517 	ldw	r2,-26988(gp)
 4003b88:	00000106 	br	4003b90 <vTaskPrioritySet+0x48>
 4003b8c:	e0bffb17 	ldw	r2,-20(fp)
 4003b90:	e0bffe15 	stw	r2,-8(fp)

            traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

            #if ( configUSE_MUTEXES == 1 )
                {
                    uxCurrentBasePriority = pxTCB->uxBasePriority;
 4003b94:	e0bffe17 	ldw	r2,-8(fp)
 4003b98:	10801017 	ldw	r2,64(r2)
 4003b9c:	e0bffd15 	stw	r2,-12(fp)
                {
                    uxCurrentBasePriority = pxTCB->uxPriority;
                }
            #endif

            if( uxCurrentBasePriority != uxNewPriority )
 4003ba0:	e0fffd17 	ldw	r3,-12(fp)
 4003ba4:	e0bffa17 	ldw	r2,-24(fp)
 4003ba8:	18804926 	beq	r3,r2,4003cd0 <vTaskPrioritySet+0x188>
            {
                /* The priority change may have readied a task of higher
                 * priority than the calling task. */
                if( uxNewPriority > uxCurrentBasePriority )
 4003bac:	e0bffa17 	ldw	r2,-24(fp)
 4003bb0:	e0fffd17 	ldw	r3,-12(fp)
 4003bb4:	18800a2e 	bgeu	r3,r2,4003be0 <vTaskPrioritySet+0x98>
                {
                    if( pxTCB != pxCurrentTCB )
 4003bb8:	d0a5a517 	ldw	r2,-26988(gp)
 4003bbc:	e0fffe17 	ldw	r3,-8(fp)
 4003bc0:	18800c26 	beq	r3,r2,4003bf4 <vTaskPrioritySet+0xac>
                    {
                        /* The priority of a task other than the currently
                         * running task is being raised.  Is the priority being
                         * raised above that of the running task? */
                        if( uxNewPriority >= pxCurrentTCB->uxPriority )
 4003bc4:	d0a5a517 	ldw	r2,-26988(gp)
 4003bc8:	10800b17 	ldw	r2,44(r2)
 4003bcc:	e0fffa17 	ldw	r3,-24(fp)
 4003bd0:	18800836 	bltu	r3,r2,4003bf4 <vTaskPrioritySet+0xac>
                        {
                            xYieldRequired = pdTRUE;
 4003bd4:	00800044 	movi	r2,1
 4003bd8:	e0bfff15 	stw	r2,-4(fp)
 4003bdc:	00000506 	br	4003bf4 <vTaskPrioritySet+0xac>
                        /* The priority of the running task is being raised,
                         * but the running task must already be the highest
                         * priority task able to run so no yield is required. */
                    }
                }
                else if( pxTCB == pxCurrentTCB )
 4003be0:	d0a5a517 	ldw	r2,-26988(gp)
 4003be4:	e0fffe17 	ldw	r3,-8(fp)
 4003be8:	1880021e 	bne	r3,r2,4003bf4 <vTaskPrioritySet+0xac>
                {
                    /* Setting the priority of the running task down means
                     * there may now be another task of higher priority that
                     * is ready to execute. */
                    xYieldRequired = pdTRUE;
 4003bec:	00800044 	movi	r2,1
 4003bf0:	e0bfff15 	stw	r2,-4(fp)
                }

                /* Remember the ready list the task might be referenced from
                 * before its uxPriority member is changed so the
                 * taskRESET_READY_PRIORITY() macro can function correctly. */
                uxPriorityUsedOnEntry = pxTCB->uxPriority;
 4003bf4:	e0bffe17 	ldw	r2,-8(fp)
 4003bf8:	10800b17 	ldw	r2,44(r2)
 4003bfc:	e0bffc15 	stw	r2,-16(fp)

                #if ( configUSE_MUTEXES == 1 )
                    {
                        /* Only change the priority being used if the task is not
                         * currently using an inherited priority. */
                        if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 4003c00:	e0bffe17 	ldw	r2,-8(fp)
 4003c04:	10c01017 	ldw	r3,64(r2)
 4003c08:	e0bffe17 	ldw	r2,-8(fp)
 4003c0c:	10800b17 	ldw	r2,44(r2)
 4003c10:	1880031e 	bne	r3,r2,4003c20 <vTaskPrioritySet+0xd8>
                        {
                            pxTCB->uxPriority = uxNewPriority;
 4003c14:	e0bffe17 	ldw	r2,-8(fp)
 4003c18:	e0fffa17 	ldw	r3,-24(fp)
 4003c1c:	10c00b15 	stw	r3,44(r2)
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }

                        /* The base priority gets set whatever. */
                        pxTCB->uxBasePriority = uxNewPriority;
 4003c20:	e0bffe17 	ldw	r2,-8(fp)
 4003c24:	e0fffa17 	ldw	r3,-24(fp)
 4003c28:	10c01015 	stw	r3,64(r2)
                    }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                /* Only reset the event list item value if the value is not
                 * being used for anything else. */
                if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 4003c2c:	e0bffe17 	ldw	r2,-8(fp)
 4003c30:	10800617 	ldw	r2,24(r2)
 4003c34:	10000516 	blt	r2,zero,4003c4c <vTaskPrioritySet+0x104>
                {
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 4003c38:	00c00144 	movi	r3,5
 4003c3c:	e0bffa17 	ldw	r2,-24(fp)
 4003c40:	1887c83a 	sub	r3,r3,r2
 4003c44:	e0bffe17 	ldw	r2,-8(fp)
 4003c48:	10c00615 	stw	r3,24(r2)

                /* If the task is in the blocked or suspended list we need do
                 * nothing more than change its priority variable. However, if
                 * the task is in a ready list it needs to be removed and placed
                 * in the list appropriate to its new priority. */
                if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 4003c4c:	e0bffe17 	ldw	r2,-8(fp)
 4003c50:	10c00517 	ldw	r3,20(r2)
 4003c54:	e0bffc17 	ldw	r2,-16(fp)
 4003c58:	11000524 	muli	r4,r2,20
 4003c5c:	00812074 	movhi	r2,1153
 4003c60:	10abdc04 	addi	r2,r2,-20624
 4003c64:	2085883a 	add	r2,r4,r2
 4003c68:	1880161e 	bne	r3,r2,4003cc4 <vTaskPrioritySet+0x17c>
                {
                    /* The task is currently in its ready list - remove before
                     * adding it to it's new ready list.  As we are in a critical
                     * section we can do this even if the scheduler is suspended. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 4003c6c:	e0bffe17 	ldw	r2,-8(fp)
 4003c70:	10800104 	addi	r2,r2,4
 4003c74:	1009883a 	mov	r4,r2
 4003c78:	40010600 	call	4001060 <uxListRemove>
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    prvAddTaskToReadyList( pxTCB );
 4003c7c:	e0bffe17 	ldw	r2,-8(fp)
 4003c80:	10800b17 	ldw	r2,44(r2)
 4003c84:	d0e5ab17 	ldw	r3,-26964(gp)
 4003c88:	1880032e 	bgeu	r3,r2,4003c98 <vTaskPrioritySet+0x150>
 4003c8c:	e0bffe17 	ldw	r2,-8(fp)
 4003c90:	10800b17 	ldw	r2,44(r2)
 4003c94:	d0a5ab15 	stw	r2,-26964(gp)
 4003c98:	e0bffe17 	ldw	r2,-8(fp)
 4003c9c:	10800b17 	ldw	r2,44(r2)
 4003ca0:	10c00524 	muli	r3,r2,20
 4003ca4:	00812074 	movhi	r2,1153
 4003ca8:	10abdc04 	addi	r2,r2,-20624
 4003cac:	1887883a 	add	r3,r3,r2
 4003cb0:	e0bffe17 	ldw	r2,-8(fp)
 4003cb4:	10800104 	addi	r2,r2,4
 4003cb8:	100b883a 	mov	r5,r2
 4003cbc:	1809883a 	mov	r4,r3
 4003cc0:	4000efc0 	call	4000efc <vListInsertEnd>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                if( xYieldRequired != pdFALSE )
 4003cc4:	e0bfff17 	ldw	r2,-4(fp)
 4003cc8:	10000126 	beq	r2,zero,4003cd0 <vTaskPrioritySet+0x188>
                {
                    taskYIELD_IF_USING_PREEMPTION();
 4003ccc:	003b683a 	trap	0
                /* Remove compiler warning about unused variables when the port
                 * optimised task selection is not being used. */
                ( void ) uxPriorityUsedOnEntry;
            }
        }
        taskEXIT_CRITICAL();
 4003cd0:	400509c0 	call	400509c <vTaskExitCritical>
    }
 4003cd4:	0001883a 	nop
 4003cd8:	e037883a 	mov	sp,fp
 4003cdc:	dfc00117 	ldw	ra,4(sp)
 4003ce0:	df000017 	ldw	fp,0(sp)
 4003ce4:	dec00204 	addi	sp,sp,8
 4003ce8:	f800283a 	ret

04003cec <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

    void vTaskSuspend( TaskHandle_t xTaskToSuspend )
    {
 4003cec:	defffb04 	addi	sp,sp,-20
 4003cf0:	dfc00415 	stw	ra,16(sp)
 4003cf4:	df000315 	stw	fp,12(sp)
 4003cf8:	df000304 	addi	fp,sp,12
 4003cfc:	e13ffd15 	stw	r4,-12(fp)
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
 4003d00:	40050480 	call	4005048 <vTaskEnterCritical>
        {
            /* If null is passed in here then it is the running task that is
             * being suspended. */
            pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 4003d04:	e0bffd17 	ldw	r2,-12(fp)
 4003d08:	1000021e 	bne	r2,zero,4003d14 <vTaskSuspend+0x28>
 4003d0c:	d0a5a517 	ldw	r2,-26988(gp)
 4003d10:	00000106 	br	4003d18 <vTaskSuspend+0x2c>
 4003d14:	e0bffd17 	ldw	r2,-12(fp)
 4003d18:	e0bffe15 	stw	r2,-8(fp)

            traceTASK_SUSPEND( pxTCB );

            /* Remove task from the ready/delayed list and place in the
             * suspended list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 4003d1c:	e0bffe17 	ldw	r2,-8(fp)
 4003d20:	10800104 	addi	r2,r2,4
 4003d24:	1009883a 	mov	r4,r2
 4003d28:	40010600 	call	4001060 <uxListRemove>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 4003d2c:	e0bffe17 	ldw	r2,-8(fp)
 4003d30:	10800a17 	ldw	r2,40(r2)
 4003d34:	10000426 	beq	r2,zero,4003d48 <vTaskSuspend+0x5c>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 4003d38:	e0bffe17 	ldw	r2,-8(fp)
 4003d3c:	10800604 	addi	r2,r2,24
 4003d40:	1009883a 	mov	r4,r2
 4003d44:	40010600 	call	4001060 <uxListRemove>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
 4003d48:	e0bffe17 	ldw	r2,-8(fp)
 4003d4c:	10800104 	addi	r2,r2,4
 4003d50:	100b883a 	mov	r5,r2
 4003d54:	01012074 	movhi	r4,1153
 4003d58:	212c0904 	addi	r4,r4,-20444
 4003d5c:	4000efc0 	call	4000efc <vListInsertEnd>

            #if ( configUSE_TASK_NOTIFICATIONS == 1 )
                {
                    BaseType_t x;

                    for( x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
 4003d60:	e03fff15 	stw	zero,-4(fp)
 4003d64:	00000e06 	br	4003da0 <vTaskSuspend+0xb4>
                    {
                        if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )
 4003d68:	e0fffe17 	ldw	r3,-8(fp)
 4003d6c:	e0bfff17 	ldw	r2,-4(fp)
 4003d70:	1885883a 	add	r2,r3,r2
 4003d74:	10801303 	ldbu	r2,76(r2)
 4003d78:	10803fcc 	andi	r2,r2,255
 4003d7c:	10800058 	cmpnei	r2,r2,1
 4003d80:	1000041e 	bne	r2,zero,4003d94 <vTaskSuspend+0xa8>
                        {
                            /* The task was blocked to wait for a notification, but is
                             * now suspended, so no notification was received. */
                            pxTCB->ucNotifyState[ x ] = taskNOT_WAITING_NOTIFICATION;
 4003d84:	e0fffe17 	ldw	r3,-8(fp)
 4003d88:	e0bfff17 	ldw	r2,-4(fp)
 4003d8c:	1885883a 	add	r2,r3,r2
 4003d90:	10001305 	stb	zero,76(r2)
                    for( x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
 4003d94:	e0bfff17 	ldw	r2,-4(fp)
 4003d98:	10800044 	addi	r2,r2,1
 4003d9c:	e0bfff15 	stw	r2,-4(fp)
 4003da0:	e0bfff17 	ldw	r2,-4(fp)
 4003da4:	00bff00e 	bge	zero,r2,4003d68 <vTaskSuspend+0x7c>
                        }
                    }
                }
            #endif /* if ( configUSE_TASK_NOTIFICATIONS == 1 ) */
        }
        taskEXIT_CRITICAL();
 4003da8:	400509c0 	call	400509c <vTaskExitCritical>

        if( xSchedulerRunning != pdFALSE )
 4003dac:	d0a5ac17 	ldw	r2,-26960(gp)
 4003db0:	10000326 	beq	r2,zero,4003dc0 <vTaskSuspend+0xd4>
        {
            /* Reset the next expected unblock time in case it referred to the
             * task that is now in the Suspended state. */
            taskENTER_CRITICAL();
 4003db4:	40050480 	call	4005048 <vTaskEnterCritical>
            {
                prvResetNextTaskUnblockTime();
 4003db8:	4004c5c0 	call	4004c5c <prvResetNextTaskUnblockTime>
            }
            taskEXIT_CRITICAL();
 4003dbc:	400509c0 	call	400509c <vTaskExitCritical>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( pxTCB == pxCurrentTCB )
 4003dc0:	d0a5a517 	ldw	r2,-26988(gp)
 4003dc4:	e0fffe17 	ldw	r3,-8(fp)
 4003dc8:	18800b1e 	bne	r3,r2,4003df8 <vTaskSuspend+0x10c>
        {
            if( xSchedulerRunning != pdFALSE )
 4003dcc:	d0a5ac17 	ldw	r2,-26960(gp)
 4003dd0:	10000226 	beq	r2,zero,4003ddc <vTaskSuspend+0xf0>
            {
                /* The current task has just been suspended. */
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
 4003dd4:	003b683a 	trap	0
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
 4003dd8:	00000706 	br	4003df8 <vTaskSuspend+0x10c>
                if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
 4003ddc:	00812074 	movhi	r2,1153
 4003de0:	10ec0917 	ldw	r3,-20444(r2)
 4003de4:	d0a5a917 	ldw	r2,-26972(gp)
 4003de8:	1880021e 	bne	r3,r2,4003df4 <vTaskSuspend+0x108>
                    pxCurrentTCB = NULL;
 4003dec:	d025a515 	stw	zero,-26988(gp)
    }
 4003df0:	00000106 	br	4003df8 <vTaskSuspend+0x10c>
                    vTaskSwitchContext();
 4003df4:	40045240 	call	4004524 <vTaskSwitchContext>
    }
 4003df8:	0001883a 	nop
 4003dfc:	e037883a 	mov	sp,fp
 4003e00:	dfc00117 	ldw	ra,4(sp)
 4003e04:	df000017 	ldw	fp,0(sp)
 4003e08:	dec00204 	addi	sp,sp,8
 4003e0c:	f800283a 	ret

04003e10 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

    static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
    {
 4003e10:	defffc04 	addi	sp,sp,-16
 4003e14:	df000315 	stw	fp,12(sp)
 4003e18:	df000304 	addi	fp,sp,12
 4003e1c:	e13ffd15 	stw	r4,-12(fp)
        BaseType_t xReturn = pdFALSE;
 4003e20:	e03fff15 	stw	zero,-4(fp)
        const TCB_t * const pxTCB = xTask;
 4003e24:	e0bffd17 	ldw	r2,-12(fp)
 4003e28:	e0bffe15 	stw	r2,-8(fp)

        /* It does not make sense to check if the calling task is suspended. */
        configASSERT( xTask );

        /* Is the task being resumed actually in the suspended list? */
        if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
 4003e2c:	e0bffe17 	ldw	r2,-8(fp)
 4003e30:	10c00517 	ldw	r3,20(r2)
 4003e34:	00812074 	movhi	r2,1153
 4003e38:	10ac0904 	addi	r2,r2,-20444
 4003e3c:	18800a1e 	bne	r3,r2,4003e68 <prvTaskIsTaskSuspended+0x58>
        {
            /* Has the task already been resumed from within an ISR? */
            if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
 4003e40:	e0bffe17 	ldw	r2,-8(fp)
 4003e44:	10c00a17 	ldw	r3,40(r2)
 4003e48:	00812074 	movhi	r2,1153
 4003e4c:	10abff04 	addi	r2,r2,-20484
 4003e50:	18800526 	beq	r3,r2,4003e68 <prvTaskIsTaskSuspended+0x58>
            {
                /* Is it in the suspended list because it is in the Suspended
                 * state, or because is is blocked with no timeout? */
                if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
 4003e54:	e0bffe17 	ldw	r2,-8(fp)
 4003e58:	10800a17 	ldw	r2,40(r2)
 4003e5c:	1000021e 	bne	r2,zero,4003e68 <prvTaskIsTaskSuspended+0x58>
                {
                    xReturn = pdTRUE;
 4003e60:	00800044 	movi	r2,1
 4003e64:	e0bfff15 	stw	r2,-4(fp)
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
 4003e68:	e0bfff17 	ldw	r2,-4(fp)
    } /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 4003e6c:	e037883a 	mov	sp,fp
 4003e70:	df000017 	ldw	fp,0(sp)
 4003e74:	dec00104 	addi	sp,sp,4
 4003e78:	f800283a 	ret

04003e7c <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

    void vTaskResume( TaskHandle_t xTaskToResume )
    {
 4003e7c:	defffc04 	addi	sp,sp,-16
 4003e80:	dfc00315 	stw	ra,12(sp)
 4003e84:	df000215 	stw	fp,8(sp)
 4003e88:	df000204 	addi	fp,sp,8
 4003e8c:	e13ffe15 	stw	r4,-8(fp)
        TCB_t * const pxTCB = xTaskToResume;
 4003e90:	e0bffe17 	ldw	r2,-8(fp)
 4003e94:	e0bfff15 	stw	r2,-4(fp)
        /* It does not make sense to resume the calling task. */
        configASSERT( xTaskToResume );

        /* The parameter cannot be NULL as it is impossible to resume the
         * currently executing task. */
        if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
 4003e98:	d0a5a517 	ldw	r2,-26988(gp)
 4003e9c:	e0ffff17 	ldw	r3,-4(fp)
 4003ea0:	18802326 	beq	r3,r2,4003f30 <vTaskResume+0xb4>
 4003ea4:	e0bfff17 	ldw	r2,-4(fp)
 4003ea8:	10002126 	beq	r2,zero,4003f30 <vTaskResume+0xb4>
        {
            taskENTER_CRITICAL();
 4003eac:	40050480 	call	4005048 <vTaskEnterCritical>
            {
                if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 4003eb0:	e13fff17 	ldw	r4,-4(fp)
 4003eb4:	4003e100 	call	4003e10 <prvTaskIsTaskSuspended>
 4003eb8:	10001c26 	beq	r2,zero,4003f2c <vTaskResume+0xb0>
                {
                    traceTASK_RESUME( pxTCB );

                    /* The ready list can be accessed even if the scheduler is
                     * suspended because this is inside a critical section. */
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 4003ebc:	e0bfff17 	ldw	r2,-4(fp)
 4003ec0:	10800104 	addi	r2,r2,4
 4003ec4:	1009883a 	mov	r4,r2
 4003ec8:	40010600 	call	4001060 <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
 4003ecc:	e0bfff17 	ldw	r2,-4(fp)
 4003ed0:	10800b17 	ldw	r2,44(r2)
 4003ed4:	d0e5ab17 	ldw	r3,-26964(gp)
 4003ed8:	1880032e 	bgeu	r3,r2,4003ee8 <vTaskResume+0x6c>
 4003edc:	e0bfff17 	ldw	r2,-4(fp)
 4003ee0:	10800b17 	ldw	r2,44(r2)
 4003ee4:	d0a5ab15 	stw	r2,-26964(gp)
 4003ee8:	e0bfff17 	ldw	r2,-4(fp)
 4003eec:	10800b17 	ldw	r2,44(r2)
 4003ef0:	10c00524 	muli	r3,r2,20
 4003ef4:	00812074 	movhi	r2,1153
 4003ef8:	10abdc04 	addi	r2,r2,-20624
 4003efc:	1887883a 	add	r3,r3,r2
 4003f00:	e0bfff17 	ldw	r2,-4(fp)
 4003f04:	10800104 	addi	r2,r2,4
 4003f08:	100b883a 	mov	r5,r2
 4003f0c:	1809883a 	mov	r4,r3
 4003f10:	4000efc0 	call	4000efc <vListInsertEnd>

                    /* A higher priority task may have just been resumed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 4003f14:	e0bfff17 	ldw	r2,-4(fp)
 4003f18:	10c00b17 	ldw	r3,44(r2)
 4003f1c:	d0a5a517 	ldw	r2,-26988(gp)
 4003f20:	10800b17 	ldw	r2,44(r2)
 4003f24:	18800136 	bltu	r3,r2,4003f2c <vTaskResume+0xb0>
                    {
                        /* This yield may not cause the task just resumed to run,
                         * but will leave the lists in the correct state for the
                         * next yield. */
                        taskYIELD_IF_USING_PREEMPTION();
 4003f28:	003b683a 	trap	0
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
 4003f2c:	400509c0 	call	400509c <vTaskExitCritical>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
 4003f30:	0001883a 	nop
 4003f34:	e037883a 	mov	sp,fp
 4003f38:	dfc00117 	ldw	ra,4(sp)
 4003f3c:	df000017 	ldw	fp,0(sp)
 4003f40:	dec00204 	addi	sp,sp,8
 4003f44:	f800283a 	ret

04003f48 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

    BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
    {
 4003f48:	defffa04 	addi	sp,sp,-24
 4003f4c:	dfc00515 	stw	ra,20(sp)
 4003f50:	df000415 	stw	fp,16(sp)
 4003f54:	df000404 	addi	fp,sp,16
 4003f58:	e13ffc15 	stw	r4,-16(fp)
        BaseType_t xYieldRequired = pdFALSE;
 4003f5c:	e03fff15 	stw	zero,-4(fp)
        TCB_t * const pxTCB = xTaskToResume;
 4003f60:	e0bffc17 	ldw	r2,-16(fp)
 4003f64:	e0bffe15 	stw	r2,-8(fp)
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 4003f68:	e03ffd15 	stw	zero,-12(fp)
        {
            if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 4003f6c:	e13ffe17 	ldw	r4,-8(fp)
 4003f70:	4003e100 	call	4003e10 <prvTaskIsTaskSuspended>
 4003f74:	10002626 	beq	r2,zero,4004010 <xTaskResumeFromISR+0xc8>
            {
                traceTASK_RESUME_FROM_ISR( pxTCB );

                /* Check the ready lists can be accessed. */
                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 4003f78:	d0a5b317 	ldw	r2,-26932(gp)
 4003f7c:	10001e1e 	bne	r2,zero,4003ff8 <xTaskResumeFromISR+0xb0>
                {
                    /* Ready lists can be accessed so move the task from the
                     * suspended list to the ready list directly. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 4003f80:	e0bffe17 	ldw	r2,-8(fp)
 4003f84:	10c00b17 	ldw	r3,44(r2)
 4003f88:	d0a5a517 	ldw	r2,-26988(gp)
 4003f8c:	10800b17 	ldw	r2,44(r2)
 4003f90:	18800236 	bltu	r3,r2,4003f9c <xTaskResumeFromISR+0x54>
                    {
                        xYieldRequired = pdTRUE;
 4003f94:	00800044 	movi	r2,1
 4003f98:	e0bfff15 	stw	r2,-4(fp)
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 4003f9c:	e0bffe17 	ldw	r2,-8(fp)
 4003fa0:	10800104 	addi	r2,r2,4
 4003fa4:	1009883a 	mov	r4,r2
 4003fa8:	40010600 	call	4001060 <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
 4003fac:	e0bffe17 	ldw	r2,-8(fp)
 4003fb0:	10800b17 	ldw	r2,44(r2)
 4003fb4:	d0e5ab17 	ldw	r3,-26964(gp)
 4003fb8:	1880032e 	bgeu	r3,r2,4003fc8 <xTaskResumeFromISR+0x80>
 4003fbc:	e0bffe17 	ldw	r2,-8(fp)
 4003fc0:	10800b17 	ldw	r2,44(r2)
 4003fc4:	d0a5ab15 	stw	r2,-26964(gp)
 4003fc8:	e0bffe17 	ldw	r2,-8(fp)
 4003fcc:	10800b17 	ldw	r2,44(r2)
 4003fd0:	10c00524 	muli	r3,r2,20
 4003fd4:	00812074 	movhi	r2,1153
 4003fd8:	10abdc04 	addi	r2,r2,-20624
 4003fdc:	1887883a 	add	r3,r3,r2
 4003fe0:	e0bffe17 	ldw	r2,-8(fp)
 4003fe4:	10800104 	addi	r2,r2,4
 4003fe8:	100b883a 	mov	r5,r2
 4003fec:	1809883a 	mov	r4,r3
 4003ff0:	4000efc0 	call	4000efc <vListInsertEnd>
 4003ff4:	00000606 	br	4004010 <xTaskResumeFromISR+0xc8>
                else
                {
                    /* The delayed or ready lists cannot be accessed so the task
                     * is held in the pending ready list until the scheduler is
                     * unsuspended. */
                    vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 4003ff8:	e0bffe17 	ldw	r2,-8(fp)
 4003ffc:	10800604 	addi	r2,r2,24
 4004000:	100b883a 	mov	r5,r2
 4004004:	01012074 	movhi	r4,1153
 4004008:	212bff04 	addi	r4,r4,-20484
 400400c:	4000efc0 	call	4000efc <vListInsertEnd>
                mtCOVERAGE_TEST_MARKER();
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xYieldRequired;
 4004010:	e0bfff17 	ldw	r2,-4(fp)
    }
 4004014:	e037883a 	mov	sp,fp
 4004018:	dfc00117 	ldw	ra,4(sp)
 400401c:	df000017 	ldw	fp,0(sp)
 4004020:	dec00204 	addi	sp,sp,8
 4004024:	f800283a 	ret

04004028 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 4004028:	defffa04 	addi	sp,sp,-24
 400402c:	dfc00515 	stw	ra,20(sp)
 4004030:	df000415 	stw	fp,16(sp)
 4004034:	df000404 	addi	fp,sp,16
            }
        }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
        {
            /* The Idle task is being created using dynamically allocated RAM. */
            xReturn = xTaskCreate( prvIdleTask,
 4004038:	d0a5b204 	addi	r2,gp,-26936
 400403c:	d8800115 	stw	r2,4(sp)
 4004040:	d8000015 	stw	zero,0(sp)
 4004044:	000f883a 	mov	r7,zero
 4004048:	01810004 	movi	r6,1024
 400404c:	01410074 	movhi	r5,1025
 4004050:	29608004 	addi	r5,r5,-32256
 4004054:	01010034 	movhi	r4,1024
 4004058:	21128004 	addi	r4,r4,18944
 400405c:	40034980 	call	4003498 <xTaskCreate>
 4004060:	e0bfff15 	stw	r2,-4(fp)
                mtCOVERAGE_TEST_MARKER();
            }
        }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
 4004064:	e0bfff17 	ldw	r2,-4(fp)
 4004068:	10800058 	cmpnei	r2,r2,1
 400406c:	10000c1e 	bne	r2,zero,40040a0 <vTaskStartScheduler+0x78>
  NIOS2_READ_STATUS (context);
 4004070:	0005303a 	rdctl	r2,status
 4004074:	e0bffe15 	stw	r2,-8(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 4004078:	e0fffe17 	ldw	r3,-8(fp)
 400407c:	00bfff84 	movi	r2,-2
 4004080:	1884703a 	and	r2,r3,r2
 4004084:	1001703a 	wrctl	status,r2
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */

        xNextTaskUnblockTime = portMAX_DELAY;
 4004088:	00bfffc4 	movi	r2,-1
 400408c:	d0a5b115 	stw	r2,-26940(gp)
        xSchedulerRunning = pdTRUE;
 4004090:	00800044 	movi	r2,1
 4004094:	d0a5ac15 	stw	r2,-26960(gp)
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 4004098:	d025aa15 	stw	zero,-26968(gp)

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        if( xPortStartScheduler() != pdFALSE )
 400409c:	40003a00 	call	40003a0 <xPortStartScheduler>
    }

    /* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
     * meaning xIdleTaskHandle is not used anywhere else. */
    ( void ) xIdleTaskHandle;
}
 40040a0:	0001883a 	nop
 40040a4:	e037883a 	mov	sp,fp
 40040a8:	dfc00117 	ldw	ra,4(sp)
 40040ac:	df000017 	ldw	fp,0(sp)
 40040b0:	dec00204 	addi	sp,sp,8
 40040b4:	f800283a 	ret

040040b8 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
 40040b8:	defffd04 	addi	sp,sp,-12
 40040bc:	dfc00215 	stw	ra,8(sp)
 40040c0:	df000115 	stw	fp,4(sp)
 40040c4:	df000104 	addi	fp,sp,4
  NIOS2_READ_STATUS (context);
 40040c8:	0005303a 	rdctl	r2,status
 40040cc:	e0bfff15 	stw	r2,-4(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 40040d0:	e0ffff17 	ldw	r3,-4(fp)
 40040d4:	00bfff84 	movi	r2,-2
 40040d8:	1884703a 	and	r2,r3,r2
 40040dc:	1001703a 	wrctl	status,r2
    /* Stop the scheduler interrupts and call the portable scheduler end
     * routine so the original ISRs can be restored if necessary.  The port
     * layer must ensure interrupts enable  bit is left in the correct state. */
    portDISABLE_INTERRUPTS();
    xSchedulerRunning = pdFALSE;
 40040e0:	d025ac15 	stw	zero,-26960(gp)
    vPortEndScheduler();
 40040e4:	40003d80 	call	40003d8 <vPortEndScheduler>
}
 40040e8:	0001883a 	nop
 40040ec:	e037883a 	mov	sp,fp
 40040f0:	dfc00117 	ldw	ra,4(sp)
 40040f4:	df000017 	ldw	fp,0(sp)
 40040f8:	dec00204 	addi	sp,sp,8
 40040fc:	f800283a 	ret

04004100 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
 4004100:	deffff04 	addi	sp,sp,-4
 4004104:	df000015 	stw	fp,0(sp)
 4004108:	d839883a 	mov	fp,sp
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
 400410c:	d0a5b317 	ldw	r2,-26932(gp)
 4004110:	10800044 	addi	r2,r2,1
 4004114:	d0a5b315 	stw	r2,-26932(gp)

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
 4004118:	0001883a 	nop
 400411c:	e037883a 	mov	sp,fp
 4004120:	df000017 	ldw	fp,0(sp)
 4004124:	dec00104 	addi	sp,sp,4
 4004128:	f800283a 	ret

0400412c <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
 400412c:	defffb04 	addi	sp,sp,-20
 4004130:	dfc00415 	stw	ra,16(sp)
 4004134:	df000315 	stw	fp,12(sp)
 4004138:	df000304 	addi	fp,sp,12
    TCB_t * pxTCB = NULL;
 400413c:	e03fff15 	stw	zero,-4(fp)
    BaseType_t xAlreadyYielded = pdFALSE;
 4004140:	e03ffe15 	stw	zero,-8(fp)
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
 4004144:	40050480 	call	4005048 <vTaskEnterCritical>
    {
        --uxSchedulerSuspended;
 4004148:	d0a5b317 	ldw	r2,-26932(gp)
 400414c:	10bfffc4 	addi	r2,r2,-1
 4004150:	d0a5b315 	stw	r2,-26932(gp)

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 4004154:	d0a5b317 	ldw	r2,-26932(gp)
 4004158:	1000411e 	bne	r2,zero,4004260 <xTaskResumeAll+0x134>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 400415c:	d0a5a917 	ldw	r2,-26972(gp)
 4004160:	10003f26 	beq	r2,zero,4004260 <xTaskResumeAll+0x134>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 4004164:	00002506 	br	40041fc <xTaskResumeAll+0xd0>
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 4004168:	00812074 	movhi	r2,1153
 400416c:	10ac0217 	ldw	r2,-20472(r2)
 4004170:	10800317 	ldw	r2,12(r2)
 4004174:	e0bfff15 	stw	r2,-4(fp)
                    ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 4004178:	e0bfff17 	ldw	r2,-4(fp)
 400417c:	10800604 	addi	r2,r2,24
 4004180:	1009883a 	mov	r4,r2
 4004184:	40010600 	call	4001060 <uxListRemove>
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 4004188:	e0bfff17 	ldw	r2,-4(fp)
 400418c:	10800104 	addi	r2,r2,4
 4004190:	1009883a 	mov	r4,r2
 4004194:	40010600 	call	4001060 <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
 4004198:	e0bfff17 	ldw	r2,-4(fp)
 400419c:	10800b17 	ldw	r2,44(r2)
 40041a0:	d0e5ab17 	ldw	r3,-26964(gp)
 40041a4:	1880032e 	bgeu	r3,r2,40041b4 <xTaskResumeAll+0x88>
 40041a8:	e0bfff17 	ldw	r2,-4(fp)
 40041ac:	10800b17 	ldw	r2,44(r2)
 40041b0:	d0a5ab15 	stw	r2,-26964(gp)
 40041b4:	e0bfff17 	ldw	r2,-4(fp)
 40041b8:	10800b17 	ldw	r2,44(r2)
 40041bc:	10c00524 	muli	r3,r2,20
 40041c0:	00812074 	movhi	r2,1153
 40041c4:	10abdc04 	addi	r2,r2,-20624
 40041c8:	1887883a 	add	r3,r3,r2
 40041cc:	e0bfff17 	ldw	r2,-4(fp)
 40041d0:	10800104 	addi	r2,r2,4
 40041d4:	100b883a 	mov	r5,r2
 40041d8:	1809883a 	mov	r4,r3
 40041dc:	4000efc0 	call	4000efc <vListInsertEnd>

                    /* If the moved task has a priority higher than the current
                     * task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 40041e0:	e0bfff17 	ldw	r2,-4(fp)
 40041e4:	10c00b17 	ldw	r3,44(r2)
 40041e8:	d0a5a517 	ldw	r2,-26988(gp)
 40041ec:	10800b17 	ldw	r2,44(r2)
 40041f0:	18800236 	bltu	r3,r2,40041fc <xTaskResumeAll+0xd0>
                    {
                        xYieldPending = pdTRUE;
 40041f4:	00800044 	movi	r2,1
 40041f8:	d0a5ae15 	stw	r2,-26952(gp)
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 40041fc:	00812074 	movhi	r2,1153
 4004200:	10abff17 	ldw	r2,-20484(r2)
 4004204:	103fd81e 	bne	r2,zero,4004168 <xTaskResumeAll+0x3c>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
 4004208:	e0bfff17 	ldw	r2,-4(fp)
 400420c:	10000126 	beq	r2,zero,4004214 <xTaskResumeAll+0xe8>
                     * which may have prevented the next unblock time from being
                     * re-calculated, in which case re-calculate it now.  Mainly
                     * important for low power tickless implementations, where
                     * this can prevent an unnecessary exit from low power
                     * state. */
                    prvResetNextTaskUnblockTime();
 4004210:	4004c5c0 	call	4004c5c <prvResetNextTaskUnblockTime>
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
 4004214:	d0a5ad17 	ldw	r2,-26956(gp)
 4004218:	e0bffd15 	stw	r2,-12(fp)

                    if( xPendedCounts > ( TickType_t ) 0U )
 400421c:	e0bffd17 	ldw	r2,-12(fp)
 4004220:	10000a26 	beq	r2,zero,400424c <xTaskResumeAll+0x120>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
 4004224:	40043780 	call	4004378 <xTaskIncrementTick>
 4004228:	10000226 	beq	r2,zero,4004234 <xTaskResumeAll+0x108>
                            {
                                xYieldPending = pdTRUE;
 400422c:	00800044 	movi	r2,1
 4004230:	d0a5ae15 	stw	r2,-26952(gp)
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
 4004234:	e0bffd17 	ldw	r2,-12(fp)
 4004238:	10bfffc4 	addi	r2,r2,-1
 400423c:	e0bffd15 	stw	r2,-12(fp)
                        } while( xPendedCounts > ( TickType_t ) 0U );
 4004240:	e0bffd17 	ldw	r2,-12(fp)
 4004244:	103ff71e 	bne	r2,zero,4004224 <xTaskResumeAll+0xf8>

                        xPendedTicks = 0;
 4004248:	d025ad15 	stw	zero,-26956(gp)
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
 400424c:	d0a5ae17 	ldw	r2,-26952(gp)
 4004250:	10000326 	beq	r2,zero,4004260 <xTaskResumeAll+0x134>
                {
                    #if ( configUSE_PREEMPTION != 0 )
                        {
                            xAlreadyYielded = pdTRUE;
 4004254:	00800044 	movi	r2,1
 4004258:	e0bffe15 	stw	r2,-8(fp)
                        }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
 400425c:	003b683a 	trap	0
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
 4004260:	400509c0 	call	400509c <vTaskExitCritical>

    return xAlreadyYielded;
 4004264:	e0bffe17 	ldw	r2,-8(fp)
}
 4004268:	e037883a 	mov	sp,fp
 400426c:	dfc00117 	ldw	ra,4(sp)
 4004270:	df000017 	ldw	fp,0(sp)
 4004274:	dec00204 	addi	sp,sp,8
 4004278:	f800283a 	ret

0400427c <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
 400427c:	defffe04 	addi	sp,sp,-8
 4004280:	df000115 	stw	fp,4(sp)
 4004284:	df000104 	addi	fp,sp,4
    TickType_t xTicks;

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    {
        xTicks = xTickCount;
 4004288:	d0a5aa17 	ldw	r2,-26968(gp)
 400428c:	e0bfff15 	stw	r2,-4(fp)
    }
    portTICK_TYPE_EXIT_CRITICAL();

    return xTicks;
 4004290:	e0bfff17 	ldw	r2,-4(fp)
}
 4004294:	e037883a 	mov	sp,fp
 4004298:	df000017 	ldw	fp,0(sp)
 400429c:	dec00104 	addi	sp,sp,4
 40042a0:	f800283a 	ret

040042a4 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
 40042a4:	defffd04 	addi	sp,sp,-12
 40042a8:	df000215 	stw	fp,8(sp)
 40042ac:	df000204 	addi	fp,sp,8
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
 40042b0:	e03fff15 	stw	zero,-4(fp)
    {
        xReturn = xTickCount;
 40042b4:	d0a5aa17 	ldw	r2,-26968(gp)
 40042b8:	e0bffe15 	stw	r2,-8(fp)
    }
    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
 40042bc:	e0bffe17 	ldw	r2,-8(fp)
}
 40042c0:	e037883a 	mov	sp,fp
 40042c4:	df000017 	ldw	fp,0(sp)
 40042c8:	dec00104 	addi	sp,sp,4
 40042cc:	f800283a 	ret

040042d0 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
 40042d0:	deffff04 	addi	sp,sp,-4
 40042d4:	df000015 	stw	fp,0(sp)
 40042d8:	d839883a 	mov	fp,sp
    /* A critical section is not required because the variables are of type
     * BaseType_t. */
    return uxCurrentNumberOfTasks;
 40042dc:	d0a5a917 	ldw	r2,-26972(gp)
}
 40042e0:	e037883a 	mov	sp,fp
 40042e4:	df000017 	ldw	fp,0(sp)
 40042e8:	dec00104 	addi	sp,sp,4
 40042ec:	f800283a 	ret

040042f0 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char * pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
 40042f0:	defffd04 	addi	sp,sp,-12
 40042f4:	df000215 	stw	fp,8(sp)
 40042f8:	df000204 	addi	fp,sp,8
 40042fc:	e13ffe15 	stw	r4,-8(fp)
    TCB_t * pxTCB;

    /* If null is passed in here then the name of the calling task is being
     * queried. */
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 4004300:	e0bffe17 	ldw	r2,-8(fp)
 4004304:	1000021e 	bne	r2,zero,4004310 <pcTaskGetName+0x20>
 4004308:	d0a5a517 	ldw	r2,-26988(gp)
 400430c:	00000106 	br	4004314 <pcTaskGetName+0x24>
 4004310:	e0bffe17 	ldw	r2,-8(fp)
 4004314:	e0bfff15 	stw	r2,-4(fp)
    configASSERT( pxTCB );
    return &( pxTCB->pcTaskName[ 0 ] );
 4004318:	e0bfff17 	ldw	r2,-4(fp)
 400431c:	10800d04 	addi	r2,r2,52
}
 4004320:	e037883a 	mov	sp,fp
 4004324:	df000017 	ldw	fp,0(sp)
 4004328:	dec00104 	addi	sp,sp,4
 400432c:	f800283a 	ret

04004330 <xTaskCatchUpTicks>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
 4004330:	defffc04 	addi	sp,sp,-16
 4004334:	dfc00315 	stw	ra,12(sp)
 4004338:	df000215 	stw	fp,8(sp)
 400433c:	df000204 	addi	fp,sp,8
 4004340:	e13ffe15 	stw	r4,-8(fp)
     * relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
    configASSERT( uxSchedulerSuspended == 0 );

    /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
     * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
    vTaskSuspendAll();
 4004344:	40041000 	call	4004100 <vTaskSuspendAll>
    xPendedTicks += xTicksToCatchUp;
 4004348:	d0e5ad17 	ldw	r3,-26956(gp)
 400434c:	e0bffe17 	ldw	r2,-8(fp)
 4004350:	1885883a 	add	r2,r3,r2
 4004354:	d0a5ad15 	stw	r2,-26956(gp)
    xYieldOccurred = xTaskResumeAll();
 4004358:	400412c0 	call	400412c <xTaskResumeAll>
 400435c:	e0bfff15 	stw	r2,-4(fp)

    return xYieldOccurred;
 4004360:	e0bfff17 	ldw	r2,-4(fp)
}
 4004364:	e037883a 	mov	sp,fp
 4004368:	dfc00117 	ldw	ra,4(sp)
 400436c:	df000017 	ldw	fp,0(sp)
 4004370:	dec00204 	addi	sp,sp,8
 4004374:	f800283a 	ret

04004378 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
 4004378:	defff904 	addi	sp,sp,-28
 400437c:	dfc00615 	stw	ra,24(sp)
 4004380:	df000515 	stw	fp,20(sp)
 4004384:	df000504 	addi	fp,sp,20
    TCB_t * pxTCB;
    TickType_t xItemValue;
    BaseType_t xSwitchRequired = pdFALSE;
 4004388:	e03fff15 	stw	zero,-4(fp)
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 400438c:	d0a5b317 	ldw	r2,-26932(gp)
 4004390:	10005b1e 	bne	r2,zero,4004500 <xTaskIncrementTick+0x188>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 4004394:	d0a5aa17 	ldw	r2,-26968(gp)
 4004398:	10800044 	addi	r2,r2,1
 400439c:	e0bffe15 	stw	r2,-8(fp)

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
 40043a0:	e0bffe17 	ldw	r2,-8(fp)
 40043a4:	d0a5aa15 	stw	r2,-26968(gp)

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 40043a8:	e0bffe17 	ldw	r2,-8(fp)
 40043ac:	10000a1e 	bne	r2,zero,40043d8 <xTaskIncrementTick+0x60>
        {
            taskSWITCH_DELAYED_LISTS();
 40043b0:	d0a5a617 	ldw	r2,-26984(gp)
 40043b4:	e0bffd15 	stw	r2,-12(fp)
 40043b8:	d0a5a717 	ldw	r2,-26980(gp)
 40043bc:	d0a5a615 	stw	r2,-26984(gp)
 40043c0:	e0bffd17 	ldw	r2,-12(fp)
 40043c4:	d0a5a715 	stw	r2,-26980(gp)
 40043c8:	d0a5af17 	ldw	r2,-26948(gp)
 40043cc:	10800044 	addi	r2,r2,1
 40043d0:	d0a5af15 	stw	r2,-26948(gp)
 40043d4:	4004c5c0 	call	4004c5c <prvResetNextTaskUnblockTime>

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
 40043d8:	d0a5b117 	ldw	r2,-26940(gp)
 40043dc:	e0fffe17 	ldw	r3,-8(fp)
 40043e0:	18803836 	bltu	r3,r2,40044c4 <xTaskIncrementTick+0x14c>
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 40043e4:	d0a5a617 	ldw	r2,-26984(gp)
 40043e8:	10800017 	ldw	r2,0(r2)
 40043ec:	1000031e 	bne	r2,zero,40043fc <xTaskIncrementTick+0x84>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 40043f0:	00bfffc4 	movi	r2,-1
 40043f4:	d0a5b115 	stw	r2,-26940(gp)
                    break;
 40043f8:	00003206 	br	40044c4 <xTaskIncrementTick+0x14c>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 40043fc:	d0a5a617 	ldw	r2,-26984(gp)
 4004400:	10800317 	ldw	r2,12(r2)
 4004404:	10800317 	ldw	r2,12(r2)
 4004408:	e0bffc15 	stw	r2,-16(fp)
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 400440c:	e0bffc17 	ldw	r2,-16(fp)
 4004410:	10800117 	ldw	r2,4(r2)
 4004414:	e0bffb15 	stw	r2,-20(fp)

                    if( xConstTickCount < xItemValue )
 4004418:	e0fffe17 	ldw	r3,-8(fp)
 400441c:	e0bffb17 	ldw	r2,-20(fp)
 4004420:	1880032e 	bgeu	r3,r2,4004430 <xTaskIncrementTick+0xb8>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
 4004424:	e0bffb17 	ldw	r2,-20(fp)
 4004428:	d0a5b115 	stw	r2,-26940(gp)
                        break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
 400442c:	00002506 	br	40044c4 <xTaskIncrementTick+0x14c>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 4004430:	e0bffc17 	ldw	r2,-16(fp)
 4004434:	10800104 	addi	r2,r2,4
 4004438:	1009883a 	mov	r4,r2
 400443c:	40010600 	call	4001060 <uxListRemove>

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 4004440:	e0bffc17 	ldw	r2,-16(fp)
 4004444:	10800a17 	ldw	r2,40(r2)
 4004448:	10000426 	beq	r2,zero,400445c <xTaskIncrementTick+0xe4>
                    {
                        ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 400444c:	e0bffc17 	ldw	r2,-16(fp)
 4004450:	10800604 	addi	r2,r2,24
 4004454:	1009883a 	mov	r4,r2
 4004458:	40010600 	call	4001060 <uxListRemove>
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
 400445c:	e0bffc17 	ldw	r2,-16(fp)
 4004460:	10800b17 	ldw	r2,44(r2)
 4004464:	d0e5ab17 	ldw	r3,-26964(gp)
 4004468:	1880032e 	bgeu	r3,r2,4004478 <xTaskIncrementTick+0x100>
 400446c:	e0bffc17 	ldw	r2,-16(fp)
 4004470:	10800b17 	ldw	r2,44(r2)
 4004474:	d0a5ab15 	stw	r2,-26964(gp)
 4004478:	e0bffc17 	ldw	r2,-16(fp)
 400447c:	10800b17 	ldw	r2,44(r2)
 4004480:	10c00524 	muli	r3,r2,20
 4004484:	00812074 	movhi	r2,1153
 4004488:	10abdc04 	addi	r2,r2,-20624
 400448c:	1887883a 	add	r3,r3,r2
 4004490:	e0bffc17 	ldw	r2,-16(fp)
 4004494:	10800104 	addi	r2,r2,4
 4004498:	100b883a 	mov	r5,r2
 400449c:	1809883a 	mov	r4,r3
 40044a0:	4000efc0 	call	4000efc <vListInsertEnd>
                        {
                            /* Preemption is on, but a context switch should
                             * only be performed if the unblocked task has a
                             * priority that is equal to or higher than the
                             * currently executing task. */
                            if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 40044a4:	e0bffc17 	ldw	r2,-16(fp)
 40044a8:	10c00b17 	ldw	r3,44(r2)
 40044ac:	d0a5a517 	ldw	r2,-26988(gp)
 40044b0:	10800b17 	ldw	r2,44(r2)
 40044b4:	18bfcb36 	bltu	r3,r2,40043e4 <xTaskIncrementTick+0x6c>
                            {
                                xSwitchRequired = pdTRUE;
 40044b8:	00800044 	movi	r2,1
 40044bc:	e0bfff15 	stw	r2,-4(fp)
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 40044c0:	003fc806 	br	40043e4 <xTaskIncrementTick+0x6c>
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
            {
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 40044c4:	d0a5a517 	ldw	r2,-26988(gp)
 40044c8:	10800b17 	ldw	r2,44(r2)
 40044cc:	10c00524 	muli	r3,r2,20
 40044d0:	00812074 	movhi	r2,1153
 40044d4:	1885883a 	add	r2,r3,r2
 40044d8:	10abdc17 	ldw	r2,-20624(r2)
 40044dc:	108000b0 	cmpltui	r2,r2,2
 40044e0:	1000021e 	bne	r2,zero,40044ec <xTaskIncrementTick+0x174>
                {
                    xSwitchRequired = pdTRUE;
 40044e4:	00800044 	movi	r2,1
 40044e8:	e0bfff15 	stw	r2,-4(fp)
            }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
            {
                if( xYieldPending != pdFALSE )
 40044ec:	d0a5ae17 	ldw	r2,-26952(gp)
 40044f0:	10000626 	beq	r2,zero,400450c <xTaskIncrementTick+0x194>
                {
                    xSwitchRequired = pdTRUE;
 40044f4:	00800044 	movi	r2,1
 40044f8:	e0bfff15 	stw	r2,-4(fp)
 40044fc:	00000306 	br	400450c <xTaskIncrementTick+0x194>
            }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
 4004500:	d0a5ad17 	ldw	r2,-26956(gp)
 4004504:	10800044 	addi	r2,r2,1
 4004508:	d0a5ad15 	stw	r2,-26956(gp)
                vApplicationTickHook();
            }
        #endif
    }

    return xSwitchRequired;
 400450c:	e0bfff17 	ldw	r2,-4(fp)
}
 4004510:	e037883a 	mov	sp,fp
 4004514:	dfc00117 	ldw	ra,4(sp)
 4004518:	df000017 	ldw	fp,0(sp)
 400451c:	dec00204 	addi	sp,sp,8
 4004520:	f800283a 	ret

04004524 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 4004524:	defffd04 	addi	sp,sp,-12
 4004528:	df000215 	stw	fp,8(sp)
 400452c:	df000204 	addi	fp,sp,8
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 4004530:	d0a5b317 	ldw	r2,-26932(gp)
 4004534:	10000326 	beq	r2,zero,4004544 <vTaskSwitchContext+0x20>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
 4004538:	00800044 	movi	r2,1
 400453c:	d0a5ae15 	stw	r2,-26952(gp)
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */
    }
}
 4004540:	00002806 	br	40045e4 <vTaskSwitchContext+0xc0>
        xYieldPending = pdFALSE;
 4004544:	d025ae15 	stw	zero,-26952(gp)
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 4004548:	d0a5ab17 	ldw	r2,-26964(gp)
 400454c:	e0bfff15 	stw	r2,-4(fp)
 4004550:	00000306 	br	4004560 <vTaskSwitchContext+0x3c>
 4004554:	e0bfff17 	ldw	r2,-4(fp)
 4004558:	10bfffc4 	addi	r2,r2,-1
 400455c:	e0bfff15 	stw	r2,-4(fp)
 4004560:	e0bfff17 	ldw	r2,-4(fp)
 4004564:	10c00524 	muli	r3,r2,20
 4004568:	00812074 	movhi	r2,1153
 400456c:	1885883a 	add	r2,r3,r2
 4004570:	10abdc17 	ldw	r2,-20624(r2)
 4004574:	103ff726 	beq	r2,zero,4004554 <vTaskSwitchContext+0x30>
 4004578:	e0bfff17 	ldw	r2,-4(fp)
 400457c:	10c00524 	muli	r3,r2,20
 4004580:	00812074 	movhi	r2,1153
 4004584:	10abdc04 	addi	r2,r2,-20624
 4004588:	1885883a 	add	r2,r3,r2
 400458c:	e0bffe15 	stw	r2,-8(fp)
 4004590:	e0bffe17 	ldw	r2,-8(fp)
 4004594:	10800117 	ldw	r2,4(r2)
 4004598:	10c00117 	ldw	r3,4(r2)
 400459c:	e0bffe17 	ldw	r2,-8(fp)
 40045a0:	10c00115 	stw	r3,4(r2)
 40045a4:	e0bffe17 	ldw	r2,-8(fp)
 40045a8:	10c00117 	ldw	r3,4(r2)
 40045ac:	e0bffe17 	ldw	r2,-8(fp)
 40045b0:	10800204 	addi	r2,r2,8
 40045b4:	1880051e 	bne	r3,r2,40045cc <vTaskSwitchContext+0xa8>
 40045b8:	e0bffe17 	ldw	r2,-8(fp)
 40045bc:	10800117 	ldw	r2,4(r2)
 40045c0:	10c00117 	ldw	r3,4(r2)
 40045c4:	e0bffe17 	ldw	r2,-8(fp)
 40045c8:	10c00115 	stw	r3,4(r2)
 40045cc:	e0bffe17 	ldw	r2,-8(fp)
 40045d0:	10800117 	ldw	r2,4(r2)
 40045d4:	10800317 	ldw	r2,12(r2)
 40045d8:	d0a5a515 	stw	r2,-26988(gp)
 40045dc:	e0bfff17 	ldw	r2,-4(fp)
 40045e0:	d0a5ab15 	stw	r2,-26964(gp)
}
 40045e4:	0001883a 	nop
 40045e8:	e037883a 	mov	sp,fp
 40045ec:	df000017 	ldw	fp,0(sp)
 40045f0:	dec00104 	addi	sp,sp,4
 40045f4:	f800283a 	ret

040045f8 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
 40045f8:	defffc04 	addi	sp,sp,-16
 40045fc:	dfc00315 	stw	ra,12(sp)
 4004600:	df000215 	stw	fp,8(sp)
 4004604:	df000204 	addi	fp,sp,8
 4004608:	e13fff15 	stw	r4,-4(fp)
 400460c:	e17ffe15 	stw	r5,-8(fp)

    /* Place the event list item of the TCB in the appropriate event list.
     * This is placed in the list in priority order so the highest priority task
     * is the first to be woken by the event.  The queue that contains the event
     * list is locked, preventing simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 4004610:	d0a5a517 	ldw	r2,-26988(gp)
 4004614:	10800604 	addi	r2,r2,24
 4004618:	100b883a 	mov	r5,r2
 400461c:	e13fff17 	ldw	r4,-4(fp)
 4004620:	4000f880 	call	4000f88 <vListInsert>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 4004624:	01400044 	movi	r5,1
 4004628:	e13ffe17 	ldw	r4,-8(fp)
 400462c:	4005af80 	call	4005af8 <prvAddCurrentTaskToDelayedList>
}
 4004630:	0001883a 	nop
 4004634:	e037883a 	mov	sp,fp
 4004638:	dfc00117 	ldw	ra,4(sp)
 400463c:	df000017 	ldw	fp,0(sp)
 4004640:	dec00204 	addi	sp,sp,8
 4004644:	f800283a 	ret

04004648 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
                                     const TickType_t xItemValue,
                                     const TickType_t xTicksToWait )
{
 4004648:	defffb04 	addi	sp,sp,-20
 400464c:	dfc00415 	stw	ra,16(sp)
 4004650:	df000315 	stw	fp,12(sp)
 4004654:	df000304 	addi	fp,sp,12
 4004658:	e13fff15 	stw	r4,-4(fp)
 400465c:	e17ffe15 	stw	r5,-8(fp)
 4004660:	e1bffd15 	stw	r6,-12(fp)
    configASSERT( uxSchedulerSuspended != 0 );

    /* Store the item value in the event list item.  It is safe to access the
     * event list item here as interrupts won't access the event list item of a
     * task that is not in the Blocked state. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 4004664:	d0a5a517 	ldw	r2,-26988(gp)
 4004668:	e0fffe17 	ldw	r3,-8(fp)
 400466c:	18e00034 	orhi	r3,r3,32768
 4004670:	10c00615 	stw	r3,24(r2)
    /* Place the event list item of the TCB at the end of the appropriate event
     * list.  It is safe to access the event list here because it is part of an
     * event group implementation - and interrupts don't access event groups
     * directly (instead they access them indirectly by pending function calls to
     * the task level). */
    vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 4004674:	d0a5a517 	ldw	r2,-26988(gp)
 4004678:	10800604 	addi	r2,r2,24
 400467c:	100b883a 	mov	r5,r2
 4004680:	e13fff17 	ldw	r4,-4(fp)
 4004684:	4000efc0 	call	4000efc <vListInsertEnd>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 4004688:	01400044 	movi	r5,1
 400468c:	e13ffd17 	ldw	r4,-12(fp)
 4004690:	4005af80 	call	4005af8 <prvAddCurrentTaskToDelayedList>
}
 4004694:	0001883a 	nop
 4004698:	e037883a 	mov	sp,fp
 400469c:	dfc00117 	ldw	ra,4(sp)
 40046a0:	df000017 	ldw	fp,0(sp)
 40046a4:	dec00204 	addi	sp,sp,8
 40046a8:	f800283a 	ret

040046ac <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
 40046ac:	defffb04 	addi	sp,sp,-20
 40046b0:	dfc00415 	stw	ra,16(sp)
 40046b4:	df000315 	stw	fp,12(sp)
 40046b8:	df000304 	addi	fp,sp,12
 40046bc:	e13ffd15 	stw	r4,-12(fp)
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 40046c0:	e0bffd17 	ldw	r2,-12(fp)
 40046c4:	10800317 	ldw	r2,12(r2)
 40046c8:	10800317 	ldw	r2,12(r2)
 40046cc:	e0bffe15 	stw	r2,-8(fp)
    configASSERT( pxUnblockedTCB );
    ( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 40046d0:	e0bffe17 	ldw	r2,-8(fp)
 40046d4:	10800604 	addi	r2,r2,24
 40046d8:	1009883a 	mov	r4,r2
 40046dc:	40010600 	call	4001060 <uxListRemove>

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 40046e0:	d0a5b317 	ldw	r2,-26932(gp)
 40046e4:	1000171e 	bne	r2,zero,4004744 <xTaskRemoveFromEventList+0x98>
    {
        ( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 40046e8:	e0bffe17 	ldw	r2,-8(fp)
 40046ec:	10800104 	addi	r2,r2,4
 40046f0:	1009883a 	mov	r4,r2
 40046f4:	40010600 	call	4001060 <uxListRemove>
        prvAddTaskToReadyList( pxUnblockedTCB );
 40046f8:	e0bffe17 	ldw	r2,-8(fp)
 40046fc:	10800b17 	ldw	r2,44(r2)
 4004700:	d0e5ab17 	ldw	r3,-26964(gp)
 4004704:	1880032e 	bgeu	r3,r2,4004714 <xTaskRemoveFromEventList+0x68>
 4004708:	e0bffe17 	ldw	r2,-8(fp)
 400470c:	10800b17 	ldw	r2,44(r2)
 4004710:	d0a5ab15 	stw	r2,-26964(gp)
 4004714:	e0bffe17 	ldw	r2,-8(fp)
 4004718:	10800b17 	ldw	r2,44(r2)
 400471c:	10c00524 	muli	r3,r2,20
 4004720:	00812074 	movhi	r2,1153
 4004724:	10abdc04 	addi	r2,r2,-20624
 4004728:	1887883a 	add	r3,r3,r2
 400472c:	e0bffe17 	ldw	r2,-8(fp)
 4004730:	10800104 	addi	r2,r2,4
 4004734:	100b883a 	mov	r5,r2
 4004738:	1809883a 	mov	r4,r3
 400473c:	4000efc0 	call	4000efc <vListInsertEnd>
 4004740:	00000606 	br	400475c <xTaskRemoveFromEventList+0xb0>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 4004744:	e0bffe17 	ldw	r2,-8(fp)
 4004748:	10800604 	addi	r2,r2,24
 400474c:	100b883a 	mov	r5,r2
 4004750:	01012074 	movhi	r4,1153
 4004754:	212bff04 	addi	r4,r4,-20484
 4004758:	4000efc0 	call	4000efc <vListInsertEnd>
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 400475c:	e0bffe17 	ldw	r2,-8(fp)
 4004760:	10800b17 	ldw	r2,44(r2)
 4004764:	d0e5a517 	ldw	r3,-26988(gp)
 4004768:	18c00b17 	ldw	r3,44(r3)
 400476c:	1880052e 	bgeu	r3,r2,4004784 <xTaskRemoveFromEventList+0xd8>
    {
        /* Return true if the task removed from the event list has a higher
         * priority than the calling task.  This allows the calling task to know if
         * it should force a context switch now. */
        xReturn = pdTRUE;
 4004770:	00800044 	movi	r2,1
 4004774:	e0bfff15 	stw	r2,-4(fp)

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
 4004778:	00800044 	movi	r2,1
 400477c:	d0a5ae15 	stw	r2,-26952(gp)
 4004780:	00000106 	br	4004788 <xTaskRemoveFromEventList+0xdc>
    }
    else
    {
        xReturn = pdFALSE;
 4004784:	e03fff15 	stw	zero,-4(fp)
    }

    return xReturn;
 4004788:	e0bfff17 	ldw	r2,-4(fp)
}
 400478c:	e037883a 	mov	sp,fp
 4004790:	dfc00117 	ldw	ra,4(sp)
 4004794:	df000017 	ldw	fp,0(sp)
 4004798:	dec00204 	addi	sp,sp,8
 400479c:	f800283a 	ret

040047a0 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
                                        const TickType_t xItemValue )
{
 40047a0:	defffb04 	addi	sp,sp,-20
 40047a4:	dfc00415 	stw	ra,16(sp)
 40047a8:	df000315 	stw	fp,12(sp)
 40047ac:	df000304 	addi	fp,sp,12
 40047b0:	e13ffe15 	stw	r4,-8(fp)
 40047b4:	e17ffd15 	stw	r5,-12(fp)
    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event flags implementation. */
    configASSERT( uxSchedulerSuspended != pdFALSE );

    /* Store the new item value in the event list. */
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 40047b8:	e0bffd17 	ldw	r2,-12(fp)
 40047bc:	10e00034 	orhi	r3,r2,32768
 40047c0:	e0bffe17 	ldw	r2,-8(fp)
 40047c4:	10c00015 	stw	r3,0(r2)

    /* Remove the event list form the event flag.  Interrupts do not access
     * event flags. */
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 40047c8:	e0bffe17 	ldw	r2,-8(fp)
 40047cc:	10800317 	ldw	r2,12(r2)
 40047d0:	e0bfff15 	stw	r2,-4(fp)
    configASSERT( pxUnblockedTCB );
    ( void ) uxListRemove( pxEventListItem );
 40047d4:	e13ffe17 	ldw	r4,-8(fp)
 40047d8:	40010600 	call	4001060 <uxListRemove>
    #endif

    /* Remove the task from the delayed list and add it to the ready list.  The
     * scheduler is suspended so interrupts will not be accessing the ready
     * lists. */
    ( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 40047dc:	e0bfff17 	ldw	r2,-4(fp)
 40047e0:	10800104 	addi	r2,r2,4
 40047e4:	1009883a 	mov	r4,r2
 40047e8:	40010600 	call	4001060 <uxListRemove>
    prvAddTaskToReadyList( pxUnblockedTCB );
 40047ec:	e0bfff17 	ldw	r2,-4(fp)
 40047f0:	10800b17 	ldw	r2,44(r2)
 40047f4:	d0e5ab17 	ldw	r3,-26964(gp)
 40047f8:	1880032e 	bgeu	r3,r2,4004808 <vTaskRemoveFromUnorderedEventList+0x68>
 40047fc:	e0bfff17 	ldw	r2,-4(fp)
 4004800:	10800b17 	ldw	r2,44(r2)
 4004804:	d0a5ab15 	stw	r2,-26964(gp)
 4004808:	e0bfff17 	ldw	r2,-4(fp)
 400480c:	10800b17 	ldw	r2,44(r2)
 4004810:	10c00524 	muli	r3,r2,20
 4004814:	00812074 	movhi	r2,1153
 4004818:	10abdc04 	addi	r2,r2,-20624
 400481c:	1887883a 	add	r3,r3,r2
 4004820:	e0bfff17 	ldw	r2,-4(fp)
 4004824:	10800104 	addi	r2,r2,4
 4004828:	100b883a 	mov	r5,r2
 400482c:	1809883a 	mov	r4,r3
 4004830:	4000efc0 	call	4000efc <vListInsertEnd>

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 4004834:	e0bfff17 	ldw	r2,-4(fp)
 4004838:	10800b17 	ldw	r2,44(r2)
 400483c:	d0e5a517 	ldw	r3,-26988(gp)
 4004840:	18c00b17 	ldw	r3,44(r3)
 4004844:	1880022e 	bgeu	r3,r2,4004850 <vTaskRemoveFromUnorderedEventList+0xb0>
    {
        /* The unblocked task has a priority above that of the calling task, so
         * a context switch is required.  This function is called with the
         * scheduler suspended so xYieldPending is set so the context switch
         * occurs immediately that the scheduler is resumed (unsuspended). */
        xYieldPending = pdTRUE;
 4004848:	00800044 	movi	r2,1
 400484c:	d0a5ae15 	stw	r2,-26952(gp)
    }
}
 4004850:	0001883a 	nop
 4004854:	e037883a 	mov	sp,fp
 4004858:	dfc00117 	ldw	ra,4(sp)
 400485c:	df000017 	ldw	fp,0(sp)
 4004860:	dec00204 	addi	sp,sp,8
 4004864:	f800283a 	ret

04004868 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
 4004868:	defffd04 	addi	sp,sp,-12
 400486c:	dfc00215 	stw	ra,8(sp)
 4004870:	df000115 	stw	fp,4(sp)
 4004874:	df000104 	addi	fp,sp,4
 4004878:	e13fff15 	stw	r4,-4(fp)
    configASSERT( pxTimeOut );
    taskENTER_CRITICAL();
 400487c:	40050480 	call	4005048 <vTaskEnterCritical>
    {
        pxTimeOut->xOverflowCount = xNumOfOverflows;
 4004880:	d0e5af17 	ldw	r3,-26948(gp)
 4004884:	e0bfff17 	ldw	r2,-4(fp)
 4004888:	10c00015 	stw	r3,0(r2)
        pxTimeOut->xTimeOnEntering = xTickCount;
 400488c:	d0e5aa17 	ldw	r3,-26968(gp)
 4004890:	e0bfff17 	ldw	r2,-4(fp)
 4004894:	10c00115 	stw	r3,4(r2)
    }
    taskEXIT_CRITICAL();
 4004898:	400509c0 	call	400509c <vTaskExitCritical>
}
 400489c:	0001883a 	nop
 40048a0:	e037883a 	mov	sp,fp
 40048a4:	dfc00117 	ldw	ra,4(sp)
 40048a8:	df000017 	ldw	fp,0(sp)
 40048ac:	dec00204 	addi	sp,sp,8
 40048b0:	f800283a 	ret

040048b4 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
 40048b4:	defffe04 	addi	sp,sp,-8
 40048b8:	df000115 	stw	fp,4(sp)
 40048bc:	df000104 	addi	fp,sp,4
 40048c0:	e13fff15 	stw	r4,-4(fp)
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
 40048c4:	d0e5af17 	ldw	r3,-26948(gp)
 40048c8:	e0bfff17 	ldw	r2,-4(fp)
 40048cc:	10c00015 	stw	r3,0(r2)
    pxTimeOut->xTimeOnEntering = xTickCount;
 40048d0:	d0e5aa17 	ldw	r3,-26968(gp)
 40048d4:	e0bfff17 	ldw	r2,-4(fp)
 40048d8:	10c00115 	stw	r3,4(r2)
}
 40048dc:	0001883a 	nop
 40048e0:	e037883a 	mov	sp,fp
 40048e4:	df000017 	ldw	fp,0(sp)
 40048e8:	dec00104 	addi	sp,sp,4
 40048ec:	f800283a 	ret

040048f0 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
 40048f0:	defff904 	addi	sp,sp,-28
 40048f4:	dfc00615 	stw	ra,24(sp)
 40048f8:	df000515 	stw	fp,20(sp)
 40048fc:	df000504 	addi	fp,sp,20
 4004900:	e13ffc15 	stw	r4,-16(fp)
 4004904:	e17ffb15 	stw	r5,-20(fp)
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );

    taskENTER_CRITICAL();
 4004908:	40050480 	call	4005048 <vTaskEnterCritical>
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
 400490c:	d0a5aa17 	ldw	r2,-26968(gp)
 4004910:	e0bffe15 	stw	r2,-8(fp)
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 4004914:	e0bffc17 	ldw	r2,-16(fp)
 4004918:	10800117 	ldw	r2,4(r2)
 400491c:	e0fffe17 	ldw	r3,-8(fp)
 4004920:	1885c83a 	sub	r2,r3,r2
 4004924:	e0bffd15 	stw	r2,-12(fp)
            }
            else
        #endif

        #if ( INCLUDE_vTaskSuspend == 1 )
            if( *pxTicksToWait == portMAX_DELAY )
 4004928:	e0bffb17 	ldw	r2,-20(fp)
 400492c:	10800017 	ldw	r2,0(r2)
 4004930:	10bfffd8 	cmpnei	r2,r2,-1
 4004934:	1000021e 	bne	r2,zero,4004940 <xTaskCheckForTimeOut+0x50>
            {
                /* If INCLUDE_vTaskSuspend is set to 1 and the block time
                 * specified is the maximum block time then the task should block
                 * indefinitely, and therefore never time out. */
                xReturn = pdFALSE;
 4004938:	e03fff15 	stw	zero,-4(fp)
 400493c:	00001f06 	br	40049bc <xTaskCheckForTimeOut+0xcc>
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 4004940:	e0bffc17 	ldw	r2,-16(fp)
 4004944:	10c00017 	ldw	r3,0(r2)
 4004948:	d0a5af17 	ldw	r2,-26948(gp)
 400494c:	18800926 	beq	r3,r2,4004974 <xTaskCheckForTimeOut+0x84>
 4004950:	e0bffc17 	ldw	r2,-16(fp)
 4004954:	10800117 	ldw	r2,4(r2)
 4004958:	e0fffe17 	ldw	r3,-8(fp)
 400495c:	18800536 	bltu	r3,r2,4004974 <xTaskCheckForTimeOut+0x84>
            /* The tick count is greater than the time at which
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
 4004960:	00800044 	movi	r2,1
 4004964:	e0bfff15 	stw	r2,-4(fp)
            *pxTicksToWait = ( TickType_t ) 0;
 4004968:	e0bffb17 	ldw	r2,-20(fp)
 400496c:	10000015 	stw	zero,0(r2)
 4004970:	00001206 	br	40049bc <xTaskCheckForTimeOut+0xcc>
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 4004974:	e0bffb17 	ldw	r2,-20(fp)
 4004978:	10800017 	ldw	r2,0(r2)
 400497c:	e0fffd17 	ldw	r3,-12(fp)
 4004980:	18800a2e 	bgeu	r3,r2,40049ac <xTaskCheckForTimeOut+0xbc>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
 4004984:	e0bffb17 	ldw	r2,-20(fp)
 4004988:	10c00017 	ldw	r3,0(r2)
 400498c:	e0bffd17 	ldw	r2,-12(fp)
 4004990:	1887c83a 	sub	r3,r3,r2
 4004994:	e0bffb17 	ldw	r2,-20(fp)
 4004998:	10c00015 	stw	r3,0(r2)
            vTaskInternalSetTimeOutState( pxTimeOut );
 400499c:	e13ffc17 	ldw	r4,-16(fp)
 40049a0:	40048b40 	call	40048b4 <vTaskInternalSetTimeOutState>
            xReturn = pdFALSE;
 40049a4:	e03fff15 	stw	zero,-4(fp)
 40049a8:	00000406 	br	40049bc <xTaskCheckForTimeOut+0xcc>
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
 40049ac:	e0bffb17 	ldw	r2,-20(fp)
 40049b0:	10000015 	stw	zero,0(r2)
            xReturn = pdTRUE;
 40049b4:	00800044 	movi	r2,1
 40049b8:	e0bfff15 	stw	r2,-4(fp)
        }
    }
    taskEXIT_CRITICAL();
 40049bc:	400509c0 	call	400509c <vTaskExitCritical>

    return xReturn;
 40049c0:	e0bfff17 	ldw	r2,-4(fp)
}
 40049c4:	e037883a 	mov	sp,fp
 40049c8:	dfc00117 	ldw	ra,4(sp)
 40049cc:	df000017 	ldw	fp,0(sp)
 40049d0:	dec00204 	addi	sp,sp,8
 40049d4:	f800283a 	ret

040049d8 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
 40049d8:	deffff04 	addi	sp,sp,-4
 40049dc:	df000015 	stw	fp,0(sp)
 40049e0:	d839883a 	mov	fp,sp
    xYieldPending = pdTRUE;
 40049e4:	00800044 	movi	r2,1
 40049e8:	d0a5ae15 	stw	r2,-26952(gp)
}
 40049ec:	0001883a 	nop
 40049f0:	e037883a 	mov	sp,fp
 40049f4:	df000017 	ldw	fp,0(sp)
 40049f8:	dec00104 	addi	sp,sp,4
 40049fc:	f800283a 	ret

04004a00 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 4004a00:	defffd04 	addi	sp,sp,-12
 4004a04:	dfc00215 	stw	ra,8(sp)
 4004a08:	df000115 	stw	fp,4(sp)
 4004a0c:	df000104 	addi	fp,sp,4
 4004a10:	e13fff15 	stw	r4,-4(fp)

    for( ; ; )
    {
        /* See if any tasks have deleted themselves - if so then the idle task
         * is responsible for freeing the deleted task's TCB and stack. */
        prvCheckTasksWaitingTermination();
 4004a14:	4004ad40 	call	4004ad4 <prvCheckTasksWaitingTermination>
 4004a18:	003ffe06 	br	4004a14 <prvIdleTask+0x14>

04004a1c <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
 4004a1c:	defffd04 	addi	sp,sp,-12
 4004a20:	dfc00215 	stw	ra,8(sp)
 4004a24:	df000115 	stw	fp,4(sp)
 4004a28:	df000104 	addi	fp,sp,4
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 4004a2c:	e03fff15 	stw	zero,-4(fp)
 4004a30:	00000a06 	br	4004a5c <prvInitialiseTaskLists+0x40>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 4004a34:	e0bfff17 	ldw	r2,-4(fp)
 4004a38:	10c00524 	muli	r3,r2,20
 4004a3c:	00812074 	movhi	r2,1153
 4004a40:	10abdc04 	addi	r2,r2,-20624
 4004a44:	1885883a 	add	r2,r3,r2
 4004a48:	1009883a 	mov	r4,r2
 4004a4c:	4000e680 	call	4000e68 <vListInitialise>
    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 4004a50:	e0bfff17 	ldw	r2,-4(fp)
 4004a54:	10800044 	addi	r2,r2,1
 4004a58:	e0bfff15 	stw	r2,-4(fp)
 4004a5c:	e0bfff17 	ldw	r2,-4(fp)
 4004a60:	10800170 	cmpltui	r2,r2,5
 4004a64:	103ff31e 	bne	r2,zero,4004a34 <prvInitialiseTaskLists+0x18>
    }

    vListInitialise( &xDelayedTaskList1 );
 4004a68:	01012074 	movhi	r4,1153
 4004a6c:	212bf504 	addi	r4,r4,-20524
 4004a70:	4000e680 	call	4000e68 <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
 4004a74:	01012074 	movhi	r4,1153
 4004a78:	212bfa04 	addi	r4,r4,-20504
 4004a7c:	4000e680 	call	4000e68 <vListInitialise>
    vListInitialise( &xPendingReadyList );
 4004a80:	01012074 	movhi	r4,1153
 4004a84:	212bff04 	addi	r4,r4,-20484
 4004a88:	4000e680 	call	4000e68 <vListInitialise>

    #if ( INCLUDE_vTaskDelete == 1 )
        {
            vListInitialise( &xTasksWaitingTermination );
 4004a8c:	01012074 	movhi	r4,1153
 4004a90:	212c0404 	addi	r4,r4,-20464
 4004a94:	4000e680 	call	4000e68 <vListInitialise>
        }
    #endif /* INCLUDE_vTaskDelete */

    #if ( INCLUDE_vTaskSuspend == 1 )
        {
            vListInitialise( &xSuspendedTaskList );
 4004a98:	01012074 	movhi	r4,1153
 4004a9c:	212c0904 	addi	r4,r4,-20444
 4004aa0:	4000e680 	call	4000e68 <vListInitialise>
        }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
 4004aa4:	00812074 	movhi	r2,1153
 4004aa8:	10abf504 	addi	r2,r2,-20524
 4004aac:	d0a5a615 	stw	r2,-26984(gp)
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
 4004ab0:	00812074 	movhi	r2,1153
 4004ab4:	10abfa04 	addi	r2,r2,-20504
 4004ab8:	d0a5a715 	stw	r2,-26980(gp)
}
 4004abc:	0001883a 	nop
 4004ac0:	e037883a 	mov	sp,fp
 4004ac4:	dfc00117 	ldw	ra,4(sp)
 4004ac8:	df000017 	ldw	fp,0(sp)
 4004acc:	dec00204 	addi	sp,sp,8
 4004ad0:	f800283a 	ret

04004ad4 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
 4004ad4:	defffd04 	addi	sp,sp,-12
 4004ad8:	dfc00215 	stw	ra,8(sp)
 4004adc:	df000115 	stw	fp,4(sp)
 4004ae0:	df000104 	addi	fp,sp,4
        {
            TCB_t * pxTCB;

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 4004ae4:	00001206 	br	4004b30 <prvCheckTasksWaitingTermination+0x5c>
            {
                taskENTER_CRITICAL();
 4004ae8:	40050480 	call	4005048 <vTaskEnterCritical>
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 4004aec:	00812074 	movhi	r2,1153
 4004af0:	10ac0717 	ldw	r2,-20452(r2)
 4004af4:	10800317 	ldw	r2,12(r2)
 4004af8:	e0bfff15 	stw	r2,-4(fp)
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 4004afc:	e0bfff17 	ldw	r2,-4(fp)
 4004b00:	10800104 	addi	r2,r2,4
 4004b04:	1009883a 	mov	r4,r2
 4004b08:	40010600 	call	4001060 <uxListRemove>
                    --uxCurrentNumberOfTasks;
 4004b0c:	d0a5a917 	ldw	r2,-26972(gp)
 4004b10:	10bfffc4 	addi	r2,r2,-1
 4004b14:	d0a5a915 	stw	r2,-26972(gp)
                    --uxDeletedTasksWaitingCleanUp;
 4004b18:	d0a5a817 	ldw	r2,-26976(gp)
 4004b1c:	10bfffc4 	addi	r2,r2,-1
 4004b20:	d0a5a815 	stw	r2,-26976(gp)
                }
                taskEXIT_CRITICAL();
 4004b24:	400509c0 	call	400509c <vTaskExitCritical>

                prvDeleteTCB( pxTCB );
 4004b28:	e13fff17 	ldw	r4,-4(fp)
 4004b2c:	4004c180 	call	4004c18 <prvDeleteTCB>
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 4004b30:	d0a5a817 	ldw	r2,-26976(gp)
 4004b34:	103fec1e 	bne	r2,zero,4004ae8 <prvCheckTasksWaitingTermination+0x14>
            }
        }
    #endif /* INCLUDE_vTaskDelete */
}
 4004b38:	0001883a 	nop
 4004b3c:	0001883a 	nop
 4004b40:	e037883a 	mov	sp,fp
 4004b44:	dfc00117 	ldw	ra,4(sp)
 4004b48:	df000017 	ldw	fp,0(sp)
 4004b4c:	dec00204 	addi	sp,sp,8
 4004b50:	f800283a 	ret

04004b54 <prvTaskCheckFreeStackSpace>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) )

    static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
    {
 4004b54:	defffd04 	addi	sp,sp,-12
 4004b58:	df000215 	stw	fp,8(sp)
 4004b5c:	df000204 	addi	fp,sp,8
 4004b60:	e13ffe15 	stw	r4,-8(fp)
        uint32_t ulCount = 0U;
 4004b64:	e03fff15 	stw	zero,-4(fp)

        while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 4004b68:	00000606 	br	4004b84 <prvTaskCheckFreeStackSpace+0x30>
        {
            pucStackByte -= portSTACK_GROWTH;
 4004b6c:	e0bffe17 	ldw	r2,-8(fp)
 4004b70:	10800044 	addi	r2,r2,1
 4004b74:	e0bffe15 	stw	r2,-8(fp)
            ulCount++;
 4004b78:	e0bfff17 	ldw	r2,-4(fp)
 4004b7c:	10800044 	addi	r2,r2,1
 4004b80:	e0bfff15 	stw	r2,-4(fp)
        while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 4004b84:	e0bffe17 	ldw	r2,-8(fp)
 4004b88:	10800003 	ldbu	r2,0(r2)
 4004b8c:	10803fcc 	andi	r2,r2,255
 4004b90:	10802960 	cmpeqi	r2,r2,165
 4004b94:	103ff51e 	bne	r2,zero,4004b6c <prvTaskCheckFreeStackSpace+0x18>
        }

        ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
 4004b98:	e0bfff17 	ldw	r2,-4(fp)
 4004b9c:	1004d0ba 	srli	r2,r2,2
 4004ba0:	e0bfff15 	stw	r2,-4(fp)

        return ( configSTACK_DEPTH_TYPE ) ulCount;
 4004ba4:	e0bfff17 	ldw	r2,-4(fp)
    }
 4004ba8:	e037883a 	mov	sp,fp
 4004bac:	df000017 	ldw	fp,0(sp)
 4004bb0:	dec00104 	addi	sp,sp,4
 4004bb4:	f800283a 	ret

04004bb8 <uxTaskGetStackHighWaterMark>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )

    UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
    {
 4004bb8:	defffa04 	addi	sp,sp,-24
 4004bbc:	dfc00515 	stw	ra,20(sp)
 4004bc0:	df000415 	stw	fp,16(sp)
 4004bc4:	df000404 	addi	fp,sp,16
 4004bc8:	e13ffc15 	stw	r4,-16(fp)
        TCB_t * pxTCB;
        uint8_t * pucEndOfStack;
        UBaseType_t uxReturn;

        pxTCB = prvGetTCBFromHandle( xTask );
 4004bcc:	e0bffc17 	ldw	r2,-16(fp)
 4004bd0:	1000021e 	bne	r2,zero,4004bdc <uxTaskGetStackHighWaterMark+0x24>
 4004bd4:	d0a5a517 	ldw	r2,-26988(gp)
 4004bd8:	00000106 	br	4004be0 <uxTaskGetStackHighWaterMark+0x28>
 4004bdc:	e0bffc17 	ldw	r2,-16(fp)
 4004be0:	e0bfff15 	stw	r2,-4(fp)

        #if portSTACK_GROWTH < 0
            {
                pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
 4004be4:	e0bfff17 	ldw	r2,-4(fp)
 4004be8:	10800c17 	ldw	r2,48(r2)
 4004bec:	e0bffe15 	stw	r2,-8(fp)
            {
                pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
            }
        #endif

        uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
 4004bf0:	e13ffe17 	ldw	r4,-8(fp)
 4004bf4:	4004b540 	call	4004b54 <prvTaskCheckFreeStackSpace>
 4004bf8:	10bfffcc 	andi	r2,r2,65535
 4004bfc:	e0bffd15 	stw	r2,-12(fp)

        return uxReturn;
 4004c00:	e0bffd17 	ldw	r2,-12(fp)
    }
 4004c04:	e037883a 	mov	sp,fp
 4004c08:	dfc00117 	ldw	ra,4(sp)
 4004c0c:	df000017 	ldw	fp,0(sp)
 4004c10:	dec00204 	addi	sp,sp,8
 4004c14:	f800283a 	ret

04004c18 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    static void prvDeleteTCB( TCB_t * pxTCB )
    {
 4004c18:	defffd04 	addi	sp,sp,-12
 4004c1c:	dfc00215 	stw	ra,8(sp)
 4004c20:	df000115 	stw	fp,4(sp)
 4004c24:	df000104 	addi	fp,sp,4
 4004c28:	e13fff15 	stw	r4,-4(fp)

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
            {
                /* The task can only have been allocated dynamically - free both
                 * the stack and TCB. */
                vPortFree( pxTCB->pxStack );
 4004c2c:	e0bfff17 	ldw	r2,-4(fp)
 4004c30:	10800c17 	ldw	r2,48(r2)
 4004c34:	1009883a 	mov	r4,r2
 4004c38:	40006f40 	call	40006f4 <vPortFree>
                vPortFree( pxTCB );
 4004c3c:	e13fff17 	ldw	r4,-4(fp)
 4004c40:	40006f40 	call	40006f4 <vPortFree>
                    configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
 4004c44:	0001883a 	nop
 4004c48:	e037883a 	mov	sp,fp
 4004c4c:	dfc00117 	ldw	ra,4(sp)
 4004c50:	df000017 	ldw	fp,0(sp)
 4004c54:	dec00204 	addi	sp,sp,8
 4004c58:	f800283a 	ret

04004c5c <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
 4004c5c:	deffff04 	addi	sp,sp,-4
 4004c60:	df000015 	stw	fp,0(sp)
 4004c64:	d839883a 	mov	fp,sp
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 4004c68:	d0a5a617 	ldw	r2,-26984(gp)
 4004c6c:	10800017 	ldw	r2,0(r2)
 4004c70:	1000031e 	bne	r2,zero,4004c80 <prvResetNextTaskUnblockTime+0x24>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
 4004c74:	00bfffc4 	movi	r2,-1
 4004c78:	d0a5b115 	stw	r2,-26940(gp)
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    }
}
 4004c7c:	00000406 	br	4004c90 <prvResetNextTaskUnblockTime+0x34>
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
 4004c80:	d0a5a617 	ldw	r2,-26984(gp)
 4004c84:	10800317 	ldw	r2,12(r2)
 4004c88:	10800017 	ldw	r2,0(r2)
 4004c8c:	d0a5b115 	stw	r2,-26940(gp)
}
 4004c90:	0001883a 	nop
 4004c94:	e037883a 	mov	sp,fp
 4004c98:	df000017 	ldw	fp,0(sp)
 4004c9c:	dec00104 	addi	sp,sp,4
 4004ca0:	f800283a 	ret

04004ca4 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

    TaskHandle_t xTaskGetCurrentTaskHandle( void )
    {
 4004ca4:	defffe04 	addi	sp,sp,-8
 4004ca8:	df000115 	stw	fp,4(sp)
 4004cac:	df000104 	addi	fp,sp,4
        TaskHandle_t xReturn;

        /* A critical section is not required as this is not called from
         * an interrupt and the current TCB will always be the same for any
         * individual execution thread. */
        xReturn = pxCurrentTCB;
 4004cb0:	d0a5a517 	ldw	r2,-26988(gp)
 4004cb4:	e0bfff15 	stw	r2,-4(fp)

        return xReturn;
 4004cb8:	e0bfff17 	ldw	r2,-4(fp)
    }
 4004cbc:	e037883a 	mov	sp,fp
 4004cc0:	df000017 	ldw	fp,0(sp)
 4004cc4:	dec00104 	addi	sp,sp,4
 4004cc8:	f800283a 	ret

04004ccc <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
    {
 4004ccc:	defffb04 	addi	sp,sp,-20
 4004cd0:	dfc00415 	stw	ra,16(sp)
 4004cd4:	df000315 	stw	fp,12(sp)
 4004cd8:	df000304 	addi	fp,sp,12
 4004cdc:	e13ffd15 	stw	r4,-12(fp)
        TCB_t * const pxMutexHolderTCB = pxMutexHolder;
 4004ce0:	e0bffd17 	ldw	r2,-12(fp)
 4004ce4:	e0bffe15 	stw	r2,-8(fp)
        BaseType_t xReturn = pdFALSE;
 4004ce8:	e03fff15 	stw	zero,-4(fp)

        /* If the mutex was given back by an interrupt while the queue was
         * locked then the mutex holder might now be NULL.  _RB_ Is this still
         * needed as interrupts can no longer use mutexes? */
        if( pxMutexHolder != NULL )
 4004cec:	e0bffd17 	ldw	r2,-12(fp)
 4004cf0:	10004026 	beq	r2,zero,4004df4 <xTaskPriorityInherit+0x128>
        {
            /* If the holder of the mutex has a priority below the priority of
             * the task attempting to obtain the mutex then it will temporarily
             * inherit the priority of the task attempting to obtain the mutex. */
            if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
 4004cf4:	e0bffe17 	ldw	r2,-8(fp)
 4004cf8:	10c00b17 	ldw	r3,44(r2)
 4004cfc:	d0a5a517 	ldw	r2,-26988(gp)
 4004d00:	10800b17 	ldw	r2,44(r2)
 4004d04:	1880342e 	bgeu	r3,r2,4004dd8 <xTaskPriorityInherit+0x10c>
            {
                /* Adjust the mutex holder state to account for its new
                 * priority.  Only reset the event list item value if the value is
                 * not being used for anything else. */
                if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 4004d08:	e0bffe17 	ldw	r2,-8(fp)
 4004d0c:	10800617 	ldw	r2,24(r2)
 4004d10:	10000616 	blt	r2,zero,4004d2c <xTaskPriorityInherit+0x60>
                {
                    listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 4004d14:	d0a5a517 	ldw	r2,-26988(gp)
 4004d18:	10800b17 	ldw	r2,44(r2)
 4004d1c:	00c00144 	movi	r3,5
 4004d20:	1887c83a 	sub	r3,r3,r2
 4004d24:	e0bffe17 	ldw	r2,-8(fp)
 4004d28:	10c00615 	stw	r3,24(r2)
                    mtCOVERAGE_TEST_MARKER();
                }

                /* If the task being modified is in the ready state it will need
                 * to be moved into a new list. */
                if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
 4004d2c:	e0bffe17 	ldw	r2,-8(fp)
 4004d30:	10c00517 	ldw	r3,20(r2)
 4004d34:	e0bffe17 	ldw	r2,-8(fp)
 4004d38:	10800b17 	ldw	r2,44(r2)
 4004d3c:	11000524 	muli	r4,r2,20
 4004d40:	00812074 	movhi	r2,1153
 4004d44:	10abdc04 	addi	r2,r2,-20624
 4004d48:	2085883a 	add	r2,r4,r2
 4004d4c:	18801b1e 	bne	r3,r2,4004dbc <xTaskPriorityInherit+0xf0>
                {
                    if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 4004d50:	e0bffe17 	ldw	r2,-8(fp)
 4004d54:	10800104 	addi	r2,r2,4
 4004d58:	1009883a 	mov	r4,r2
 4004d5c:	40010600 	call	4001060 <uxListRemove>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Inherit the priority before being moved into the new list. */
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 4004d60:	d0a5a517 	ldw	r2,-26988(gp)
 4004d64:	10c00b17 	ldw	r3,44(r2)
 4004d68:	e0bffe17 	ldw	r2,-8(fp)
 4004d6c:	10c00b15 	stw	r3,44(r2)
                    prvAddTaskToReadyList( pxMutexHolderTCB );
 4004d70:	e0bffe17 	ldw	r2,-8(fp)
 4004d74:	10800b17 	ldw	r2,44(r2)
 4004d78:	d0e5ab17 	ldw	r3,-26964(gp)
 4004d7c:	1880032e 	bgeu	r3,r2,4004d8c <xTaskPriorityInherit+0xc0>
 4004d80:	e0bffe17 	ldw	r2,-8(fp)
 4004d84:	10800b17 	ldw	r2,44(r2)
 4004d88:	d0a5ab15 	stw	r2,-26964(gp)
 4004d8c:	e0bffe17 	ldw	r2,-8(fp)
 4004d90:	10800b17 	ldw	r2,44(r2)
 4004d94:	10c00524 	muli	r3,r2,20
 4004d98:	00812074 	movhi	r2,1153
 4004d9c:	10abdc04 	addi	r2,r2,-20624
 4004da0:	1887883a 	add	r3,r3,r2
 4004da4:	e0bffe17 	ldw	r2,-8(fp)
 4004da8:	10800104 	addi	r2,r2,4
 4004dac:	100b883a 	mov	r5,r2
 4004db0:	1809883a 	mov	r4,r3
 4004db4:	4000efc0 	call	4000efc <vListInsertEnd>
 4004db8:	00000406 	br	4004dcc <xTaskPriorityInherit+0x100>
                }
                else
                {
                    /* Just inherit the priority. */
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 4004dbc:	d0a5a517 	ldw	r2,-26988(gp)
 4004dc0:	10c00b17 	ldw	r3,44(r2)
 4004dc4:	e0bffe17 	ldw	r2,-8(fp)
 4004dc8:	10c00b15 	stw	r3,44(r2)
                }

                traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

                /* Inheritance occurred. */
                xReturn = pdTRUE;
 4004dcc:	00800044 	movi	r2,1
 4004dd0:	e0bfff15 	stw	r2,-4(fp)
 4004dd4:	00000706 	br	4004df4 <xTaskPriorityInherit+0x128>
            }
            else
            {
                if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
 4004dd8:	e0bffe17 	ldw	r2,-8(fp)
 4004ddc:	10c01017 	ldw	r3,64(r2)
 4004de0:	d0a5a517 	ldw	r2,-26988(gp)
 4004de4:	10800b17 	ldw	r2,44(r2)
 4004de8:	1880022e 	bgeu	r3,r2,4004df4 <xTaskPriorityInherit+0x128>
                     * current priority of the mutex holder is not lower than the
                     * priority of the task attempting to take the mutex.
                     * Therefore the mutex holder must have already inherited a
                     * priority, but inheritance would have occurred if that had
                     * not been the case. */
                    xReturn = pdTRUE;
 4004dec:	00800044 	movi	r2,1
 4004df0:	e0bfff15 	stw	r2,-4(fp)
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
 4004df4:	e0bfff17 	ldw	r2,-4(fp)
    }
 4004df8:	e037883a 	mov	sp,fp
 4004dfc:	dfc00117 	ldw	ra,4(sp)
 4004e00:	df000017 	ldw	fp,0(sp)
 4004e04:	dec00204 	addi	sp,sp,8
 4004e08:	f800283a 	ret

04004e0c <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
 4004e0c:	defffb04 	addi	sp,sp,-20
 4004e10:	dfc00415 	stw	ra,16(sp)
 4004e14:	df000315 	stw	fp,12(sp)
 4004e18:	df000304 	addi	fp,sp,12
 4004e1c:	e13ffd15 	stw	r4,-12(fp)
        TCB_t * const pxTCB = pxMutexHolder;
 4004e20:	e0bffd17 	ldw	r2,-12(fp)
 4004e24:	e0bffe15 	stw	r2,-8(fp)
        BaseType_t xReturn = pdFALSE;
 4004e28:	e03fff15 	stw	zero,-4(fp)

        if( pxMutexHolder != NULL )
 4004e2c:	e0bffd17 	ldw	r2,-12(fp)
 4004e30:	10002f26 	beq	r2,zero,4004ef0 <xTaskPriorityDisinherit+0xe4>
             * If the mutex is held by a task then it cannot be given from an
             * interrupt, and if a mutex is given by the holding task then it must
             * be the running state task. */
            configASSERT( pxTCB == pxCurrentTCB );
            configASSERT( pxTCB->uxMutexesHeld );
            ( pxTCB->uxMutexesHeld )--;
 4004e34:	e0bffe17 	ldw	r2,-8(fp)
 4004e38:	10801117 	ldw	r2,68(r2)
 4004e3c:	10ffffc4 	addi	r3,r2,-1
 4004e40:	e0bffe17 	ldw	r2,-8(fp)
 4004e44:	10c01115 	stw	r3,68(r2)

            /* Has the holder of the mutex inherited the priority of another
             * task? */
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 4004e48:	e0bffe17 	ldw	r2,-8(fp)
 4004e4c:	10c00b17 	ldw	r3,44(r2)
 4004e50:	e0bffe17 	ldw	r2,-8(fp)
 4004e54:	10801017 	ldw	r2,64(r2)
 4004e58:	18802526 	beq	r3,r2,4004ef0 <xTaskPriorityDisinherit+0xe4>
            {
                /* Only disinherit if no other mutexes are held. */
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 4004e5c:	e0bffe17 	ldw	r2,-8(fp)
 4004e60:	10801117 	ldw	r2,68(r2)
 4004e64:	1000221e 	bne	r2,zero,4004ef0 <xTaskPriorityDisinherit+0xe4>
                    /* A task can only have an inherited priority if it holds
                     * the mutex.  If the mutex is held by a task then it cannot be
                     * given from an interrupt, and if a mutex is given by the
                     * holding task then it must be the running state task.  Remove
                     * the holding task from the ready list. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 4004e68:	e0bffe17 	ldw	r2,-8(fp)
 4004e6c:	10800104 	addi	r2,r2,4
 4004e70:	1009883a 	mov	r4,r2
 4004e74:	40010600 	call	4001060 <uxListRemove>
                    }

                    /* Disinherit the priority before adding the task into the
                     * new  ready list. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
 4004e78:	e0bffe17 	ldw	r2,-8(fp)
 4004e7c:	10c01017 	ldw	r3,64(r2)
 4004e80:	e0bffe17 	ldw	r2,-8(fp)
 4004e84:	10c00b15 	stw	r3,44(r2)

                    /* Reset the event list item value.  It cannot be in use for
                     * any other purpose if this task is running, and it must be
                     * running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 4004e88:	e0bffe17 	ldw	r2,-8(fp)
 4004e8c:	10800b17 	ldw	r2,44(r2)
 4004e90:	00c00144 	movi	r3,5
 4004e94:	1887c83a 	sub	r3,r3,r2
 4004e98:	e0bffe17 	ldw	r2,-8(fp)
 4004e9c:	10c00615 	stw	r3,24(r2)
                    prvAddTaskToReadyList( pxTCB );
 4004ea0:	e0bffe17 	ldw	r2,-8(fp)
 4004ea4:	10800b17 	ldw	r2,44(r2)
 4004ea8:	d0e5ab17 	ldw	r3,-26964(gp)
 4004eac:	1880032e 	bgeu	r3,r2,4004ebc <xTaskPriorityDisinherit+0xb0>
 4004eb0:	e0bffe17 	ldw	r2,-8(fp)
 4004eb4:	10800b17 	ldw	r2,44(r2)
 4004eb8:	d0a5ab15 	stw	r2,-26964(gp)
 4004ebc:	e0bffe17 	ldw	r2,-8(fp)
 4004ec0:	10800b17 	ldw	r2,44(r2)
 4004ec4:	10c00524 	muli	r3,r2,20
 4004ec8:	00812074 	movhi	r2,1153
 4004ecc:	10abdc04 	addi	r2,r2,-20624
 4004ed0:	1887883a 	add	r3,r3,r2
 4004ed4:	e0bffe17 	ldw	r2,-8(fp)
 4004ed8:	10800104 	addi	r2,r2,4
 4004edc:	100b883a 	mov	r5,r2
 4004ee0:	1809883a 	mov	r4,r3
 4004ee4:	4000efc0 	call	4000efc <vListInsertEnd>
                     * in an order different to that in which they were taken.
                     * If a context switch did not occur when the first mutex was
                     * returned, even if a task was waiting on it, then a context
                     * switch should occur when the last mutex is returned whether
                     * a task is waiting on it or not. */
                    xReturn = pdTRUE;
 4004ee8:	00800044 	movi	r2,1
 4004eec:	e0bfff15 	stw	r2,-4(fp)
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
 4004ef0:	e0bfff17 	ldw	r2,-4(fp)
    }
 4004ef4:	e037883a 	mov	sp,fp
 4004ef8:	dfc00117 	ldw	ra,4(sp)
 4004efc:	df000017 	ldw	fp,0(sp)
 4004f00:	dec00204 	addi	sp,sp,8
 4004f04:	f800283a 	ret

04004f08 <vTaskPriorityDisinheritAfterTimeout>:

#if ( configUSE_MUTEXES == 1 )

    void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder,
                                              UBaseType_t uxHighestPriorityWaitingTask )
    {
 4004f08:	defff804 	addi	sp,sp,-32
 4004f0c:	dfc00715 	stw	ra,28(sp)
 4004f10:	df000615 	stw	fp,24(sp)
 4004f14:	df000604 	addi	fp,sp,24
 4004f18:	e13ffb15 	stw	r4,-20(fp)
 4004f1c:	e17ffa15 	stw	r5,-24(fp)
        TCB_t * const pxTCB = pxMutexHolder;
 4004f20:	e0bffb17 	ldw	r2,-20(fp)
 4004f24:	e0bffe15 	stw	r2,-8(fp)
        UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
        const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
 4004f28:	00800044 	movi	r2,1
 4004f2c:	e0bffd15 	stw	r2,-12(fp)

        if( pxMutexHolder != NULL )
 4004f30:	e0bffb17 	ldw	r2,-20(fp)
 4004f34:	10003e26 	beq	r2,zero,4005030 <vTaskPriorityDisinheritAfterTimeout+0x128>

            /* Determine the priority to which the priority of the task that
             * holds the mutex should be set.  This will be the greater of the
             * holding task's base priority and the priority of the highest
             * priority task that is waiting to obtain the mutex. */
            if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
 4004f38:	e0bffe17 	ldw	r2,-8(fp)
 4004f3c:	10c01017 	ldw	r3,64(r2)
 4004f40:	e0bffa17 	ldw	r2,-24(fp)
 4004f44:	1880032e 	bgeu	r3,r2,4004f54 <vTaskPriorityDisinheritAfterTimeout+0x4c>
            {
                uxPriorityToUse = uxHighestPriorityWaitingTask;
 4004f48:	e0bffa17 	ldw	r2,-24(fp)
 4004f4c:	e0bfff15 	stw	r2,-4(fp)
 4004f50:	00000306 	br	4004f60 <vTaskPriorityDisinheritAfterTimeout+0x58>
            }
            else
            {
                uxPriorityToUse = pxTCB->uxBasePriority;
 4004f54:	e0bffe17 	ldw	r2,-8(fp)
 4004f58:	10801017 	ldw	r2,64(r2)
 4004f5c:	e0bfff15 	stw	r2,-4(fp)
            }

            /* Does the priority need to change? */
            if( pxTCB->uxPriority != uxPriorityToUse )
 4004f60:	e0bffe17 	ldw	r2,-8(fp)
 4004f64:	10800b17 	ldw	r2,44(r2)
 4004f68:	e0ffff17 	ldw	r3,-4(fp)
 4004f6c:	18803026 	beq	r3,r2,4005030 <vTaskPriorityDisinheritAfterTimeout+0x128>
            {
                /* Only disinherit if no other mutexes are held.  This is a
                 * simplification in the priority inheritance implementation.  If
                 * the task that holds the mutex is also holding other mutexes then
                 * the other mutexes may have caused the priority inheritance. */
                if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
 4004f70:	e0bffe17 	ldw	r2,-8(fp)
 4004f74:	10801117 	ldw	r2,68(r2)
 4004f78:	e0fffd17 	ldw	r3,-12(fp)
 4004f7c:	18802c1e 	bne	r3,r2,4005030 <vTaskPriorityDisinheritAfterTimeout+0x128>

                    /* Disinherit the priority, remembering the previous
                     * priority to facilitate determining the subject task's
                     * state. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, uxPriorityToUse );
                    uxPriorityUsedOnEntry = pxTCB->uxPriority;
 4004f80:	e0bffe17 	ldw	r2,-8(fp)
 4004f84:	10800b17 	ldw	r2,44(r2)
 4004f88:	e0bffc15 	stw	r2,-16(fp)
                    pxTCB->uxPriority = uxPriorityToUse;
 4004f8c:	e0bffe17 	ldw	r2,-8(fp)
 4004f90:	e0ffff17 	ldw	r3,-4(fp)
 4004f94:	10c00b15 	stw	r3,44(r2)

                    /* Only reset the event list item value if the value is not
                     * being used for anything else. */
                    if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 4004f98:	e0bffe17 	ldw	r2,-8(fp)
 4004f9c:	10800617 	ldw	r2,24(r2)
 4004fa0:	10000516 	blt	r2,zero,4004fb8 <vTaskPriorityDisinheritAfterTimeout+0xb0>
                    {
                        listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 4004fa4:	00c00144 	movi	r3,5
 4004fa8:	e0bfff17 	ldw	r2,-4(fp)
 4004fac:	1887c83a 	sub	r3,r3,r2
 4004fb0:	e0bffe17 	ldw	r2,-8(fp)
 4004fb4:	10c00615 	stw	r3,24(r2)
                     * then the task that holds the mutex could be in either the
                     * Ready, Blocked or Suspended states.  Only remove the task
                     * from its current state list if it is in the Ready state as
                     * the task's priority is going to change and there is one
                     * Ready list per priority. */
                    if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 4004fb8:	e0bffe17 	ldw	r2,-8(fp)
 4004fbc:	10c00517 	ldw	r3,20(r2)
 4004fc0:	e0bffc17 	ldw	r2,-16(fp)
 4004fc4:	11000524 	muli	r4,r2,20
 4004fc8:	00812074 	movhi	r2,1153
 4004fcc:	10abdc04 	addi	r2,r2,-20624
 4004fd0:	2085883a 	add	r2,r4,r2
 4004fd4:	1880161e 	bne	r3,r2,4005030 <vTaskPriorityDisinheritAfterTimeout+0x128>
                    {
                        if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 4004fd8:	e0bffe17 	ldw	r2,-8(fp)
 4004fdc:	10800104 	addi	r2,r2,4
 4004fe0:	1009883a 	mov	r4,r2
 4004fe4:	40010600 	call	4001060 <uxListRemove>
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }

                        prvAddTaskToReadyList( pxTCB );
 4004fe8:	e0bffe17 	ldw	r2,-8(fp)
 4004fec:	10800b17 	ldw	r2,44(r2)
 4004ff0:	d0e5ab17 	ldw	r3,-26964(gp)
 4004ff4:	1880032e 	bgeu	r3,r2,4005004 <vTaskPriorityDisinheritAfterTimeout+0xfc>
 4004ff8:	e0bffe17 	ldw	r2,-8(fp)
 4004ffc:	10800b17 	ldw	r2,44(r2)
 4005000:	d0a5ab15 	stw	r2,-26964(gp)
 4005004:	e0bffe17 	ldw	r2,-8(fp)
 4005008:	10800b17 	ldw	r2,44(r2)
 400500c:	10c00524 	muli	r3,r2,20
 4005010:	00812074 	movhi	r2,1153
 4005014:	10abdc04 	addi	r2,r2,-20624
 4005018:	1887883a 	add	r3,r3,r2
 400501c:	e0bffe17 	ldw	r2,-8(fp)
 4005020:	10800104 	addi	r2,r2,4
 4005024:	100b883a 	mov	r5,r2
 4005028:	1809883a 	mov	r4,r3
 400502c:	4000efc0 	call	4000efc <vListInsertEnd>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
 4005030:	0001883a 	nop
 4005034:	e037883a 	mov	sp,fp
 4005038:	dfc00117 	ldw	ra,4(sp)
 400503c:	df000017 	ldw	fp,0(sp)
 4005040:	dec00204 	addi	sp,sp,8
 4005044:	f800283a 	ret

04005048 <vTaskEnterCritical>:
/*-----------------------------------------------------------*/

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

    void vTaskEnterCritical( void )
    {
 4005048:	defffe04 	addi	sp,sp,-8
 400504c:	df000115 	stw	fp,4(sp)
 4005050:	df000104 	addi	fp,sp,4
  NIOS2_READ_STATUS (context);
 4005054:	0005303a 	rdctl	r2,status
 4005058:	e0bfff15 	stw	r2,-4(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 400505c:	e0ffff17 	ldw	r3,-4(fp)
 4005060:	00bfff84 	movi	r2,-2
 4005064:	1884703a 	and	r2,r3,r2
 4005068:	1001703a 	wrctl	status,r2
        portDISABLE_INTERRUPTS();

        if( xSchedulerRunning != pdFALSE )
 400506c:	d0a5ac17 	ldw	r2,-26960(gp)
 4005070:	10000526 	beq	r2,zero,4005088 <vTaskEnterCritical+0x40>
        {
            ( pxCurrentTCB->uxCriticalNesting )++;
 4005074:	d0a5a517 	ldw	r2,-26988(gp)
 4005078:	10c00f17 	ldw	r3,60(r2)
 400507c:	18c00044 	addi	r3,r3,1
 4005080:	10c00f15 	stw	r3,60(r2)
             * function so  assert() if it is being called from an interrupt
             * context.  Only API functions that end in "FromISR" can be used in an
             * interrupt.  Only assert if the critical nesting count is 1 to
             * protect against recursive calls if the assert function also uses a
             * critical section. */
            if( pxCurrentTCB->uxCriticalNesting == 1 )
 4005084:	d0a5a517 	ldw	r2,-26988(gp)
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
 4005088:	0001883a 	nop
 400508c:	e037883a 	mov	sp,fp
 4005090:	df000017 	ldw	fp,0(sp)
 4005094:	dec00104 	addi	sp,sp,4
 4005098:	f800283a 	ret

0400509c <vTaskExitCritical>:
/*-----------------------------------------------------------*/

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

    void vTaskExitCritical( void )
    {
 400509c:	defffe04 	addi	sp,sp,-8
 40050a0:	df000115 	stw	fp,4(sp)
 40050a4:	df000104 	addi	fp,sp,4
        if( xSchedulerRunning != pdFALSE )
 40050a8:	d0a5ac17 	ldw	r2,-26960(gp)
 40050ac:	10000f26 	beq	r2,zero,40050ec <vTaskExitCritical+0x50>
        {
            if( pxCurrentTCB->uxCriticalNesting > 0U )
 40050b0:	d0a5a517 	ldw	r2,-26988(gp)
 40050b4:	10800f17 	ldw	r2,60(r2)
 40050b8:	10000c26 	beq	r2,zero,40050ec <vTaskExitCritical+0x50>
            {
                ( pxCurrentTCB->uxCriticalNesting )--;
 40050bc:	d0a5a517 	ldw	r2,-26988(gp)
 40050c0:	10c00f17 	ldw	r3,60(r2)
 40050c4:	18ffffc4 	addi	r3,r3,-1
 40050c8:	10c00f15 	stw	r3,60(r2)

                if( pxCurrentTCB->uxCriticalNesting == 0U )
 40050cc:	d0a5a517 	ldw	r2,-26988(gp)
 40050d0:	10800f17 	ldw	r2,60(r2)
 40050d4:	1000051e 	bne	r2,zero,40050ec <vTaskExitCritical+0x50>
 40050d8:	00800044 	movi	r2,1
 40050dc:	e0bfff15 	stw	r2,-4(fp)
  NIOS2_WRITE_STATUS (context);
 40050e0:	e0bfff17 	ldw	r2,-4(fp)
 40050e4:	1001703a 	wrctl	status,r2
}
 40050e8:	0001883a 	nop
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
 40050ec:	0001883a 	nop
 40050f0:	e037883a 	mov	sp,fp
 40050f4:	df000017 	ldw	fp,0(sp)
 40050f8:	dec00104 	addi	sp,sp,4
 40050fc:	f800283a 	ret

04005100 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
 4005100:	defffe04 	addi	sp,sp,-8
 4005104:	df000115 	stw	fp,4(sp)
 4005108:	df000104 	addi	fp,sp,4
    TickType_t uxReturn;

    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
 400510c:	d0a5a517 	ldw	r2,-26988(gp)
 4005110:	10800617 	ldw	r2,24(r2)
 4005114:	e0bfff15 	stw	r2,-4(fp)

    /* Reset the event list item to its normal value - so it can be used with
     * queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 4005118:	d0a5a517 	ldw	r2,-26988(gp)
 400511c:	10c00b17 	ldw	r3,44(r2)
 4005120:	d0a5a517 	ldw	r2,-26988(gp)
 4005124:	01000144 	movi	r4,5
 4005128:	20c7c83a 	sub	r3,r4,r3
 400512c:	10c00615 	stw	r3,24(r2)

    return uxReturn;
 4005130:	e0bfff17 	ldw	r2,-4(fp)
}
 4005134:	e037883a 	mov	sp,fp
 4005138:	df000017 	ldw	fp,0(sp)
 400513c:	dec00104 	addi	sp,sp,4
 4005140:	f800283a 	ret

04005144 <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    TaskHandle_t pvTaskIncrementMutexHeldCount( void )
    {
 4005144:	deffff04 	addi	sp,sp,-4
 4005148:	df000015 	stw	fp,0(sp)
 400514c:	d839883a 	mov	fp,sp
        /* If xSemaphoreCreateMutex() is called before any tasks have been created
         * then pxCurrentTCB will be NULL. */
        if( pxCurrentTCB != NULL )
 4005150:	d0a5a517 	ldw	r2,-26988(gp)
 4005154:	10000426 	beq	r2,zero,4005168 <pvTaskIncrementMutexHeldCount+0x24>
        {
            ( pxCurrentTCB->uxMutexesHeld )++;
 4005158:	d0a5a517 	ldw	r2,-26988(gp)
 400515c:	10c01117 	ldw	r3,68(r2)
 4005160:	18c00044 	addi	r3,r3,1
 4005164:	10c01115 	stw	r3,68(r2)
        }

        return pxCurrentTCB;
 4005168:	d0a5a517 	ldw	r2,-26988(gp)
    }
 400516c:	e037883a 	mov	sp,fp
 4005170:	df000017 	ldw	fp,0(sp)
 4005174:	dec00104 	addi	sp,sp,4
 4005178:	f800283a 	ret

0400517c <ulTaskGenericNotifyTake>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
 400517c:	defffa04 	addi	sp,sp,-24
 4005180:	dfc00515 	stw	ra,20(sp)
 4005184:	df000415 	stw	fp,16(sp)
 4005188:	df000404 	addi	fp,sp,16
 400518c:	e13ffe15 	stw	r4,-8(fp)
 4005190:	e17ffd15 	stw	r5,-12(fp)
 4005194:	e1bffc15 	stw	r6,-16(fp)
        uint32_t ulReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
 4005198:	40050480 	call	4005048 <vTaskEnterCritical>
        {
            /* Only block if the notification count is not already non-zero. */
            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
 400519c:	d0e5a517 	ldw	r3,-26988(gp)
 40051a0:	e0bffe17 	ldw	r2,-8(fp)
 40051a4:	10800484 	addi	r2,r2,18
 40051a8:	100490ba 	slli	r2,r2,2
 40051ac:	1885883a 	add	r2,r3,r2
 40051b0:	10800017 	ldw	r2,0(r2)
 40051b4:	10000b1e 	bne	r2,zero,40051e4 <ulTaskGenericNotifyTake+0x68>
            {
                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
 40051b8:	d0e5a517 	ldw	r3,-26988(gp)
 40051bc:	e0bffe17 	ldw	r2,-8(fp)
 40051c0:	1885883a 	add	r2,r3,r2
 40051c4:	00c00044 	movi	r3,1
 40051c8:	10c01305 	stb	r3,76(r2)

                if( xTicksToWait > ( TickType_t ) 0 )
 40051cc:	e0bffc17 	ldw	r2,-16(fp)
 40051d0:	10000426 	beq	r2,zero,40051e4 <ulTaskGenericNotifyTake+0x68>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 40051d4:	01400044 	movi	r5,1
 40051d8:	e13ffc17 	ldw	r4,-16(fp)
 40051dc:	4005af80 	call	4005af8 <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
 40051e0:	003b683a 	trap	0
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
 40051e4:	400509c0 	call	400509c <vTaskExitCritical>

        taskENTER_CRITICAL();
 40051e8:	40050480 	call	4005048 <vTaskEnterCritical>
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWait );
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
 40051ec:	d0e5a517 	ldw	r3,-26988(gp)
 40051f0:	e0bffe17 	ldw	r2,-8(fp)
 40051f4:	10800484 	addi	r2,r2,18
 40051f8:	100490ba 	slli	r2,r2,2
 40051fc:	1885883a 	add	r2,r3,r2
 4005200:	10800017 	ldw	r2,0(r2)
 4005204:	e0bfff15 	stw	r2,-4(fp)

            if( ulReturn != 0UL )
 4005208:	e0bfff17 	ldw	r2,-4(fp)
 400520c:	10001126 	beq	r2,zero,4005254 <ulTaskGenericNotifyTake+0xd8>
            {
                if( xClearCountOnExit != pdFALSE )
 4005210:	e0bffd17 	ldw	r2,-12(fp)
 4005214:	10000726 	beq	r2,zero,4005234 <ulTaskGenericNotifyTake+0xb8>
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
 4005218:	d0e5a517 	ldw	r3,-26988(gp)
 400521c:	e0bffe17 	ldw	r2,-8(fp)
 4005220:	10800484 	addi	r2,r2,18
 4005224:	100490ba 	slli	r2,r2,2
 4005228:	1885883a 	add	r2,r3,r2
 400522c:	10000015 	stw	zero,0(r2)
 4005230:	00000806 	br	4005254 <ulTaskGenericNotifyTake+0xd8>
                }
                else
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
 4005234:	d125a517 	ldw	r4,-26988(gp)
 4005238:	e0bfff17 	ldw	r2,-4(fp)
 400523c:	10ffffc4 	addi	r3,r2,-1
 4005240:	e0bffe17 	ldw	r2,-8(fp)
 4005244:	10800484 	addi	r2,r2,18
 4005248:	100490ba 	slli	r2,r2,2
 400524c:	2085883a 	add	r2,r4,r2
 4005250:	10c00015 	stw	r3,0(r2)
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
 4005254:	d0e5a517 	ldw	r3,-26988(gp)
 4005258:	e0bffe17 	ldw	r2,-8(fp)
 400525c:	1885883a 	add	r2,r3,r2
 4005260:	10001305 	stb	zero,76(r2)
        }
        taskEXIT_CRITICAL();
 4005264:	400509c0 	call	400509c <vTaskExitCritical>

        return ulReturn;
 4005268:	e0bfff17 	ldw	r2,-4(fp)
    }
 400526c:	e037883a 	mov	sp,fp
 4005270:	dfc00117 	ldw	ra,4(sp)
 4005274:	df000017 	ldw	fp,0(sp)
 4005278:	dec00204 	addi	sp,sp,8
 400527c:	f800283a 	ret

04005280 <xTaskGenericNotifyWait>:
    BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWait,
                                       uint32_t ulBitsToClearOnEntry,
                                       uint32_t ulBitsToClearOnExit,
                                       uint32_t * pulNotificationValue,
                                       TickType_t xTicksToWait )
    {
 4005280:	defff904 	addi	sp,sp,-28
 4005284:	dfc00615 	stw	ra,24(sp)
 4005288:	df000515 	stw	fp,20(sp)
 400528c:	df000504 	addi	fp,sp,20
 4005290:	e13ffe15 	stw	r4,-8(fp)
 4005294:	e17ffd15 	stw	r5,-12(fp)
 4005298:	e1bffc15 	stw	r6,-16(fp)
 400529c:	e1fffb15 	stw	r7,-20(fp)
        BaseType_t xReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
 40052a0:	40050480 	call	4005048 <vTaskEnterCritical>
        {
            /* Only block if a notification is not already pending. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
 40052a4:	d0e5a517 	ldw	r3,-26988(gp)
 40052a8:	e0bffe17 	ldw	r2,-8(fp)
 40052ac:	1885883a 	add	r2,r3,r2
 40052b0:	10801303 	ldbu	r2,76(r2)
 40052b4:	10803fcc 	andi	r2,r2,255
 40052b8:	108000a0 	cmpeqi	r2,r2,2
 40052bc:	1000191e 	bne	r2,zero,4005324 <xTaskGenericNotifyWait+0xa4>
            {
                /* Clear bits in the task's notification value as bits may get
                 * set  by the notifying task or interrupt.  This can be used to
                 * clear the value to zero. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
 40052c0:	d0a5a517 	ldw	r2,-26988(gp)
 40052c4:	e0fffe17 	ldw	r3,-8(fp)
 40052c8:	18c00484 	addi	r3,r3,18
 40052cc:	180690ba 	slli	r3,r3,2
 40052d0:	10c7883a 	add	r3,r2,r3
 40052d4:	19000017 	ldw	r4,0(r3)
 40052d8:	e0fffd17 	ldw	r3,-12(fp)
 40052dc:	00c6303a 	nor	r3,zero,r3
 40052e0:	20c6703a 	and	r3,r4,r3
 40052e4:	e13ffe17 	ldw	r4,-8(fp)
 40052e8:	21000484 	addi	r4,r4,18
 40052ec:	200890ba 	slli	r4,r4,2
 40052f0:	1105883a 	add	r2,r2,r4
 40052f4:	10c00015 	stw	r3,0(r2)

                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
 40052f8:	d0e5a517 	ldw	r3,-26988(gp)
 40052fc:	e0bffe17 	ldw	r2,-8(fp)
 4005300:	1885883a 	add	r2,r3,r2
 4005304:	00c00044 	movi	r3,1
 4005308:	10c01305 	stb	r3,76(r2)

                if( xTicksToWait > ( TickType_t ) 0 )
 400530c:	e0800217 	ldw	r2,8(fp)
 4005310:	10000426 	beq	r2,zero,4005324 <xTaskGenericNotifyWait+0xa4>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 4005314:	01400044 	movi	r5,1
 4005318:	e1000217 	ldw	r4,8(fp)
 400531c:	4005af80 	call	4005af8 <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
 4005320:	003b683a 	trap	0
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
 4005324:	400509c0 	call	400509c <vTaskExitCritical>

        taskENTER_CRITICAL();
 4005328:	40050480 	call	4005048 <vTaskEnterCritical>
        {
            traceTASK_NOTIFY_WAIT( uxIndexToWait );

            if( pulNotificationValue != NULL )
 400532c:	e0bffb17 	ldw	r2,-20(fp)
 4005330:	10000826 	beq	r2,zero,4005354 <xTaskGenericNotifyWait+0xd4>
            {
                /* Output the current notification value, which may or may not
                 * have changed. */
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
 4005334:	d0e5a517 	ldw	r3,-26988(gp)
 4005338:	e0bffe17 	ldw	r2,-8(fp)
 400533c:	10800484 	addi	r2,r2,18
 4005340:	100490ba 	slli	r2,r2,2
 4005344:	1885883a 	add	r2,r3,r2
 4005348:	10c00017 	ldw	r3,0(r2)
 400534c:	e0bffb17 	ldw	r2,-20(fp)
 4005350:	10c00015 	stw	r3,0(r2)

            /* If ucNotifyValue is set then either the task never entered the
             * blocked state (because a notification was already pending) or the
             * task unblocked because of a notification.  Otherwise the task
             * unblocked because of a timeout. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
 4005354:	d0e5a517 	ldw	r3,-26988(gp)
 4005358:	e0bffe17 	ldw	r2,-8(fp)
 400535c:	1885883a 	add	r2,r3,r2
 4005360:	10801303 	ldbu	r2,76(r2)
 4005364:	10803fcc 	andi	r2,r2,255
 4005368:	108000a0 	cmpeqi	r2,r2,2
 400536c:	1000021e 	bne	r2,zero,4005378 <xTaskGenericNotifyWait+0xf8>
            {
                /* A notification was not received. */
                xReturn = pdFALSE;
 4005370:	e03fff15 	stw	zero,-4(fp)
 4005374:	00001006 	br	40053b8 <xTaskGenericNotifyWait+0x138>
            }
            else
            {
                /* A notification was already pending or a notification was
                 * received while the task was waiting. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
 4005378:	d0a5a517 	ldw	r2,-26988(gp)
 400537c:	e0fffe17 	ldw	r3,-8(fp)
 4005380:	18c00484 	addi	r3,r3,18
 4005384:	180690ba 	slli	r3,r3,2
 4005388:	10c7883a 	add	r3,r2,r3
 400538c:	19000017 	ldw	r4,0(r3)
 4005390:	e0fffc17 	ldw	r3,-16(fp)
 4005394:	00c6303a 	nor	r3,zero,r3
 4005398:	20c6703a 	and	r3,r4,r3
 400539c:	e13ffe17 	ldw	r4,-8(fp)
 40053a0:	21000484 	addi	r4,r4,18
 40053a4:	200890ba 	slli	r4,r4,2
 40053a8:	1105883a 	add	r2,r2,r4
 40053ac:	10c00015 	stw	r3,0(r2)
                xReturn = pdTRUE;
 40053b0:	00800044 	movi	r2,1
 40053b4:	e0bfff15 	stw	r2,-4(fp)
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
 40053b8:	d0e5a517 	ldw	r3,-26988(gp)
 40053bc:	e0bffe17 	ldw	r2,-8(fp)
 40053c0:	1885883a 	add	r2,r3,r2
 40053c4:	10001305 	stb	zero,76(r2)
        }
        taskEXIT_CRITICAL();
 40053c8:	400509c0 	call	400509c <vTaskExitCritical>

        return xReturn;
 40053cc:	e0bfff17 	ldw	r2,-4(fp)
    }
 40053d0:	e037883a 	mov	sp,fp
 40053d4:	dfc00117 	ldw	ra,4(sp)
 40053d8:	df000017 	ldw	fp,0(sp)
 40053dc:	dec00204 	addi	sp,sp,8
 40053e0:	f800283a 	ret

040053e4 <xTaskGenericNotify>:
    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
 40053e4:	defff704 	addi	sp,sp,-36
 40053e8:	dfc00815 	stw	ra,32(sp)
 40053ec:	df000715 	stw	fp,28(sp)
 40053f0:	df000704 	addi	fp,sp,28
 40053f4:	e13ffc15 	stw	r4,-16(fp)
 40053f8:	e17ffb15 	stw	r5,-20(fp)
 40053fc:	e1bffa15 	stw	r6,-24(fp)
 4005400:	e1fff915 	stw	r7,-28(fp)
        TCB_t * pxTCB;
        BaseType_t xReturn = pdPASS;
 4005404:	00800044 	movi	r2,1
 4005408:	e0bfff15 	stw	r2,-4(fp)
        uint8_t ucOriginalNotifyState;

        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
        configASSERT( xTaskToNotify );
        pxTCB = xTaskToNotify;
 400540c:	e0bffc17 	ldw	r2,-16(fp)
 4005410:	e0bffe15 	stw	r2,-8(fp)

        taskENTER_CRITICAL();
 4005414:	40050480 	call	4005048 <vTaskEnterCritical>
        {
            if( pulPreviousNotificationValue != NULL )
 4005418:	e0800217 	ldw	r2,8(fp)
 400541c:	10000826 	beq	r2,zero,4005440 <xTaskGenericNotify+0x5c>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
 4005420:	e0fffe17 	ldw	r3,-8(fp)
 4005424:	e0bffb17 	ldw	r2,-20(fp)
 4005428:	10800484 	addi	r2,r2,18
 400542c:	100490ba 	slli	r2,r2,2
 4005430:	1885883a 	add	r2,r3,r2
 4005434:	10c00017 	ldw	r3,0(r2)
 4005438:	e0800217 	ldw	r2,8(fp)
 400543c:	10c00015 	stw	r3,0(r2)
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
 4005440:	e0fffe17 	ldw	r3,-8(fp)
 4005444:	e0bffb17 	ldw	r2,-20(fp)
 4005448:	1885883a 	add	r2,r3,r2
 400544c:	10801303 	ldbu	r2,76(r2)
 4005450:	e0bffdc5 	stb	r2,-9(fp)

            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
 4005454:	e0fffe17 	ldw	r3,-8(fp)
 4005458:	e0bffb17 	ldw	r2,-20(fp)
 400545c:	1885883a 	add	r2,r3,r2
 4005460:	00c00084 	movi	r3,2
 4005464:	10c01305 	stb	r3,76(r2)
 4005468:	e0bff917 	ldw	r2,-28(fp)
 400546c:	10800168 	cmpgeui	r2,r2,5
 4005470:	10003d1e 	bne	r2,zero,4005568 <xTaskGenericNotify+0x184>
 4005474:	e0bff917 	ldw	r2,-28(fp)
 4005478:	100690ba 	slli	r3,r2,2
 400547c:	00810034 	movhi	r2,1024
 4005480:	1885883a 	add	r2,r3,r2
 4005484:	10952317 	ldw	r2,21644(r2)
 4005488:	1000683a 	jmp	r2
 400548c:	04005570 	cmpltui	r16,zero,341
 4005490:	040054a0 	cmpeqi	r16,zero,338
 4005494:	040054dc 	xori	r16,zero,339
 4005498:	04005514 	movui	r16,340
 400549c:	04005534 	movhi	r16,340

            switch( eAction )
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
 40054a0:	e0fffe17 	ldw	r3,-8(fp)
 40054a4:	e0bffb17 	ldw	r2,-20(fp)
 40054a8:	10800484 	addi	r2,r2,18
 40054ac:	100490ba 	slli	r2,r2,2
 40054b0:	1885883a 	add	r2,r3,r2
 40054b4:	10c00017 	ldw	r3,0(r2)
 40054b8:	e0bffa17 	ldw	r2,-24(fp)
 40054bc:	1886b03a 	or	r3,r3,r2
 40054c0:	e13ffe17 	ldw	r4,-8(fp)
 40054c4:	e0bffb17 	ldw	r2,-20(fp)
 40054c8:	10800484 	addi	r2,r2,18
 40054cc:	100490ba 	slli	r2,r2,2
 40054d0:	2085883a 	add	r2,r4,r2
 40054d4:	10c00015 	stw	r3,0(r2)
                    break;
 40054d8:	00002606 	br	4005574 <xTaskGenericNotify+0x190>

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
 40054dc:	e0fffe17 	ldw	r3,-8(fp)
 40054e0:	e0bffb17 	ldw	r2,-20(fp)
 40054e4:	10800484 	addi	r2,r2,18
 40054e8:	100490ba 	slli	r2,r2,2
 40054ec:	1885883a 	add	r2,r3,r2
 40054f0:	10800017 	ldw	r2,0(r2)
 40054f4:	10c00044 	addi	r3,r2,1
 40054f8:	e13ffe17 	ldw	r4,-8(fp)
 40054fc:	e0bffb17 	ldw	r2,-20(fp)
 4005500:	10800484 	addi	r2,r2,18
 4005504:	100490ba 	slli	r2,r2,2
 4005508:	2085883a 	add	r2,r4,r2
 400550c:	10c00015 	stw	r3,0(r2)
                    break;
 4005510:	00001806 	br	4005574 <xTaskGenericNotify+0x190>

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
 4005514:	e0fffe17 	ldw	r3,-8(fp)
 4005518:	e0bffb17 	ldw	r2,-20(fp)
 400551c:	10800484 	addi	r2,r2,18
 4005520:	100490ba 	slli	r2,r2,2
 4005524:	1885883a 	add	r2,r3,r2
 4005528:	e0fffa17 	ldw	r3,-24(fp)
 400552c:	10c00015 	stw	r3,0(r2)
                    break;
 4005530:	00001006 	br	4005574 <xTaskGenericNotify+0x190>

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 4005534:	e0bffdc3 	ldbu	r2,-9(fp)
 4005538:	108000a0 	cmpeqi	r2,r2,2
 400553c:	1000081e 	bne	r2,zero,4005560 <xTaskGenericNotify+0x17c>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
 4005540:	e0fffe17 	ldw	r3,-8(fp)
 4005544:	e0bffb17 	ldw	r2,-20(fp)
 4005548:	10800484 	addi	r2,r2,18
 400554c:	100490ba 	slli	r2,r2,2
 4005550:	1885883a 	add	r2,r3,r2
 4005554:	e0fffa17 	ldw	r3,-24(fp)
 4005558:	10c00015 	stw	r3,0(r2)
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
                    }

                    break;
 400555c:	00000506 	br	4005574 <xTaskGenericNotify+0x190>
                        xReturn = pdFAIL;
 4005560:	e03fff15 	stw	zero,-4(fp)
                    break;
 4005564:	00000306 	br	4005574 <xTaskGenericNotify+0x190>
                    /* Should not get here if all enums are handled.
                     * Artificially force an assert by testing a value the
                     * compiler can't assume is const. */
                    configASSERT( xTickCount == ( TickType_t ) 0 );

                    break;
 4005568:	0001883a 	nop
 400556c:	00000106 	br	4005574 <xTaskGenericNotify+0x190>
                    break;
 4005570:	0001883a 	nop

            traceTASK_NOTIFY( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 4005574:	e0bffdc3 	ldbu	r2,-9(fp)
 4005578:	10800058 	cmpnei	r2,r2,1
 400557c:	10001c1e 	bne	r2,zero,40055f0 <xTaskGenericNotify+0x20c>
            {
                ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 4005580:	e0bffe17 	ldw	r2,-8(fp)
 4005584:	10800104 	addi	r2,r2,4
 4005588:	1009883a 	mov	r4,r2
 400558c:	40010600 	call	4001060 <uxListRemove>
                prvAddTaskToReadyList( pxTCB );
 4005590:	e0bffe17 	ldw	r2,-8(fp)
 4005594:	10800b17 	ldw	r2,44(r2)
 4005598:	d0e5ab17 	ldw	r3,-26964(gp)
 400559c:	1880032e 	bgeu	r3,r2,40055ac <xTaskGenericNotify+0x1c8>
 40055a0:	e0bffe17 	ldw	r2,-8(fp)
 40055a4:	10800b17 	ldw	r2,44(r2)
 40055a8:	d0a5ab15 	stw	r2,-26964(gp)
 40055ac:	e0bffe17 	ldw	r2,-8(fp)
 40055b0:	10800b17 	ldw	r2,44(r2)
 40055b4:	10c00524 	muli	r3,r2,20
 40055b8:	00812074 	movhi	r2,1153
 40055bc:	10abdc04 	addi	r2,r2,-20624
 40055c0:	1887883a 	add	r3,r3,r2
 40055c4:	e0bffe17 	ldw	r2,-8(fp)
 40055c8:	10800104 	addi	r2,r2,4
 40055cc:	100b883a 	mov	r5,r2
 40055d0:	1809883a 	mov	r4,r3
 40055d4:	4000efc0 	call	4000efc <vListInsertEnd>
                         * earliest possible time. */
                        prvResetNextTaskUnblockTime();
                    }
                #endif

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 40055d8:	e0bffe17 	ldw	r2,-8(fp)
 40055dc:	10800b17 	ldw	r2,44(r2)
 40055e0:	d0e5a517 	ldw	r3,-26988(gp)
 40055e4:	18c00b17 	ldw	r3,44(r3)
 40055e8:	1880012e 	bgeu	r3,r2,40055f0 <xTaskGenericNotify+0x20c>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    taskYIELD_IF_USING_PREEMPTION();
 40055ec:	003b683a 	trap	0
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
 40055f0:	400509c0 	call	400509c <vTaskExitCritical>

        return xReturn;
 40055f4:	e0bfff17 	ldw	r2,-4(fp)
    }
 40055f8:	e037883a 	mov	sp,fp
 40055fc:	dfc00117 	ldw	ra,4(sp)
 4005600:	df000017 	ldw	fp,0(sp)
 4005604:	dec00204 	addi	sp,sp,8
 4005608:	f800283a 	ret

0400560c <xTaskGenericNotifyFromISR>:
                                          UBaseType_t uxIndexToNotify,
                                          uint32_t ulValue,
                                          eNotifyAction eAction,
                                          uint32_t * pulPreviousNotificationValue,
                                          BaseType_t * pxHigherPriorityTaskWoken )
    {
 400560c:	defff604 	addi	sp,sp,-40
 4005610:	dfc00915 	stw	ra,36(sp)
 4005614:	df000815 	stw	fp,32(sp)
 4005618:	df000804 	addi	fp,sp,32
 400561c:	e13ffb15 	stw	r4,-20(fp)
 4005620:	e17ffa15 	stw	r5,-24(fp)
 4005624:	e1bff915 	stw	r6,-28(fp)
 4005628:	e1fff815 	stw	r7,-32(fp)
        TCB_t * pxTCB;
        uint8_t ucOriginalNotifyState;
        BaseType_t xReturn = pdPASS;
 400562c:	00800044 	movi	r2,1
 4005630:	e0bfff15 	stw	r2,-4(fp)
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
 4005634:	e0bffb17 	ldw	r2,-20(fp)
 4005638:	e0bffe15 	stw	r2,-8(fp)

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 400563c:	e03ffd15 	stw	zero,-12(fp)
        {
            if( pulPreviousNotificationValue != NULL )
 4005640:	e0800217 	ldw	r2,8(fp)
 4005644:	10000826 	beq	r2,zero,4005668 <xTaskGenericNotifyFromISR+0x5c>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
 4005648:	e0fffe17 	ldw	r3,-8(fp)
 400564c:	e0bffa17 	ldw	r2,-24(fp)
 4005650:	10800484 	addi	r2,r2,18
 4005654:	100490ba 	slli	r2,r2,2
 4005658:	1885883a 	add	r2,r3,r2
 400565c:	10c00017 	ldw	r3,0(r2)
 4005660:	e0800217 	ldw	r2,8(fp)
 4005664:	10c00015 	stw	r3,0(r2)
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
 4005668:	e0fffe17 	ldw	r3,-8(fp)
 400566c:	e0bffa17 	ldw	r2,-24(fp)
 4005670:	1885883a 	add	r2,r3,r2
 4005674:	10801303 	ldbu	r2,76(r2)
 4005678:	e0bffcc5 	stb	r2,-13(fp)
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
 400567c:	e0fffe17 	ldw	r3,-8(fp)
 4005680:	e0bffa17 	ldw	r2,-24(fp)
 4005684:	1885883a 	add	r2,r3,r2
 4005688:	00c00084 	movi	r3,2
 400568c:	10c01305 	stb	r3,76(r2)
 4005690:	e0bff817 	ldw	r2,-32(fp)
 4005694:	10800168 	cmpgeui	r2,r2,5
 4005698:	10003d1e 	bne	r2,zero,4005790 <xTaskGenericNotifyFromISR+0x184>
 400569c:	e0bff817 	ldw	r2,-32(fp)
 40056a0:	100690ba 	slli	r3,r2,2
 40056a4:	00810034 	movhi	r2,1024
 40056a8:	1885883a 	add	r2,r3,r2
 40056ac:	1095ad17 	ldw	r2,22196(r2)
 40056b0:	1000683a 	jmp	r2
 40056b4:	04005798 	cmpnei	r16,zero,350
 40056b8:	040056c8 	cmpgei	r16,zero,347
 40056bc:	04005704 	movi	r16,348
 40056c0:	0400573c 	xorhi	r16,zero,348
 40056c4:	0400575c 	xori	r16,zero,349

            switch( eAction )
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
 40056c8:	e0fffe17 	ldw	r3,-8(fp)
 40056cc:	e0bffa17 	ldw	r2,-24(fp)
 40056d0:	10800484 	addi	r2,r2,18
 40056d4:	100490ba 	slli	r2,r2,2
 40056d8:	1885883a 	add	r2,r3,r2
 40056dc:	10c00017 	ldw	r3,0(r2)
 40056e0:	e0bff917 	ldw	r2,-28(fp)
 40056e4:	1886b03a 	or	r3,r3,r2
 40056e8:	e13ffe17 	ldw	r4,-8(fp)
 40056ec:	e0bffa17 	ldw	r2,-24(fp)
 40056f0:	10800484 	addi	r2,r2,18
 40056f4:	100490ba 	slli	r2,r2,2
 40056f8:	2085883a 	add	r2,r4,r2
 40056fc:	10c00015 	stw	r3,0(r2)
                    break;
 4005700:	00002606 	br	400579c <xTaskGenericNotifyFromISR+0x190>

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
 4005704:	e0fffe17 	ldw	r3,-8(fp)
 4005708:	e0bffa17 	ldw	r2,-24(fp)
 400570c:	10800484 	addi	r2,r2,18
 4005710:	100490ba 	slli	r2,r2,2
 4005714:	1885883a 	add	r2,r3,r2
 4005718:	10800017 	ldw	r2,0(r2)
 400571c:	10c00044 	addi	r3,r2,1
 4005720:	e13ffe17 	ldw	r4,-8(fp)
 4005724:	e0bffa17 	ldw	r2,-24(fp)
 4005728:	10800484 	addi	r2,r2,18
 400572c:	100490ba 	slli	r2,r2,2
 4005730:	2085883a 	add	r2,r4,r2
 4005734:	10c00015 	stw	r3,0(r2)
                    break;
 4005738:	00001806 	br	400579c <xTaskGenericNotifyFromISR+0x190>

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
 400573c:	e0fffe17 	ldw	r3,-8(fp)
 4005740:	e0bffa17 	ldw	r2,-24(fp)
 4005744:	10800484 	addi	r2,r2,18
 4005748:	100490ba 	slli	r2,r2,2
 400574c:	1885883a 	add	r2,r3,r2
 4005750:	e0fff917 	ldw	r3,-28(fp)
 4005754:	10c00015 	stw	r3,0(r2)
                    break;
 4005758:	00001006 	br	400579c <xTaskGenericNotifyFromISR+0x190>

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 400575c:	e0bffcc3 	ldbu	r2,-13(fp)
 4005760:	108000a0 	cmpeqi	r2,r2,2
 4005764:	1000081e 	bne	r2,zero,4005788 <xTaskGenericNotifyFromISR+0x17c>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
 4005768:	e0fffe17 	ldw	r3,-8(fp)
 400576c:	e0bffa17 	ldw	r2,-24(fp)
 4005770:	10800484 	addi	r2,r2,18
 4005774:	100490ba 	slli	r2,r2,2
 4005778:	1885883a 	add	r2,r3,r2
 400577c:	e0fff917 	ldw	r3,-28(fp)
 4005780:	10c00015 	stw	r3,0(r2)
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
                    }

                    break;
 4005784:	00000506 	br	400579c <xTaskGenericNotifyFromISR+0x190>
                        xReturn = pdFAIL;
 4005788:	e03fff15 	stw	zero,-4(fp)
                    break;
 400578c:	00000306 	br	400579c <xTaskGenericNotifyFromISR+0x190>

                    /* Should not get here if all enums are handled.
                     * Artificially force an assert by testing a value the
                     * compiler can't assume is const. */
                    configASSERT( xTickCount == ( TickType_t ) 0 );
                    break;
 4005790:	0001883a 	nop
 4005794:	00000106 	br	400579c <xTaskGenericNotifyFromISR+0x190>
                    break;
 4005798:	0001883a 	nop

            traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 400579c:	e0bffcc3 	ldbu	r2,-13(fp)
 40057a0:	10800058 	cmpnei	r2,r2,1
 40057a4:	10002b1e 	bne	r2,zero,4005854 <xTaskGenericNotifyFromISR+0x248>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 40057a8:	d0a5b317 	ldw	r2,-26932(gp)
 40057ac:	1000171e 	bne	r2,zero,400580c <xTaskGenericNotifyFromISR+0x200>
                {
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 40057b0:	e0bffe17 	ldw	r2,-8(fp)
 40057b4:	10800104 	addi	r2,r2,4
 40057b8:	1009883a 	mov	r4,r2
 40057bc:	40010600 	call	4001060 <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
 40057c0:	e0bffe17 	ldw	r2,-8(fp)
 40057c4:	10800b17 	ldw	r2,44(r2)
 40057c8:	d0e5ab17 	ldw	r3,-26964(gp)
 40057cc:	1880032e 	bgeu	r3,r2,40057dc <xTaskGenericNotifyFromISR+0x1d0>
 40057d0:	e0bffe17 	ldw	r2,-8(fp)
 40057d4:	10800b17 	ldw	r2,44(r2)
 40057d8:	d0a5ab15 	stw	r2,-26964(gp)
 40057dc:	e0bffe17 	ldw	r2,-8(fp)
 40057e0:	10800b17 	ldw	r2,44(r2)
 40057e4:	10c00524 	muli	r3,r2,20
 40057e8:	00812074 	movhi	r2,1153
 40057ec:	10abdc04 	addi	r2,r2,-20624
 40057f0:	1887883a 	add	r3,r3,r2
 40057f4:	e0bffe17 	ldw	r2,-8(fp)
 40057f8:	10800104 	addi	r2,r2,4
 40057fc:	100b883a 	mov	r5,r2
 4005800:	1809883a 	mov	r4,r3
 4005804:	4000efc0 	call	4000efc <vListInsertEnd>
 4005808:	00000606 	br	4005824 <xTaskGenericNotifyFromISR+0x218>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 400580c:	e0bffe17 	ldw	r2,-8(fp)
 4005810:	10800604 	addi	r2,r2,24
 4005814:	100b883a 	mov	r5,r2
 4005818:	01012074 	movhi	r4,1153
 400581c:	212bff04 	addi	r4,r4,-20484
 4005820:	4000efc0 	call	4000efc <vListInsertEnd>
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 4005824:	e0bffe17 	ldw	r2,-8(fp)
 4005828:	10800b17 	ldw	r2,44(r2)
 400582c:	d0e5a517 	ldw	r3,-26988(gp)
 4005830:	18c00b17 	ldw	r3,44(r3)
 4005834:	1880072e 	bgeu	r3,r2,4005854 <xTaskGenericNotifyFromISR+0x248>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
 4005838:	e0800317 	ldw	r2,12(fp)
 400583c:	10000326 	beq	r2,zero,400584c <xTaskGenericNotifyFromISR+0x240>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
 4005840:	e0800317 	ldw	r2,12(fp)
 4005844:	00c00044 	movi	r3,1
 4005848:	10c00015 	stw	r3,0(r2)
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter to an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
 400584c:	00800044 	movi	r2,1
 4005850:	d0a5ae15 	stw	r2,-26952(gp)
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xReturn;
 4005854:	e0bfff17 	ldw	r2,-4(fp)
    }
 4005858:	e037883a 	mov	sp,fp
 400585c:	dfc00117 	ldw	ra,4(sp)
 4005860:	df000017 	ldw	fp,0(sp)
 4005864:	dec00204 	addi	sp,sp,8
 4005868:	f800283a 	ret

0400586c <vTaskGenericNotifyGiveFromISR>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
                                        UBaseType_t uxIndexToNotify,
                                        BaseType_t * pxHigherPriorityTaskWoken )
    {
 400586c:	defff804 	addi	sp,sp,-32
 4005870:	dfc00715 	stw	ra,28(sp)
 4005874:	df000615 	stw	fp,24(sp)
 4005878:	df000604 	addi	fp,sp,24
 400587c:	e13ffc15 	stw	r4,-16(fp)
 4005880:	e17ffb15 	stw	r5,-20(fp)
 4005884:	e1bffa15 	stw	r6,-24(fp)
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
 4005888:	e0bffc17 	ldw	r2,-16(fp)
 400588c:	e0bfff15 	stw	r2,-4(fp)

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 4005890:	e03ffe15 	stw	zero,-8(fp)
        {
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
 4005894:	e0ffff17 	ldw	r3,-4(fp)
 4005898:	e0bffb17 	ldw	r2,-20(fp)
 400589c:	1885883a 	add	r2,r3,r2
 40058a0:	10801303 	ldbu	r2,76(r2)
 40058a4:	e0bffdc5 	stb	r2,-9(fp)
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
 40058a8:	e0ffff17 	ldw	r3,-4(fp)
 40058ac:	e0bffb17 	ldw	r2,-20(fp)
 40058b0:	1885883a 	add	r2,r3,r2
 40058b4:	00c00084 	movi	r3,2
 40058b8:	10c01305 	stb	r3,76(r2)

            /* 'Giving' is equivalent to incrementing a count in a counting
             * semaphore. */
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
 40058bc:	e0ffff17 	ldw	r3,-4(fp)
 40058c0:	e0bffb17 	ldw	r2,-20(fp)
 40058c4:	10800484 	addi	r2,r2,18
 40058c8:	100490ba 	slli	r2,r2,2
 40058cc:	1885883a 	add	r2,r3,r2
 40058d0:	10800017 	ldw	r2,0(r2)
 40058d4:	10c00044 	addi	r3,r2,1
 40058d8:	e13fff17 	ldw	r4,-4(fp)
 40058dc:	e0bffb17 	ldw	r2,-20(fp)
 40058e0:	10800484 	addi	r2,r2,18
 40058e4:	100490ba 	slli	r2,r2,2
 40058e8:	2085883a 	add	r2,r4,r2
 40058ec:	10c00015 	stw	r3,0(r2)

            traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 40058f0:	e0bffdc3 	ldbu	r2,-9(fp)
 40058f4:	10800058 	cmpnei	r2,r2,1
 40058f8:	10002b1e 	bne	r2,zero,40059a8 <vTaskGenericNotifyGiveFromISR+0x13c>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 40058fc:	d0a5b317 	ldw	r2,-26932(gp)
 4005900:	1000171e 	bne	r2,zero,4005960 <vTaskGenericNotifyGiveFromISR+0xf4>
                {
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 4005904:	e0bfff17 	ldw	r2,-4(fp)
 4005908:	10800104 	addi	r2,r2,4
 400590c:	1009883a 	mov	r4,r2
 4005910:	40010600 	call	4001060 <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
 4005914:	e0bfff17 	ldw	r2,-4(fp)
 4005918:	10800b17 	ldw	r2,44(r2)
 400591c:	d0e5ab17 	ldw	r3,-26964(gp)
 4005920:	1880032e 	bgeu	r3,r2,4005930 <vTaskGenericNotifyGiveFromISR+0xc4>
 4005924:	e0bfff17 	ldw	r2,-4(fp)
 4005928:	10800b17 	ldw	r2,44(r2)
 400592c:	d0a5ab15 	stw	r2,-26964(gp)
 4005930:	e0bfff17 	ldw	r2,-4(fp)
 4005934:	10800b17 	ldw	r2,44(r2)
 4005938:	10c00524 	muli	r3,r2,20
 400593c:	00812074 	movhi	r2,1153
 4005940:	10abdc04 	addi	r2,r2,-20624
 4005944:	1887883a 	add	r3,r3,r2
 4005948:	e0bfff17 	ldw	r2,-4(fp)
 400594c:	10800104 	addi	r2,r2,4
 4005950:	100b883a 	mov	r5,r2
 4005954:	1809883a 	mov	r4,r3
 4005958:	4000efc0 	call	4000efc <vListInsertEnd>
 400595c:	00000606 	br	4005978 <vTaskGenericNotifyGiveFromISR+0x10c>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 4005960:	e0bfff17 	ldw	r2,-4(fp)
 4005964:	10800604 	addi	r2,r2,24
 4005968:	100b883a 	mov	r5,r2
 400596c:	01012074 	movhi	r4,1153
 4005970:	212bff04 	addi	r4,r4,-20484
 4005974:	4000efc0 	call	4000efc <vListInsertEnd>
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 4005978:	e0bfff17 	ldw	r2,-4(fp)
 400597c:	10800b17 	ldw	r2,44(r2)
 4005980:	d0e5a517 	ldw	r3,-26988(gp)
 4005984:	18c00b17 	ldw	r3,44(r3)
 4005988:	1880072e 	bgeu	r3,r2,40059a8 <vTaskGenericNotifyGiveFromISR+0x13c>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
 400598c:	e0bffa17 	ldw	r2,-24(fp)
 4005990:	10000326 	beq	r2,zero,40059a0 <vTaskGenericNotifyGiveFromISR+0x134>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
 4005994:	e0bffa17 	ldw	r2,-24(fp)
 4005998:	00c00044 	movi	r3,1
 400599c:	10c00015 	stw	r3,0(r2)
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter in an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
 40059a0:	00800044 	movi	r2,1
 40059a4:	d0a5ae15 	stw	r2,-26952(gp)
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    }
 40059a8:	0001883a 	nop
 40059ac:	e037883a 	mov	sp,fp
 40059b0:	dfc00117 	ldw	ra,4(sp)
 40059b4:	df000017 	ldw	fp,0(sp)
 40059b8:	dec00204 	addi	sp,sp,8
 40059bc:	f800283a 	ret

040059c0 <xTaskGenericNotifyStateClear>:

#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    BaseType_t xTaskGenericNotifyStateClear( TaskHandle_t xTask,
                                             UBaseType_t uxIndexToClear )
    {
 40059c0:	defffa04 	addi	sp,sp,-24
 40059c4:	dfc00515 	stw	ra,20(sp)
 40059c8:	df000415 	stw	fp,16(sp)
 40059cc:	df000404 	addi	fp,sp,16
 40059d0:	e13ffd15 	stw	r4,-12(fp)
 40059d4:	e17ffc15 	stw	r5,-16(fp)

        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
 40059d8:	e0bffd17 	ldw	r2,-12(fp)
 40059dc:	1000021e 	bne	r2,zero,40059e8 <xTaskGenericNotifyStateClear+0x28>
 40059e0:	d0a5a517 	ldw	r2,-26988(gp)
 40059e4:	00000106 	br	40059ec <xTaskGenericNotifyStateClear+0x2c>
 40059e8:	e0bffd17 	ldw	r2,-12(fp)
 40059ec:	e0bffe15 	stw	r2,-8(fp)

        taskENTER_CRITICAL();
 40059f0:	40050480 	call	4005048 <vTaskEnterCritical>
        {
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
 40059f4:	e0fffe17 	ldw	r3,-8(fp)
 40059f8:	e0bffc17 	ldw	r2,-16(fp)
 40059fc:	1885883a 	add	r2,r3,r2
 4005a00:	10801303 	ldbu	r2,76(r2)
 4005a04:	10803fcc 	andi	r2,r2,255
 4005a08:	10800098 	cmpnei	r2,r2,2
 4005a0c:	1000071e 	bne	r2,zero,4005a2c <xTaskGenericNotifyStateClear+0x6c>
            {
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
 4005a10:	e0fffe17 	ldw	r3,-8(fp)
 4005a14:	e0bffc17 	ldw	r2,-16(fp)
 4005a18:	1885883a 	add	r2,r3,r2
 4005a1c:	10001305 	stb	zero,76(r2)
                xReturn = pdPASS;
 4005a20:	00800044 	movi	r2,1
 4005a24:	e0bfff15 	stw	r2,-4(fp)
 4005a28:	00000106 	br	4005a30 <xTaskGenericNotifyStateClear+0x70>
            }
            else
            {
                xReturn = pdFAIL;
 4005a2c:	e03fff15 	stw	zero,-4(fp)
            }
        }
        taskEXIT_CRITICAL();
 4005a30:	400509c0 	call	400509c <vTaskExitCritical>

        return xReturn;
 4005a34:	e0bfff17 	ldw	r2,-4(fp)
    }
 4005a38:	e037883a 	mov	sp,fp
 4005a3c:	dfc00117 	ldw	ra,4(sp)
 4005a40:	df000017 	ldw	fp,0(sp)
 4005a44:	dec00204 	addi	sp,sp,8
 4005a48:	f800283a 	ret

04005a4c <ulTaskGenericNotifyValueClear>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
                                            UBaseType_t uxIndexToClear,
                                            uint32_t ulBitsToClear )
    {
 4005a4c:	defff904 	addi	sp,sp,-28
 4005a50:	dfc00615 	stw	ra,24(sp)
 4005a54:	df000515 	stw	fp,20(sp)
 4005a58:	df000504 	addi	fp,sp,20
 4005a5c:	e13ffd15 	stw	r4,-12(fp)
 4005a60:	e17ffc15 	stw	r5,-16(fp)
 4005a64:	e1bffb15 	stw	r6,-20(fp)
        TCB_t * pxTCB;
        uint32_t ulReturn;

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
 4005a68:	e0bffd17 	ldw	r2,-12(fp)
 4005a6c:	1000021e 	bne	r2,zero,4005a78 <ulTaskGenericNotifyValueClear+0x2c>
 4005a70:	d0a5a517 	ldw	r2,-26988(gp)
 4005a74:	00000106 	br	4005a7c <ulTaskGenericNotifyValueClear+0x30>
 4005a78:	e0bffd17 	ldw	r2,-12(fp)
 4005a7c:	e0bfff15 	stw	r2,-4(fp)

        taskENTER_CRITICAL();
 4005a80:	40050480 	call	4005048 <vTaskEnterCritical>
        {
            /* Return the notification as it was before the bits were cleared,
             * then clear the bit mask. */
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
 4005a84:	e0ffff17 	ldw	r3,-4(fp)
 4005a88:	e0bffc17 	ldw	r2,-16(fp)
 4005a8c:	10800484 	addi	r2,r2,18
 4005a90:	100490ba 	slli	r2,r2,2
 4005a94:	1885883a 	add	r2,r3,r2
 4005a98:	10800017 	ldw	r2,0(r2)
 4005a9c:	e0bffe15 	stw	r2,-8(fp)
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
 4005aa0:	e0ffff17 	ldw	r3,-4(fp)
 4005aa4:	e0bffc17 	ldw	r2,-16(fp)
 4005aa8:	10800484 	addi	r2,r2,18
 4005aac:	100490ba 	slli	r2,r2,2
 4005ab0:	1885883a 	add	r2,r3,r2
 4005ab4:	10c00017 	ldw	r3,0(r2)
 4005ab8:	e0bffb17 	ldw	r2,-20(fp)
 4005abc:	0084303a 	nor	r2,zero,r2
 4005ac0:	1886703a 	and	r3,r3,r2
 4005ac4:	e13fff17 	ldw	r4,-4(fp)
 4005ac8:	e0bffc17 	ldw	r2,-16(fp)
 4005acc:	10800484 	addi	r2,r2,18
 4005ad0:	100490ba 	slli	r2,r2,2
 4005ad4:	2085883a 	add	r2,r4,r2
 4005ad8:	10c00015 	stw	r3,0(r2)
        }
        taskEXIT_CRITICAL();
 4005adc:	400509c0 	call	400509c <vTaskExitCritical>

        return ulReturn;
 4005ae0:	e0bffe17 	ldw	r2,-8(fp)
    }
 4005ae4:	e037883a 	mov	sp,fp
 4005ae8:	dfc00117 	ldw	ra,4(sp)
 4005aec:	df000017 	ldw	fp,0(sp)
 4005af0:	dec00204 	addi	sp,sp,8
 4005af4:	f800283a 	ret

04005af8 <prvAddCurrentTaskToDelayedList>:
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
 4005af8:	defffa04 	addi	sp,sp,-24
 4005afc:	dfc00515 	stw	ra,20(sp)
 4005b00:	df000415 	stw	fp,16(sp)
 4005b04:	df000404 	addi	fp,sp,16
 4005b08:	e13ffd15 	stw	r4,-12(fp)
 4005b0c:	e17ffc15 	stw	r5,-16(fp)
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
 4005b10:	d0a5aa17 	ldw	r2,-26968(gp)
 4005b14:	e0bfff15 	stw	r2,-4(fp)
        }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 4005b18:	d0a5a517 	ldw	r2,-26988(gp)
 4005b1c:	10800104 	addi	r2,r2,4
 4005b20:	1009883a 	mov	r4,r2
 4005b24:	40010600 	call	4001060 <uxListRemove>
        mtCOVERAGE_TEST_MARKER();
    }

    #if ( INCLUDE_vTaskSuspend == 1 )
        {
            if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 4005b28:	e0bffd17 	ldw	r2,-12(fp)
 4005b2c:	10bfffd8 	cmpnei	r2,r2,-1
 4005b30:	1000091e 	bne	r2,zero,4005b58 <prvAddCurrentTaskToDelayedList+0x60>
 4005b34:	e0bffc17 	ldw	r2,-16(fp)
 4005b38:	10000726 	beq	r2,zero,4005b58 <prvAddCurrentTaskToDelayedList+0x60>
            {
                /* Add the task to the suspended task list instead of a delayed task
                 * list to ensure it is not woken by a timing event.  It will block
                 * indefinitely. */
                vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 4005b3c:	d0a5a517 	ldw	r2,-26988(gp)
 4005b40:	10800104 	addi	r2,r2,4
 4005b44:	100b883a 	mov	r5,r2
 4005b48:	01012074 	movhi	r4,1153
 4005b4c:	212c0904 	addi	r4,r4,-20444
 4005b50:	4000efc0 	call	4000efc <vListInsertEnd>

            /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
            ( void ) xCanBlockIndefinitely;
        }
    #endif /* INCLUDE_vTaskSuspend */
}
 4005b54:	00001c06 	br	4005bc8 <prvAddCurrentTaskToDelayedList+0xd0>
                xTimeToWake = xConstTickCount + xTicksToWait;
 4005b58:	e0ffff17 	ldw	r3,-4(fp)
 4005b5c:	e0bffd17 	ldw	r2,-12(fp)
 4005b60:	1885883a 	add	r2,r3,r2
 4005b64:	e0bffe15 	stw	r2,-8(fp)
                listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 4005b68:	d0a5a517 	ldw	r2,-26988(gp)
 4005b6c:	e0fffe17 	ldw	r3,-8(fp)
 4005b70:	10c00115 	stw	r3,4(r2)
                if( xTimeToWake < xConstTickCount )
 4005b74:	e0fffe17 	ldw	r3,-8(fp)
 4005b78:	e0bfff17 	ldw	r2,-4(fp)
 4005b7c:	1880072e 	bgeu	r3,r2,4005b9c <prvAddCurrentTaskToDelayedList+0xa4>
                    vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 4005b80:	d0e5a717 	ldw	r3,-26980(gp)
 4005b84:	d0a5a517 	ldw	r2,-26988(gp)
 4005b88:	10800104 	addi	r2,r2,4
 4005b8c:	100b883a 	mov	r5,r2
 4005b90:	1809883a 	mov	r4,r3
 4005b94:	4000f880 	call	4000f88 <vListInsert>
}
 4005b98:	00000b06 	br	4005bc8 <prvAddCurrentTaskToDelayedList+0xd0>
                    vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 4005b9c:	d0e5a617 	ldw	r3,-26984(gp)
 4005ba0:	d0a5a517 	ldw	r2,-26988(gp)
 4005ba4:	10800104 	addi	r2,r2,4
 4005ba8:	100b883a 	mov	r5,r2
 4005bac:	1809883a 	mov	r4,r3
 4005bb0:	4000f880 	call	4000f88 <vListInsert>
                    if( xTimeToWake < xNextTaskUnblockTime )
 4005bb4:	d0a5b117 	ldw	r2,-26940(gp)
 4005bb8:	e0fffe17 	ldw	r3,-8(fp)
 4005bbc:	1880022e 	bgeu	r3,r2,4005bc8 <prvAddCurrentTaskToDelayedList+0xd0>
                        xNextTaskUnblockTime = xTimeToWake;
 4005bc0:	e0bffe17 	ldw	r2,-8(fp)
 4005bc4:	d0a5b115 	stw	r2,-26940(gp)
}
 4005bc8:	0001883a 	nop
 4005bcc:	e037883a 	mov	sp,fp
 4005bd0:	dfc00117 	ldw	ra,4(sp)
 4005bd4:	df000017 	ldw	fp,0(sp)
 4005bd8:	dec00204 	addi	sp,sp,8
 4005bdc:	f800283a 	ret

04005be0 <timer_0_ISR>:
int Overflows = 0;
int Go = 0;
int Translate;

void timer_0_ISR(void *context, alt_32 id)
{
 4005be0:	defffd04 	addi	sp,sp,-12
 4005be4:	df000215 	stw	fp,8(sp)
 4005be8:	df000204 	addi	fp,sp,8
 4005bec:	e13fff15 	stw	r4,-4(fp)
 4005bf0:	e17ffe15 	stw	r5,-8(fp)
	if(Overflows == 10)
 4005bf4:	d0a5b417 	ldw	r2,-26928(gp)
 4005bf8:	10800298 	cmpnei	r2,r2,10
 4005bfc:	10000a1e 	bne	r2,zero,4005c28 <timer_0_ISR+0x48>
	{
		Overflows = 0;
 4005c00:	d025b415 	stw	zero,-26928(gp)
		IOWR(SERVO_0_BASE, 0, Translate); // Unable to run all 6 Servo's due to power limitations
 4005c04:	d0e5b617 	ldw	r3,-26920(gp)
 4005c08:	00820034 	movhi	r2,2048
 4005c0c:	10c41c35 	stwio	r3,4208(r2)
		// Adding more Servo's currently would hurt performance.
		IOWR_ALTERA_AVALON_TIMER_CONTROL(TIMER_0_BASE, IORD_ALTERA_AVALON_TIMER_CONTROL(TIMER_0_BASE) & (0xFFFD));
 4005c10:	00820034 	movhi	r2,2048
 4005c14:	10840937 	ldwio	r2,4132(r2)
 4005c18:	10ffff4c 	andi	r3,r2,65533
 4005c1c:	00820034 	movhi	r2,2048
 4005c20:	10c40935 	stwio	r3,4132(r2)
 4005c24:	00000606 	br	4005c40 <timer_0_ISR+0x60>
	}
	else
	{
		IOWR(SERVO_0_BASE, 0, 0x0);
 4005c28:	0007883a 	mov	r3,zero
 4005c2c:	00820034 	movhi	r2,2048
 4005c30:	10c41c35 	stwio	r3,4208(r2)
		Overflows++;
 4005c34:	d0a5b417 	ldw	r2,-26928(gp)
 4005c38:	10800044 	addi	r2,r2,1
 4005c3c:	d0a5b415 	stw	r2,-26928(gp)
	}

   // clear irq
   IOWR_ALTERA_AVALON_TIMER_STATUS(TIMER_0_BASE, 0);
 4005c40:	0007883a 	mov	r3,zero
 4005c44:	00820034 	movhi	r2,2048
 4005c48:	10c40835 	stwio	r3,4128(r2)
}
 4005c4c:	0001883a 	nop
 4005c50:	e037883a 	mov	sp,fp
 4005c54:	df000017 	ldw	fp,0(sp)
 4005c58:	dec00104 	addi	sp,sp,4
 4005c5c:	f800283a 	ret

04005c60 <timer_1_ISR>:

void timer_1_ISR(void *context, alt_32 id)
{
 4005c60:	defffd04 	addi	sp,sp,-12
 4005c64:	df000215 	stw	fp,8(sp)
 4005c68:	df000204 	addi	fp,sp,8
 4005c6c:	e13fff15 	stw	r4,-4(fp)
 4005c70:	e17ffe15 	stw	r5,-8(fp)
	if (Overflows == 13)
 4005c74:	d0a5b417 	ldw	r2,-26928(gp)
 4005c78:	10800358 	cmpnei	r2,r2,13
 4005c7c:	10000a1e 	bne	r2,zero,4005ca8 <timer_1_ISR+0x48>
	{
		IOWR(SERVO_0_BASE, 0, 0x7);	// SERVO_0_BASE
 4005c80:	00c001c4 	movi	r3,7
 4005c84:	00820034 	movhi	r2,2048
 4005c88:	10c41c35 	stwio	r3,4208(r2)
		Overflows = 0;
 4005c8c:	d025b415 	stw	zero,-26928(gp)
		IOWR_ALTERA_AVALON_TIMER_CONTROL(TIMER_1_BASE, IORD_ALTERA_AVALON_TIMER_CONTROL(TIMER_1_BASE) & (0xFFFD));
 4005c90:	00820034 	movhi	r2,2048
 4005c94:	10840137 	ldwio	r2,4100(r2)
 4005c98:	10ffff4c 	andi	r3,r2,65533
 4005c9c:	00820034 	movhi	r2,2048
 4005ca0:	10c40135 	stwio	r3,4100(r2)
 4005ca4:	00000606 	br	4005cc0 <timer_1_ISR+0x60>
	}
	else
	{
		IOWR(SERVO_0_BASE, 0, 0);	// SERVO_0_BASE
 4005ca8:	0007883a 	mov	r3,zero
 4005cac:	00820034 	movhi	r2,2048
 4005cb0:	10c41c35 	stwio	r3,4208(r2)
		Overflows++;
 4005cb4:	d0a5b417 	ldw	r2,-26928(gp)
 4005cb8:	10800044 	addi	r2,r2,1
 4005cbc:	d0a5b415 	stw	r2,-26928(gp)
	}

   // clear irq
   IOWR_ALTERA_AVALON_TIMER_STATUS(TIMER_1_BASE, 0);
 4005cc0:	0007883a 	mov	r3,zero
 4005cc4:	00820034 	movhi	r2,2048
 4005cc8:	10c40035 	stwio	r3,4096(r2)
}
 4005ccc:	0001883a 	nop
 4005cd0:	e037883a 	mov	sp,fp
 4005cd4:	df000017 	ldw	fp,0(sp)
 4005cd8:	dec00104 	addi	sp,sp,4
 4005cdc:	f800283a 	ret

04005ce0 <timer_2_ISR>:

void timer_2_ISR(void *context, alt_32 id)
{
 4005ce0:	defffd04 	addi	sp,sp,-12
 4005ce4:	df000215 	stw	fp,8(sp)
 4005ce8:	df000204 	addi	fp,sp,8
 4005cec:	e13fff15 	stw	r4,-4(fp)
 4005cf0:	e17ffe15 	stw	r5,-8(fp)
	if (Overflows == 1)
 4005cf4:	d0a5b417 	ldw	r2,-26928(gp)
 4005cf8:	10800058 	cmpnei	r2,r2,1
 4005cfc:	1000081e 	bne	r2,zero,4005d20 <timer_2_ISR+0x40>
	{
		IOWR(PIEZO_0_BASE, 0, 0x0);	// SERVO_0_BASE
 4005d00:	0007883a 	mov	r3,zero
 4005d04:	00820034 	movhi	r2,2048
 4005d08:	10c42035 	stwio	r3,4224(r2)
		Overflows = 0;
 4005d0c:	d025b415 	stw	zero,-26928(gp)
		IOWR_ALTERA_AVALON_TIMER_CONTROL(TIMER_2_BASE, IORD_ALTERA_AVALON_TIMER_CONTROL(TIMER_2_BASE) & (0xFFFD));
 4005d10:	00800137 	ldwio	r2,4(zero)
 4005d14:	10bfff4c 	andi	r2,r2,65533
 4005d18:	00800135 	stwio	r2,4(zero)
 4005d1c:	00000606 	br	4005d38 <timer_2_ISR+0x58>
	}
	else
	{
		IOWR(PIEZO_0_BASE, 0, 1);	// SERVO_0_BASE
 4005d20:	00c00044 	movi	r3,1
 4005d24:	00820034 	movhi	r2,2048
 4005d28:	10c42035 	stwio	r3,4224(r2)
		Overflows++;
 4005d2c:	d0a5b417 	ldw	r2,-26928(gp)
 4005d30:	10800044 	addi	r2,r2,1
 4005d34:	d0a5b415 	stw	r2,-26928(gp)
	}

   // clear irq
   IOWR_ALTERA_AVALON_TIMER_STATUS(TIMER_2_BASE, 0);
 4005d38:	0005883a 	mov	r2,zero
 4005d3c:	00800035 	stwio	r2,0(zero)
}
 4005d40:	0001883a 	nop
 4005d44:	e037883a 	mov	sp,fp
 4005d48:	df000017 	ldw	fp,0(sp)
 4005d4c:	dec00104 	addi	sp,sp,4
 4005d50:	f800283a 	ret

04005d54 <main>:

int main()
{
 4005d54:	defffc04 	addi	sp,sp,-16
 4005d58:	dfc00315 	stw	ra,12(sp)
 4005d5c:	df000215 	stw	fp,8(sp)
 4005d60:	df000204 	addi	fp,sp,8
  //Timer Setup
  IOWR_ALTERA_AVALON_TIMER_CONTROL(TIMER_0_BASE, ALTERA_AVALON_TIMER_CONTROL_CONT_MSK | ALTERA_AVALON_TIMER_CONTROL_START_MSK | ALTERA_AVALON_TIMER_CONTROL_ITO_MSK);
 4005d64:	00c001c4 	movi	r3,7
 4005d68:	00820034 	movhi	r2,2048
 4005d6c:	10c40935 	stwio	r3,4132(r2)

  IOWR_ALTERA_AVALON_TIMER_STATUS(TIMER_0_BASE, 0);    // Clear IRQ status
 4005d70:	0007883a 	mov	r3,zero
 4005d74:	00820034 	movhi	r2,2048
 4005d78:	10c40835 	stwio	r3,4128(r2)
  IOWR_ALTERA_AVALON_TIMER_PERIODL(TIMER_0_BASE, 0x5F00); //0x28
 4005d7c:	00d7c004 	movi	r3,24320
 4005d80:	00820034 	movhi	r2,2048
 4005d84:	10c40a35 	stwio	r3,4136(r2)
  IOWR_ALTERA_AVALON_TIMER_PERIODH(TIMER_0_BASE, 0x1); //0x8
 4005d88:	00c00044 	movi	r3,1
 4005d8c:	00820034 	movhi	r2,2048
 4005d90:	10c40b35 	stwio	r3,4140(r2)

  alt_irq_register(TIMER_0_IRQ, 0, timer_0_ISR);	//Set up ISR
 4005d94:	01810034 	movhi	r6,1024
 4005d98:	3196f804 	addi	r6,r6,23520
 4005d9c:	000b883a 	mov	r5,zero
 4005da0:	01000084 	movi	r4,2
 4005da4:	40004c80 	call	40004c8 <alt_irq_register>

  IOWR_ALTERA_AVALON_TIMER_CONTROL(TIMER_1_BASE, ALTERA_AVALON_TIMER_CONTROL_CONT_MSK | ALTERA_AVALON_TIMER_CONTROL_START_MSK | ALTERA_AVALON_TIMER_CONTROL_ITO_MSK);
 4005da8:	00c001c4 	movi	r3,7
 4005dac:	00820034 	movhi	r2,2048
 4005db0:	10c40135 	stwio	r3,4100(r2)

  IOWR_ALTERA_AVALON_TIMER_STATUS(TIMER_1_BASE, 0);    // Clear IRQ status
 4005db4:	0007883a 	mov	r3,zero
 4005db8:	00820034 	movhi	r2,2048
 4005dbc:	10c40035 	stwio	r3,4096(r2)
  IOWR_ALTERA_AVALON_TIMER_PERIODL(TIMER_1_BASE, 0x20C0); //0x28
 4005dc0:	00c83004 	movi	r3,8384
 4005dc4:	00820034 	movhi	r2,2048
 4005dc8:	10c40235 	stwio	r3,4104(r2)
  IOWR_ALTERA_AVALON_TIMER_PERIODH(TIMER_1_BASE, 0x1); //0x8
 4005dcc:	00c00044 	movi	r3,1
 4005dd0:	00820034 	movhi	r2,2048
 4005dd4:	10c40335 	stwio	r3,4108(r2)

  alt_irq_register(TIMER_1_IRQ, 0, timer_1_ISR);	//Set up ISR
 4005dd8:	01810034 	movhi	r6,1024
 4005ddc:	31971804 	addi	r6,r6,23648
 4005de0:	000b883a 	mov	r5,zero
 4005de4:	010000c4 	movi	r4,3
 4005de8:	40004c80 	call	40004c8 <alt_irq_register>

  IOWR_ALTERA_AVALON_TIMER_CONTROL(TIMER_2_BASE, ALTERA_AVALON_TIMER_CONTROL_CONT_MSK | ALTERA_AVALON_TIMER_CONTROL_START_MSK | ALTERA_AVALON_TIMER_CONTROL_ITO_MSK);
 4005dec:	008001c4 	movi	r2,7
 4005df0:	00800135 	stwio	r2,4(zero)

  IOWR_ALTERA_AVALON_TIMER_STATUS(TIMER_2_BASE, 0);    // Clear IRQ status
 4005df4:	0005883a 	mov	r2,zero
 4005df8:	00800035 	stwio	r2,0(zero)
  IOWR_ALTERA_AVALON_TIMER_PERIODL(TIMER_2_BASE, 0x28); //0x28
 4005dfc:	00800a04 	movi	r2,40
 4005e00:	00800235 	stwio	r2,8(zero)
  IOWR_ALTERA_AVALON_TIMER_PERIODH(TIMER_2_BASE, 0x0); //0x8
 4005e04:	0005883a 	mov	r2,zero
 4005e08:	00800335 	stwio	r2,12(zero)

  alt_irq_register(TIMER_2_IRQ, 0, timer_2_ISR);	//Set up ISR
 4005e0c:	01810034 	movhi	r6,1024
 4005e10:	31973804 	addi	r6,r6,23776
 4005e14:	000b883a 	mov	r5,zero
 4005e18:	01000104 	movi	r4,4
 4005e1c:	40004c80 	call	40004c8 <alt_irq_register>

  xTaskCreate(task1, "task1", 512, NULL, 2, NULL);	// Create task to handle Switches and other core components
 4005e20:	d8000115 	stw	zero,4(sp)
 4005e24:	00800084 	movi	r2,2
 4005e28:	d8800015 	stw	r2,0(sp)
 4005e2c:	000f883a 	mov	r7,zero
 4005e30:	01808004 	movi	r6,512
 4005e34:	01410074 	movhi	r5,1025
 4005e38:	29608204 	addi	r5,r5,-32248
 4005e3c:	01010034 	movhi	r4,1024
 4005e40:	2117a304 	addi	r4,r4,24204
 4005e44:	40034980 	call	4003498 <xTaskCreate>
  xTaskCreate(task2, "task2", 512, NULL, 2, NULL);	// Create task to handle Hex display
 4005e48:	d8000115 	stw	zero,4(sp)
 4005e4c:	00800084 	movi	r2,2
 4005e50:	d8800015 	stw	r2,0(sp)
 4005e54:	000f883a 	mov	r7,zero
 4005e58:	01808004 	movi	r6,512
 4005e5c:	01410074 	movhi	r5,1025
 4005e60:	29608404 	addi	r5,r5,-32240
 4005e64:	01010034 	movhi	r4,1024
 4005e68:	21188204 	addi	r4,r4,25096
 4005e6c:	40034980 	call	4003498 <xTaskCreate>
  vTaskStartScheduler();	// Start Tasks
 4005e70:	40040280 	call	4004028 <vTaskStartScheduler>

  return 0;
 4005e74:	0005883a 	mov	r2,zero
}
 4005e78:	e037883a 	mov	sp,fp
 4005e7c:	dfc00117 	ldw	ra,4(sp)
 4005e80:	df000017 	ldw	fp,0(sp)
 4005e84:	dec00204 	addi	sp,sp,8
 4005e88:	f800283a 	ret

04005e8c <task1>:

void task1(void *p)
{
 4005e8c:	defffd04 	addi	sp,sp,-12
 4005e90:	dfc00215 	stw	ra,8(sp)
 4005e94:	df000115 	stw	fp,4(sp)
 4005e98:	df000104 	addi	fp,sp,4
 4005e9c:	e13fff15 	stw	r4,-4(fp)
	while(1)
	{
		Translate = Switch();	// Receive Switches translation
 4005ea0:	4005ec40 	call	4005ec4 <Switch>
 4005ea4:	d0a5b615 	stw	r2,-26920(gp)
		if (Go == 1)
 4005ea8:	d0a5b517 	ldw	r2,-26924(gp)
 4005eac:	10800058 	cmpnei	r2,r2,1
 4005eb0:	103ffb1e 	bne	r2,zero,4005ea0 <task1+0x14>
		{
			ServoControl(Translate);	// Send the data to the Servo's
 4005eb4:	d0a5b617 	ldw	r2,-26920(gp)
 4005eb8:	1009883a 	mov	r4,r2
 4005ebc:	400612c0 	call	400612c <ServoControl>
		Translate = Switch();	// Receive Switches translation
 4005ec0:	003ff706 	br	4005ea0 <task1+0x14>

04005ec4 <Switch>:
		}
	}
}

int Switch()
{
 4005ec4:	defffb04 	addi	sp,sp,-20
 4005ec8:	dfc00415 	stw	ra,16(sp)
 4005ecc:	df000315 	stw	fp,12(sp)
 4005ed0:	df000304 	addi	fp,sp,12
	int SW = IORD(SW_0_BASE, 0);	// Read switches
 4005ed4:	00820034 	movhi	r2,2048
 4005ed8:	10842437 	ldwio	r2,4240(r2)
 4005edc:	e0bffe15 	stw	r2,-8(fp)
	char Character;	// Character being translated
	int Result;	// End result

	if((SW & 0x8) > 0)
 4005ee0:	e0bffe17 	ldw	r2,-8(fp)
 4005ee4:	1080020c 	andi	r2,r2,8
 4005ee8:	0080270e 	bge	zero,r2,4005f88 <Switch+0xc4>
	{
		switch(SW & 0x7)	//Encode into ASCII character
 4005eec:	e0bffe17 	ldw	r2,-8(fp)
 4005ef0:	108001cc 	andi	r2,r2,7
 4005ef4:	10c001a8 	cmpgeui	r3,r2,6
 4005ef8:	18001d1e 	bne	r3,zero,4005f70 <Switch+0xac>
 4005efc:	100690ba 	slli	r3,r2,2
 4005f00:	00810034 	movhi	r2,1024
 4005f04:	1885883a 	add	r2,r3,r2
 4005f08:	1097c417 	ldw	r2,24336(r2)
 4005f0c:	1000683a 	jmp	r2
 4005f10:	04005f28 	cmpgeui	r16,zero,380
 4005f14:	04005f34 	movhi	r16,380
 4005f18:	04005f40 	call	4005f4 <__alt_mem_sdram-0x3bffa0c>
 4005f1c:	04005f4c 	andi	r16,zero,381
 4005f20:	04005f58 	cmpnei	r16,zero,381
 4005f24:	04005f64 	muli	r16,zero,381
		{
			case 0:
				Character = 'A';
 4005f28:	00801044 	movi	r2,65
 4005f2c:	e0bfffc5 	stb	r2,-1(fp)
				break;
 4005f30:	00001206 	br	4005f7c <Switch+0xb8>
			case 1:
				Character = 'B';
 4005f34:	00801084 	movi	r2,66
 4005f38:	e0bfffc5 	stb	r2,-1(fp)
				break;
 4005f3c:	00000f06 	br	4005f7c <Switch+0xb8>
			case 2:
				Character = 'C';
 4005f40:	008010c4 	movi	r2,67
 4005f44:	e0bfffc5 	stb	r2,-1(fp)
				break;
 4005f48:	00000c06 	br	4005f7c <Switch+0xb8>
			case 3:
				Character = 'D';
 4005f4c:	00801104 	movi	r2,68
 4005f50:	e0bfffc5 	stb	r2,-1(fp)
				break;
 4005f54:	00000906 	br	4005f7c <Switch+0xb8>
			case 4:
				Character = 'E';
 4005f58:	00801144 	movi	r2,69
 4005f5c:	e0bfffc5 	stb	r2,-1(fp)
				break;
 4005f60:	00000606 	br	4005f7c <Switch+0xb8>
			case 5:
				Character = 'F';
 4005f64:	00801184 	movi	r2,70
 4005f68:	e0bfffc5 	stb	r2,-1(fp)
				break;
 4005f6c:	00000306 	br	4005f7c <Switch+0xb8>
			default:
				Character = 'X';
 4005f70:	00801604 	movi	r2,88
 4005f74:	e0bfffc5 	stb	r2,-1(fp)
				break;
 4005f78:	0001883a 	nop
		}
		Go = 1;
 4005f7c:	00800044 	movi	r2,1
 4005f80:	d0a5b515 	stw	r2,-26924(gp)
 4005f84:	00000106 	br	4005f8c <Switch+0xc8>
	}
	else
	{
		Go = 0;
 4005f88:	d025b515 	stw	zero,-26924(gp)
	}
	HexDecode(Character);	// Decode character for the Hex Display
 4005f8c:	e0bfffc7 	ldb	r2,-1(fp)
 4005f90:	1009883a 	mov	r4,r2
 4005f94:	4005fc00 	call	4005fc0 <HexDecode>
	Result = TranslateDecode(Character); // Decode data for the Servo's
 4005f98:	e0bfffc7 	ldb	r2,-1(fp)
 4005f9c:	1009883a 	mov	r4,r2
 4005fa0:	40060780 	call	4006078 <TranslateDecode>
 4005fa4:	e0bffd15 	stw	r2,-12(fp)

	return Result;
 4005fa8:	e0bffd17 	ldw	r2,-12(fp)
}
 4005fac:	e037883a 	mov	sp,fp
 4005fb0:	dfc00117 	ldw	ra,4(sp)
 4005fb4:	df000017 	ldw	fp,0(sp)
 4005fb8:	dec00204 	addi	sp,sp,8
 4005fbc:	f800283a 	ret

04005fc0 <HexDecode>:

void HexDecode(char decode)
{
 4005fc0:	defffe04 	addi	sp,sp,-8
 4005fc4:	df000115 	stw	fp,4(sp)
 4005fc8:	df000104 	addi	fp,sp,4
 4005fcc:	2005883a 	mov	r2,r4
 4005fd0:	e0bfff05 	stb	r2,-4(fp)
	switch(decode)	// Decode for Hex display
 4005fd4:	e0bfff07 	ldb	r2,-4(fp)
 4005fd8:	10bfefc4 	addi	r2,r2,-65
 4005fdc:	10c001a8 	cmpgeui	r3,r2,6
 4005fe0:	18001d1e 	bne	r3,zero,4006058 <HexDecode+0x98>
 4005fe4:	100690ba 	slli	r3,r2,2
 4005fe8:	00810034 	movhi	r2,1024
 4005fec:	1885883a 	add	r2,r3,r2
 4005ff0:	1097fe17 	ldw	r2,24568(r2)
 4005ff4:	1000683a 	jmp	r2
 4005ff8:	04006010 	cmplti	r16,zero,384
 4005ffc:	0400601c 	xori	r16,zero,384
 4006000:	04006028 	cmpgeui	r16,zero,384
 4006004:	04006034 	movhi	r16,384
 4006008:	04006040 	call	400604 <__alt_mem_sdram-0x3bff9fc>
 400600c:	0400604c 	andi	r16,zero,385
		{
			case 'A':
				Display = 0b0001000;
 4006010:	00800204 	movi	r2,8
 4006014:	d0a00005 	stb	r2,-32768(gp)
				break;
 4006018:	00001206 	br	4006064 <HexDecode+0xa4>
			case 'B':
				Display = 0b0000011;
 400601c:	008000c4 	movi	r2,3
 4006020:	d0a00005 	stb	r2,-32768(gp)
				break;
 4006024:	00000f06 	br	4006064 <HexDecode+0xa4>
			case 'C':
				Display = 0b1000110;
 4006028:	00801184 	movi	r2,70
 400602c:	d0a00005 	stb	r2,-32768(gp)
				break;
 4006030:	00000c06 	br	4006064 <HexDecode+0xa4>
			case 'D':
				Display = 0b0100001;
 4006034:	00800844 	movi	r2,33
 4006038:	d0a00005 	stb	r2,-32768(gp)
				break;
 400603c:	00000906 	br	4006064 <HexDecode+0xa4>
			case 'E':
				Display = 0b0000110;
 4006040:	00800184 	movi	r2,6
 4006044:	d0a00005 	stb	r2,-32768(gp)
				break;
 4006048:	00000606 	br	4006064 <HexDecode+0xa4>
			case 'F':
				Display = 0b0001110;
 400604c:	00800384 	movi	r2,14
 4006050:	d0a00005 	stb	r2,-32768(gp)
				break;
 4006054:	00000306 	br	4006064 <HexDecode+0xa4>
			default:
				Display = 0b1000000;
 4006058:	00801004 	movi	r2,64
 400605c:	d0a00005 	stb	r2,-32768(gp)
				break;
 4006060:	0001883a 	nop
		}
}
 4006064:	0001883a 	nop
 4006068:	e037883a 	mov	sp,fp
 400606c:	df000017 	ldw	fp,0(sp)
 4006070:	dec00104 	addi	sp,sp,4
 4006074:	f800283a 	ret

04006078 <TranslateDecode>:

int TranslateDecode(char decode)
{
 4006078:	defffd04 	addi	sp,sp,-12
 400607c:	df000215 	stw	fp,8(sp)
 4006080:	df000204 	addi	fp,sp,8
 4006084:	2005883a 	mov	r2,r4
 4006088:	e0bffe05 	stb	r2,-8(fp)
	int num;
	switch(decode)	// Decode for Servo's
 400608c:	e0bffe07 	ldb	r2,-8(fp)
 4006090:	10bfefc4 	addi	r2,r2,-65
 4006094:	10c001a8 	cmpgeui	r3,r2,6
 4006098:	18001d1e 	bne	r3,zero,4006110 <TranslateDecode+0x98>
 400609c:	100690ba 	slli	r3,r2,2
 40060a0:	00810034 	movhi	r2,1024
 40060a4:	1885883a 	add	r2,r3,r2
 40060a8:	10982c17 	ldw	r2,24752(r2)
 40060ac:	1000683a 	jmp	r2
 40060b0:	040060c8 	cmpgei	r16,zero,387
 40060b4:	040060d4 	movui	r16,387
 40060b8:	040060e0 	cmpeqi	r16,zero,387
 40060bc:	040060ec 	andhi	r16,zero,387
 40060c0:	040060f8 	rdprs	r16,zero,387
 40060c4:	04006104 	movi	r16,388
	{
		case 'A':
			num = 0b000001;
 40060c8:	00800044 	movi	r2,1
 40060cc:	e0bfff15 	stw	r2,-4(fp)
			break;
 40060d0:	00001106 	br	4006118 <TranslateDecode+0xa0>
		case 'B':
			num = 0b000101;
 40060d4:	00800144 	movi	r2,5
 40060d8:	e0bfff15 	stw	r2,-4(fp)
			break;
 40060dc:	00000e06 	br	4006118 <TranslateDecode+0xa0>
		case 'C':
			num = 0b000011;
 40060e0:	008000c4 	movi	r2,3
 40060e4:	e0bfff15 	stw	r2,-4(fp)
			break;
 40060e8:	00000b06 	br	4006118 <TranslateDecode+0xa0>
		case 'D':
			num = 0b001011;
 40060ec:	008002c4 	movi	r2,11
 40060f0:	e0bfff15 	stw	r2,-4(fp)
			break;
 40060f4:	00000806 	br	4006118 <TranslateDecode+0xa0>
		case 'E':
			num = 0b001001;
 40060f8:	00800244 	movi	r2,9
 40060fc:	e0bfff15 	stw	r2,-4(fp)
			break;
 4006100:	00000506 	br	4006118 <TranslateDecode+0xa0>
		case 'F':
			num = 0b000111;
 4006104:	008001c4 	movi	r2,7
 4006108:	e0bfff15 	stw	r2,-4(fp)
			break;
 400610c:	00000206 	br	4006118 <TranslateDecode+0xa0>
		default:
			num = 0b000000;
 4006110:	e03fff15 	stw	zero,-4(fp)
			break;
 4006114:	0001883a 	nop
	}
	return num;
 4006118:	e0bfff17 	ldw	r2,-4(fp)
}
 400611c:	e037883a 	mov	sp,fp
 4006120:	df000017 	ldw	fp,0(sp)
 4006124:	dec00104 	addi	sp,sp,4
 4006128:	f800283a 	ret

0400612c <ServoControl>:

void ServoControl()
{
 400612c:	defffd04 	addi	sp,sp,-12
 4006130:	dfc00215 	stw	ra,8(sp)
 4006134:	df000115 	stw	fp,4(sp)
 4006138:	df000104 	addi	fp,sp,4
	int Ninety = 0;
 400613c:	e03fff15 	stw	zero,-4(fp)
	while(Ninety != 5)
 4006140:	00000a06 	br	400616c <ServoControl+0x40>
	{
		IOWR_ALTERA_AVALON_TIMER_CONTROL(TIMER_0_BASE, 0x7 | IORD_ALTERA_AVALON_TIMER_CONTROL(TIMER_0_BASE));	// Start timer for PWM
 4006144:	00820034 	movhi	r2,2048
 4006148:	10840937 	ldwio	r2,4132(r2)
 400614c:	10c001d4 	ori	r3,r2,7
 4006150:	00820034 	movhi	r2,2048
 4006154:	10c40935 	stwio	r3,4132(r2)
		vTaskDelay(1000);
 4006158:	0100fa04 	movi	r4,1000
 400615c:	4003a480 	call	4003a48 <vTaskDelay>
		Ninety++;
 4006160:	e0bfff17 	ldw	r2,-4(fp)
 4006164:	10800044 	addi	r2,r2,1
 4006168:	e0bfff15 	stw	r2,-4(fp)
	while(Ninety != 5)
 400616c:	e0bfff17 	ldw	r2,-4(fp)
 4006170:	10800158 	cmpnei	r2,r2,5
 4006174:	103ff31e 	bne	r2,zero,4006144 <ServoControl+0x18>
	}
	vTaskDelay(5000);
 4006178:	0104e204 	movi	r4,5000
 400617c:	4003a480 	call	4003a48 <vTaskDelay>
	Ninety = 0;
 4006180:	e03fff15 	stw	zero,-4(fp)
	while (Ninety != 100000)
 4006184:	00000606 	br	40061a0 <ServoControl+0x74>
	{
		IOWR_ALTERA_AVALON_TIMER_CONTROL(TIMER_2_BASE, 0x7 | IORD_ALTERA_AVALON_TIMER_CONTROL(TIMER_2_BASE));	// Start timer for PWM
 4006188:	00800137 	ldwio	r2,4(zero)
 400618c:	108001d4 	ori	r2,r2,7
 4006190:	00800135 	stwio	r2,4(zero)
		Ninety++;
 4006194:	e0bfff17 	ldw	r2,-4(fp)
 4006198:	10800044 	addi	r2,r2,1
 400619c:	e0bfff15 	stw	r2,-4(fp)
	while (Ninety != 100000)
 40061a0:	e0ffff17 	ldw	r3,-4(fp)
 40061a4:	008000b4 	movhi	r2,2
 40061a8:	10a1a804 	addi	r2,r2,-31072
 40061ac:	18bff61e 	bne	r3,r2,4006188 <ServoControl+0x5c>
	//vTaskDelay(1000);
	}
	Ninety = 0;
 40061b0:	e03fff15 	stw	zero,-4(fp)
	while(Ninety != 5)
 40061b4:	00000a06 	br	40061e0 <ServoControl+0xb4>
	{
		IOWR_ALTERA_AVALON_TIMER_CONTROL(TIMER_1_BASE, 0x7 | IORD_ALTERA_AVALON_TIMER_CONTROL(TIMER_1_BASE));	// Start timer for PWM
 40061b8:	00820034 	movhi	r2,2048
 40061bc:	10840137 	ldwio	r2,4100(r2)
 40061c0:	10c001d4 	ori	r3,r2,7
 40061c4:	00820034 	movhi	r2,2048
 40061c8:	10c40135 	stwio	r3,4100(r2)
		vTaskDelay(1000);
 40061cc:	0100fa04 	movi	r4,1000
 40061d0:	4003a480 	call	4003a48 <vTaskDelay>
		Ninety++;
 40061d4:	e0bfff17 	ldw	r2,-4(fp)
 40061d8:	10800044 	addi	r2,r2,1
 40061dc:	e0bfff15 	stw	r2,-4(fp)
	while(Ninety != 5)
 40061e0:	e0bfff17 	ldw	r2,-4(fp)
 40061e4:	10800158 	cmpnei	r2,r2,5
 40061e8:	103ff31e 	bne	r2,zero,40061b8 <ServoControl+0x8c>
	}
}
 40061ec:	0001883a 	nop
 40061f0:	0001883a 	nop
 40061f4:	e037883a 	mov	sp,fp
 40061f8:	dfc00117 	ldw	ra,4(sp)
 40061fc:	df000017 	ldw	fp,0(sp)
 4006200:	dec00204 	addi	sp,sp,8
 4006204:	f800283a 	ret

04006208 <task2>:

void task2(void *p)
{
 4006208:	defffe04 	addi	sp,sp,-8
 400620c:	df000115 	stw	fp,4(sp)
 4006210:	df000104 	addi	fp,sp,4
 4006214:	e13fff15 	stw	r4,-4(fp)
	while(1)
	{
		IOWR(HEX_0_BASE, 0, Display);	// Write to Hex Display
 4006218:	d0a00003 	ldbu	r2,-32768(gp)
 400621c:	10c03fcc 	andi	r3,r2,255
 4006220:	18c0201c 	xori	r3,r3,128
 4006224:	18ffe004 	addi	r3,r3,-128
 4006228:	00820034 	movhi	r2,2048
 400622c:	10c42835 	stwio	r3,4256(r2)
 4006230:	003ff906 	br	4006218 <task2+0x10>

04006234 <memcpy>:
 4006234:	30c00430 	cmpltui	r3,r6,16
 4006238:	2005883a 	mov	r2,r4
 400623c:	18002d1e 	bne	r3,zero,40062f4 <memcpy+0xc0>
 4006240:	2906b03a 	or	r3,r5,r4
 4006244:	18c000cc 	andi	r3,r3,3
 4006248:	1800351e 	bne	r3,zero,4006320 <memcpy+0xec>
 400624c:	32fffc04 	addi	r11,r6,-16
 4006250:	5816d13a 	srli	r11,r11,4
 4006254:	280f883a 	mov	r7,r5
 4006258:	2007883a 	mov	r3,r4
 400625c:	5ac00044 	addi	r11,r11,1
 4006260:	5816913a 	slli	r11,r11,4
 4006264:	22d5883a 	add	r10,r4,r11
 4006268:	39000117 	ldw	r4,4(r7)
 400626c:	3a400017 	ldw	r9,0(r7)
 4006270:	3a000217 	ldw	r8,8(r7)
 4006274:	19000115 	stw	r4,4(r3)
 4006278:	39000317 	ldw	r4,12(r7)
 400627c:	1a400015 	stw	r9,0(r3)
 4006280:	1a000215 	stw	r8,8(r3)
 4006284:	19000315 	stw	r4,12(r3)
 4006288:	18c00404 	addi	r3,r3,16
 400628c:	39c00404 	addi	r7,r7,16
 4006290:	50fff51e 	bne	r10,r3,4006268 <memcpy+0x34>
 4006294:	3100030c 	andi	r4,r6,12
 4006298:	2acb883a 	add	r5,r5,r11
 400629c:	320003cc 	andi	r8,r6,15
 40062a0:	20002226 	beq	r4,zero,400632c <memcpy+0xf8>
 40062a4:	280f883a 	mov	r7,r5
 40062a8:	1813883a 	mov	r9,r3
 40062ac:	39c00104 	addi	r7,r7,4
 40062b0:	3abfff17 	ldw	r10,-4(r7)
 40062b4:	41c9c83a 	sub	r4,r8,r7
 40062b8:	2909883a 	add	r4,r5,r4
 40062bc:	4a800015 	stw	r10,0(r9)
 40062c0:	21000128 	cmpgeui	r4,r4,4
 40062c4:	4a400104 	addi	r9,r9,4
 40062c8:	203ff81e 	bne	r4,zero,40062ac <memcpy+0x78>
 40062cc:	413fff04 	addi	r4,r8,-4
 40062d0:	2008d0ba 	srli	r4,r4,2
 40062d4:	318000cc 	andi	r6,r6,3
 40062d8:	31ffffc4 	addi	r7,r6,-1
 40062dc:	21000044 	addi	r4,r4,1
 40062e0:	200890ba 	slli	r4,r4,2
 40062e4:	1907883a 	add	r3,r3,r4
 40062e8:	290b883a 	add	r5,r5,r4
 40062ec:	3000041e 	bne	r6,zero,4006300 <memcpy+0xcc>
 40062f0:	f800283a 	ret
 40062f4:	2007883a 	mov	r3,r4
 40062f8:	31ffffc4 	addi	r7,r6,-1
 40062fc:	303ffc26 	beq	r6,zero,40062f0 <memcpy+0xbc>
 4006300:	39c00044 	addi	r7,r7,1
 4006304:	19cf883a 	add	r7,r3,r7
 4006308:	29800003 	ldbu	r6,0(r5)
 400630c:	18c00044 	addi	r3,r3,1
 4006310:	29400044 	addi	r5,r5,1
 4006314:	19bfffc5 	stb	r6,-1(r3)
 4006318:	38fffb1e 	bne	r7,r3,4006308 <memcpy+0xd4>
 400631c:	f800283a 	ret
 4006320:	31ffffc4 	addi	r7,r6,-1
 4006324:	2007883a 	mov	r3,r4
 4006328:	003ff506 	br	4006300 <memcpy+0xcc>
 400632c:	400d883a 	mov	r6,r8
 4006330:	003ff106 	br	40062f8 <memcpy+0xc4>

04006334 <memset>:
 4006334:	20c000cc 	andi	r3,r4,3
 4006338:	2005883a 	mov	r2,r4
 400633c:	18003626 	beq	r3,zero,4006418 <memset+0xe4>
 4006340:	31ffffc4 	addi	r7,r6,-1
 4006344:	30003326 	beq	r6,zero,4006414 <memset+0xe0>
 4006348:	2811883a 	mov	r8,r5
 400634c:	2007883a 	mov	r3,r4
 4006350:	00000306 	br	4006360 <memset+0x2c>
 4006354:	39ffffc4 	addi	r7,r7,-1
 4006358:	39bfffe0 	cmpeqi	r6,r7,-1
 400635c:	30002d1e 	bne	r6,zero,4006414 <memset+0xe0>
 4006360:	18c00044 	addi	r3,r3,1
 4006364:	198000cc 	andi	r6,r3,3
 4006368:	1a3fffc5 	stb	r8,-1(r3)
 400636c:	303ff91e 	bne	r6,zero,4006354 <memset+0x20>
 4006370:	39000130 	cmpltui	r4,r7,4
 4006374:	2000221e 	bne	r4,zero,4006400 <memset+0xcc>
 4006378:	29003fcc 	andi	r4,r5,255
 400637c:	200c923a 	slli	r6,r4,8
 4006380:	3a000430 	cmpltui	r8,r7,16
 4006384:	3108b03a 	or	r4,r6,r4
 4006388:	200c943a 	slli	r6,r4,16
 400638c:	310cb03a 	or	r6,r6,r4
 4006390:	40000e1e 	bne	r8,zero,40063cc <memset+0x98>
 4006394:	393ffc04 	addi	r4,r7,-16
 4006398:	2008d13a 	srli	r4,r4,4
 400639c:	21000044 	addi	r4,r4,1
 40063a0:	2008913a 	slli	r4,r4,4
 40063a4:	1909883a 	add	r4,r3,r4
 40063a8:	19800015 	stw	r6,0(r3)
 40063ac:	19800115 	stw	r6,4(r3)
 40063b0:	19800215 	stw	r6,8(r3)
 40063b4:	19800315 	stw	r6,12(r3)
 40063b8:	18c00404 	addi	r3,r3,16
 40063bc:	20fffa1e 	bne	r4,r3,40063a8 <memset+0x74>
 40063c0:	3900030c 	andi	r4,r7,12
 40063c4:	39c003cc 	andi	r7,r7,15
 40063c8:	20000d26 	beq	r4,zero,4006400 <memset+0xcc>
 40063cc:	1811883a 	mov	r8,r3
 40063d0:	42000104 	addi	r8,r8,4
 40063d4:	3a09c83a 	sub	r4,r7,r8
 40063d8:	1909883a 	add	r4,r3,r4
 40063dc:	21000128 	cmpgeui	r4,r4,4
 40063e0:	41bfff15 	stw	r6,-4(r8)
 40063e4:	203ffa1e 	bne	r4,zero,40063d0 <memset+0x9c>
 40063e8:	393fff04 	addi	r4,r7,-4
 40063ec:	2008d0ba 	srli	r4,r4,2
 40063f0:	39c000cc 	andi	r7,r7,3
 40063f4:	21000044 	addi	r4,r4,1
 40063f8:	200890ba 	slli	r4,r4,2
 40063fc:	1907883a 	add	r3,r3,r4
 4006400:	38000426 	beq	r7,zero,4006414 <memset+0xe0>
 4006404:	19cf883a 	add	r7,r3,r7
 4006408:	18c00044 	addi	r3,r3,1
 400640c:	197fffc5 	stb	r5,-1(r3)
 4006410:	38fffd1e 	bne	r7,r3,4006408 <memset+0xd4>
 4006414:	f800283a 	ret
 4006418:	2007883a 	mov	r3,r4
 400641c:	300f883a 	mov	r7,r6
 4006420:	003fd306 	br	4006370 <memset+0x3c>

04006424 <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
 4006424:	defffc04 	addi	sp,sp,-16
 4006428:	df000315 	stw	fp,12(sp)
 400642c:	df000304 	addi	fp,sp,12
 4006430:	e13fff15 	stw	r4,-4(fp)
 4006434:	e17ffe15 	stw	r5,-8(fp)
 4006438:	e1bffd15 	stw	r6,-12(fp)
  if (to != from)
 400643c:	e0fffe17 	ldw	r3,-8(fp)
 4006440:	e0bfff17 	ldw	r2,-4(fp)
 4006444:	18800c26 	beq	r3,r2,4006478 <alt_load_section+0x54>
  {
    while( to != end )
 4006448:	00000806 	br	400646c <alt_load_section+0x48>
    {
      *to++ = *from++;
 400644c:	e0ffff17 	ldw	r3,-4(fp)
 4006450:	18800104 	addi	r2,r3,4
 4006454:	e0bfff15 	stw	r2,-4(fp)
 4006458:	e0bffe17 	ldw	r2,-8(fp)
 400645c:	11000104 	addi	r4,r2,4
 4006460:	e13ffe15 	stw	r4,-8(fp)
 4006464:	18c00017 	ldw	r3,0(r3)
 4006468:	10c00015 	stw	r3,0(r2)
    while( to != end )
 400646c:	e0fffe17 	ldw	r3,-8(fp)
 4006470:	e0bffd17 	ldw	r2,-12(fp)
 4006474:	18bff51e 	bne	r3,r2,400644c <alt_load_section+0x28>
    }
  }
}
 4006478:	0001883a 	nop
 400647c:	e037883a 	mov	sp,fp
 4006480:	df000017 	ldw	fp,0(sp)
 4006484:	dec00104 	addi	sp,sp,4
 4006488:	f800283a 	ret

0400648c <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
 400648c:	defffe04 	addi	sp,sp,-8
 4006490:	dfc00115 	stw	ra,4(sp)
 4006494:	df000015 	stw	fp,0(sp)
 4006498:	d839883a 	mov	fp,sp
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
 400649c:	01810074 	movhi	r6,1025
 40064a0:	31a62a04 	addi	r6,r6,-26456
 40064a4:	01410074 	movhi	r5,1025
 40064a8:	29609304 	addi	r5,r5,-32180
 40064ac:	01010074 	movhi	r4,1025
 40064b0:	21262a04 	addi	r4,r4,-26456
 40064b4:	40064240 	call	4006424 <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
 40064b8:	01810034 	movhi	r6,1024
 40064bc:	31809204 	addi	r6,r6,584
 40064c0:	01410034 	movhi	r5,1024
 40064c4:	29400804 	addi	r5,r5,32
 40064c8:	01010034 	movhi	r4,1024
 40064cc:	21000804 	addi	r4,r4,32
 40064d0:	40064240 	call	4006424 <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
 40064d4:	01810074 	movhi	r6,1025
 40064d8:	31a09304 	addi	r6,r6,-32180
 40064dc:	01410074 	movhi	r5,1025
 40064e0:	29608004 	addi	r5,r5,-32256
 40064e4:	01010074 	movhi	r4,1025
 40064e8:	21208004 	addi	r4,r4,-32256
 40064ec:	40064240 	call	4006424 <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
 40064f0:	40074040 	call	4007404 <alt_dcache_flush_all>
  alt_icache_flush_all();
 40064f4:	40076280 	call	4007628 <alt_icache_flush_all>
}
 40064f8:	0001883a 	nop
 40064fc:	e037883a 	mov	sp,fp
 4006500:	dfc00117 	ldw	ra,4(sp)
 4006504:	df000017 	ldw	fp,0(sp)
 4006508:	dec00204 	addi	sp,sp,8
 400650c:	f800283a 	ret

04006510 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 4006510:	defffd04 	addi	sp,sp,-12
 4006514:	dfc00215 	stw	ra,8(sp)
 4006518:	df000115 	stw	fp,4(sp)
 400651c:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 4006520:	0009883a 	mov	r4,zero
 4006524:	40065c00 	call	40065c0 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
 4006528:	0001883a 	nop
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
 400652c:	40065fc0 	call	40065fc <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
 4006530:	01810074 	movhi	r6,1025
 4006534:	31a08604 	addi	r6,r6,-32232
 4006538:	01410074 	movhi	r5,1025
 400653c:	29608604 	addi	r5,r5,-32232
 4006540:	01010074 	movhi	r4,1025
 4006544:	21208604 	addi	r4,r4,-32232
 4006548:	400770c0 	call	400770c <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
 400654c:	40075600 	call	4007560 <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
 4006550:	01010034 	movhi	r4,1024
 4006554:	211d7104 	addi	r4,r4,30148
 4006558:	4007ec00 	call	4007ec0 <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
 400655c:	d0a5b817 	ldw	r2,-26912(gp)
 4006560:	d0e5b917 	ldw	r3,-26908(gp)
 4006564:	d125ba17 	ldw	r4,-26904(gp)
 4006568:	200d883a 	mov	r6,r4
 400656c:	180b883a 	mov	r5,r3
 4006570:	1009883a 	mov	r4,r2
 4006574:	4005d540 	call	4005d54 <main>
 4006578:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
 400657c:	01000044 	movi	r4,1
 4006580:	40073340 	call	4007334 <close>
  exit (result);
 4006584:	e13fff17 	ldw	r4,-4(fp)
 4006588:	4007ed40 	call	4007ed4 <exit>

0400658c <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
 400658c:	defffd04 	addi	sp,sp,-12
 4006590:	dfc00215 	stw	ra,8(sp)
 4006594:	df000115 	stw	fp,4(sp)
 4006598:	df000104 	addi	fp,sp,4
 400659c:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
 40065a0:	d1600404 	addi	r5,gp,-32752
 40065a4:	e13fff17 	ldw	r4,-4(fp)
 40065a8:	40074b80 	call	40074b8 <alt_dev_llist_insert>
}
 40065ac:	e037883a 	mov	sp,fp
 40065b0:	dfc00117 	ldw	ra,4(sp)
 40065b4:	df000017 	ldw	fp,0(sp)
 40065b8:	dec00204 	addi	sp,sp,8
 40065bc:	f800283a 	ret

040065c0 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
 40065c0:	defffd04 	addi	sp,sp,-12
 40065c4:	dfc00215 	stw	ra,8(sp)
 40065c8:	df000115 	stw	fp,4(sp)
 40065cc:	df000104 	addi	fp,sp,4
 40065d0:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( FREERTOSNIOS, FreeRTOSNios);
 40065d4:	4007bd40 	call	4007bd4 <altera_nios2_gen2_irq_init>
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
 40065d8:	00800044 	movi	r2,1
 40065dc:	1001703a 	wrctl	status,r2
}
 40065e0:	0001883a 	nop
    alt_irq_cpu_enable_interrupts();
}
 40065e4:	0001883a 	nop
 40065e8:	e037883a 	mov	sp,fp
 40065ec:	dfc00117 	ldw	ra,4(sp)
 40065f0:	df000017 	ldw	fp,0(sp)
 40065f4:	dec00204 	addi	sp,sp,8
 40065f8:	f800283a 	ret

040065fc <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
 40065fc:	defffe04 	addi	sp,sp,-8
 4006600:	dfc00115 	stw	ra,4(sp)
 4006604:	df000015 	stw	fp,0(sp)
 4006608:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( SYS_CLK, sys_clk);
 400660c:	01c0fa04 	movi	r7,1000
 4006610:	01800044 	movi	r6,1
 4006614:	000b883a 	mov	r5,zero
 4006618:	01020034 	movhi	r4,2048
 400661c:	21041004 	addi	r4,r4,4160
 4006620:	40071480 	call	4007148 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_TIMER_INIT ( TIMER_0, timer_0);
    ALTERA_AVALON_TIMER_INIT ( TIMER_1, timer_1);
    ALTERA_AVALON_TIMER_INIT ( TIMER_2, timer_2);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
 4006624:	000d883a 	mov	r6,zero
 4006628:	000b883a 	mov	r5,zero
 400662c:	01010074 	movhi	r4,1025
 4006630:	21209d04 	addi	r4,r4,-32140
 4006634:	40067c00 	call	40067c0 <altera_avalon_jtag_uart_init>
 4006638:	01010074 	movhi	r4,1025
 400663c:	21209304 	addi	r4,r4,-32180
 4006640:	400658c0 	call	400658c <alt_dev_reg>
}
 4006644:	0001883a 	nop
 4006648:	e037883a 	mov	sp,fp
 400664c:	dfc00117 	ldw	ra,4(sp)
 4006650:	df000017 	ldw	fp,0(sp)
 4006654:	dec00204 	addi	sp,sp,8
 4006658:	f800283a 	ret

0400665c <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
 400665c:	defffa04 	addi	sp,sp,-24
 4006660:	dfc00515 	stw	ra,20(sp)
 4006664:	df000415 	stw	fp,16(sp)
 4006668:	df000404 	addi	fp,sp,16
 400666c:	e13ffe15 	stw	r4,-8(fp)
 4006670:	e17ffd15 	stw	r5,-12(fp)
 4006674:	e1bffc15 	stw	r6,-16(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 4006678:	e0bffe17 	ldw	r2,-8(fp)
 400667c:	10800017 	ldw	r2,0(r2)
 4006680:	e0bfff15 	stw	r2,-4(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
 4006684:	e0bfff17 	ldw	r2,-4(fp)
 4006688:	10c00a04 	addi	r3,r2,40
 400668c:	e0bffe17 	ldw	r2,-8(fp)
 4006690:	10800217 	ldw	r2,8(r2)
 4006694:	100f883a 	mov	r7,r2
 4006698:	e1bffc17 	ldw	r6,-16(fp)
 400669c:	e17ffd17 	ldw	r5,-12(fp)
 40066a0:	1809883a 	mov	r4,r3
 40066a4:	4006c800 	call	4006c80 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
 40066a8:	e037883a 	mov	sp,fp
 40066ac:	dfc00117 	ldw	ra,4(sp)
 40066b0:	df000017 	ldw	fp,0(sp)
 40066b4:	dec00204 	addi	sp,sp,8
 40066b8:	f800283a 	ret

040066bc <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
 40066bc:	defffa04 	addi	sp,sp,-24
 40066c0:	dfc00515 	stw	ra,20(sp)
 40066c4:	df000415 	stw	fp,16(sp)
 40066c8:	df000404 	addi	fp,sp,16
 40066cc:	e13ffe15 	stw	r4,-8(fp)
 40066d0:	e17ffd15 	stw	r5,-12(fp)
 40066d4:	e1bffc15 	stw	r6,-16(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 40066d8:	e0bffe17 	ldw	r2,-8(fp)
 40066dc:	10800017 	ldw	r2,0(r2)
 40066e0:	e0bfff15 	stw	r2,-4(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
 40066e4:	e0bfff17 	ldw	r2,-4(fp)
 40066e8:	10c00a04 	addi	r3,r2,40
 40066ec:	e0bffe17 	ldw	r2,-8(fp)
 40066f0:	10800217 	ldw	r2,8(r2)
 40066f4:	100f883a 	mov	r7,r2
 40066f8:	e1bffc17 	ldw	r6,-16(fp)
 40066fc:	e17ffd17 	ldw	r5,-12(fp)
 4006700:	1809883a 	mov	r4,r3
 4006704:	4006ea00 	call	4006ea0 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
 4006708:	e037883a 	mov	sp,fp
 400670c:	dfc00117 	ldw	ra,4(sp)
 4006710:	df000017 	ldw	fp,0(sp)
 4006714:	dec00204 	addi	sp,sp,8
 4006718:	f800283a 	ret

0400671c <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
 400671c:	defffc04 	addi	sp,sp,-16
 4006720:	dfc00315 	stw	ra,12(sp)
 4006724:	df000215 	stw	fp,8(sp)
 4006728:	df000204 	addi	fp,sp,8
 400672c:	e13ffe15 	stw	r4,-8(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 4006730:	e0bffe17 	ldw	r2,-8(fp)
 4006734:	10800017 	ldw	r2,0(r2)
 4006738:	e0bfff15 	stw	r2,-4(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
 400673c:	e0bfff17 	ldw	r2,-4(fp)
 4006740:	10c00a04 	addi	r3,r2,40
 4006744:	e0bffe17 	ldw	r2,-8(fp)
 4006748:	10800217 	ldw	r2,8(r2)
 400674c:	100b883a 	mov	r5,r2
 4006750:	1809883a 	mov	r4,r3
 4006754:	4006b240 	call	4006b24 <altera_avalon_jtag_uart_close>
}
 4006758:	e037883a 	mov	sp,fp
 400675c:	dfc00117 	ldw	ra,4(sp)
 4006760:	df000017 	ldw	fp,0(sp)
 4006764:	dec00204 	addi	sp,sp,8
 4006768:	f800283a 	ret

0400676c <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
 400676c:	defffa04 	addi	sp,sp,-24
 4006770:	dfc00515 	stw	ra,20(sp)
 4006774:	df000415 	stw	fp,16(sp)
 4006778:	df000404 	addi	fp,sp,16
 400677c:	e13ffe15 	stw	r4,-8(fp)
 4006780:	e17ffd15 	stw	r5,-12(fp)
 4006784:	e1bffc15 	stw	r6,-16(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
 4006788:	e0bffe17 	ldw	r2,-8(fp)
 400678c:	10800017 	ldw	r2,0(r2)
 4006790:	e0bfff15 	stw	r2,-4(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
 4006794:	e0bfff17 	ldw	r2,-4(fp)
 4006798:	10800a04 	addi	r2,r2,40
 400679c:	e1bffc17 	ldw	r6,-16(fp)
 40067a0:	e17ffd17 	ldw	r5,-12(fp)
 40067a4:	1009883a 	mov	r4,r2
 40067a8:	4006b8c0 	call	4006b8c <altera_avalon_jtag_uart_ioctl>
}
 40067ac:	e037883a 	mov	sp,fp
 40067b0:	dfc00117 	ldw	ra,4(sp)
 40067b4:	df000017 	ldw	fp,0(sp)
 40067b8:	dec00204 	addi	sp,sp,8
 40067bc:	f800283a 	ret

040067c0 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
 40067c0:	defffb04 	addi	sp,sp,-20
 40067c4:	dfc00415 	stw	ra,16(sp)
 40067c8:	df000315 	stw	fp,12(sp)
 40067cc:	df000304 	addi	fp,sp,12
 40067d0:	e13fff15 	stw	r4,-4(fp)
 40067d4:	e17ffe15 	stw	r5,-8(fp)
 40067d8:	e1bffd15 	stw	r6,-12(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 40067dc:	e0bfff17 	ldw	r2,-4(fp)
 40067e0:	00c00044 	movi	r3,1
 40067e4:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
 40067e8:	e0bfff17 	ldw	r2,-4(fp)
 40067ec:	10800017 	ldw	r2,0(r2)
 40067f0:	10800104 	addi	r2,r2,4
 40067f4:	1007883a 	mov	r3,r2
 40067f8:	e0bfff17 	ldw	r2,-4(fp)
 40067fc:	10800817 	ldw	r2,32(r2)
 4006800:	18800035 	stwio	r2,0(r3)
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
                      sp, NULL);
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
 4006804:	e0bffd17 	ldw	r2,-12(fp)
 4006808:	01810034 	movhi	r6,1024
 400680c:	319a1d04 	addi	r6,r6,26740
 4006810:	e17fff17 	ldw	r5,-4(fp)
 4006814:	1009883a 	mov	r4,r2
 4006818:	40004c80 	call	40004c8 <alt_irq_register>
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
 400681c:	e0bfff17 	ldw	r2,-4(fp)
 4006820:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
 4006824:	e0bfff17 	ldw	r2,-4(fp)
 4006828:	10800204 	addi	r2,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 400682c:	d0e5bb17 	ldw	r3,-26900(gp)
 4006830:	e1ffff17 	ldw	r7,-4(fp)
 4006834:	01810034 	movhi	r6,1024
 4006838:	319aa104 	addi	r6,r6,27268
 400683c:	180b883a 	mov	r5,r3
 4006840:	1009883a 	mov	r4,r2
 4006844:	40071c40 	call	40071c4 <alt_alarm_start>
 4006848:	1000040e 	bge	r2,zero,400685c <altera_avalon_jtag_uart_init+0x9c>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
 400684c:	e0ffff17 	ldw	r3,-4(fp)
 4006850:	00a00034 	movhi	r2,32768
 4006854:	10bfffc4 	addi	r2,r2,-1
 4006858:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
 400685c:	0001883a 	nop
 4006860:	e037883a 	mov	sp,fp
 4006864:	dfc00117 	ldw	ra,4(sp)
 4006868:	df000017 	ldw	fp,0(sp)
 400686c:	dec00204 	addi	sp,sp,8
 4006870:	f800283a 	ret

04006874 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
 4006874:	defff704 	addi	sp,sp,-36
 4006878:	df000815 	stw	fp,32(sp)
 400687c:	df000804 	addi	fp,sp,32
 4006880:	e13ff915 	stw	r4,-28(fp)
 4006884:	e17ff815 	stw	r5,-32(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
 4006888:	e0bff917 	ldw	r2,-28(fp)
 400688c:	e0bffd15 	stw	r2,-12(fp)
  unsigned int base = sp->base;
 4006890:	e0bffd17 	ldw	r2,-12(fp)
 4006894:	10800017 	ldw	r2,0(r2)
 4006898:	e0bffc15 	stw	r2,-16(fp)
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 400689c:	e0bffc17 	ldw	r2,-16(fp)
 40068a0:	10800104 	addi	r2,r2,4
 40068a4:	10800037 	ldwio	r2,0(r2)
 40068a8:	e0bffb15 	stw	r2,-20(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
 40068ac:	e0bffb17 	ldw	r2,-20(fp)
 40068b0:	1080c00c 	andi	r2,r2,768
 40068b4:	10006d26 	beq	r2,zero,4006a6c <altera_avalon_jtag_uart_irq+0x1f8>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
 40068b8:	e0bffb17 	ldw	r2,-20(fp)
 40068bc:	1080400c 	andi	r2,r2,256
 40068c0:	10003526 	beq	r2,zero,4006998 <altera_avalon_jtag_uart_irq+0x124>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
 40068c4:	00800074 	movhi	r2,1
 40068c8:	e0bfff15 	stw	r2,-4(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 40068cc:	e0bffd17 	ldw	r2,-12(fp)
 40068d0:	10800a17 	ldw	r2,40(r2)
 40068d4:	10800044 	addi	r2,r2,1
 40068d8:	1081ffcc 	andi	r2,r2,2047
 40068dc:	e0bffa15 	stw	r2,-24(fp)
        if (next == sp->rx_out)
 40068e0:	e0bffd17 	ldw	r2,-12(fp)
 40068e4:	10800b17 	ldw	r2,44(r2)
 40068e8:	e0fffa17 	ldw	r3,-24(fp)
 40068ec:	18801526 	beq	r3,r2,4006944 <altera_avalon_jtag_uart_irq+0xd0>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
 40068f0:	e0bffc17 	ldw	r2,-16(fp)
 40068f4:	10800037 	ldwio	r2,0(r2)
 40068f8:	e0bfff15 	stw	r2,-4(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
 40068fc:	e0bfff17 	ldw	r2,-4(fp)
 4006900:	10a0000c 	andi	r2,r2,32768
 4006904:	10001126 	beq	r2,zero,400694c <altera_avalon_jtag_uart_irq+0xd8>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
 4006908:	e0bffd17 	ldw	r2,-12(fp)
 400690c:	10800a17 	ldw	r2,40(r2)
 4006910:	e0ffff17 	ldw	r3,-4(fp)
 4006914:	1809883a 	mov	r4,r3
 4006918:	e0fffd17 	ldw	r3,-12(fp)
 400691c:	1885883a 	add	r2,r3,r2
 4006920:	11000e05 	stb	r4,56(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 4006924:	e0bffd17 	ldw	r2,-12(fp)
 4006928:	10800a17 	ldw	r2,40(r2)
 400692c:	10800044 	addi	r2,r2,1
 4006930:	10c1ffcc 	andi	r3,r2,2047
 4006934:	e0bffd17 	ldw	r2,-12(fp)
 4006938:	10c00a15 	stw	r3,40(r2)
 * HAL.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_no_error (void)
{
  return 0;
 400693c:	0001883a 	nop
      {
 4006940:	003fe206 	br	40068cc <altera_avalon_jtag_uart_irq+0x58>
          break;
 4006944:	0001883a 	nop
 4006948:	00000106 	br	4006950 <altera_avalon_jtag_uart_irq+0xdc>
          break;
 400694c:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
 4006950:	e0bfff17 	ldw	r2,-4(fp)
 4006954:	10bfffec 	andhi	r2,r2,65535
 4006958:	10000f26 	beq	r2,zero,4006998 <altera_avalon_jtag_uart_irq+0x124>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 400695c:	e0bffd17 	ldw	r2,-12(fp)
 4006960:	10c00817 	ldw	r3,32(r2)
 4006964:	00bfff84 	movi	r2,-2
 4006968:	1886703a 	and	r3,r3,r2
 400696c:	e0bffd17 	ldw	r2,-12(fp)
 4006970:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
 4006974:	e0bffc17 	ldw	r2,-16(fp)
 4006978:	10800104 	addi	r2,r2,4
 400697c:	1007883a 	mov	r3,r2
 4006980:	e0bffd17 	ldw	r2,-12(fp)
 4006984:	10800817 	ldw	r2,32(r2)
 4006988:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 400698c:	e0bffc17 	ldw	r2,-16(fp)
 4006990:	10800104 	addi	r2,r2,4
 4006994:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
 4006998:	e0bffb17 	ldw	r2,-20(fp)
 400699c:	1080800c 	andi	r2,r2,512
 40069a0:	103fbe26 	beq	r2,zero,400689c <altera_avalon_jtag_uart_irq+0x28>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
 40069a4:	e0bffb17 	ldw	r2,-20(fp)
 40069a8:	1004d43a 	srli	r2,r2,16
 40069ac:	e0bffe15 	stw	r2,-8(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
 40069b0:	00001406 	br	4006a04 <altera_avalon_jtag_uart_irq+0x190>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
 40069b4:	e0bffc17 	ldw	r2,-16(fp)
 40069b8:	e0fffd17 	ldw	r3,-12(fp)
 40069bc:	18c00d17 	ldw	r3,52(r3)
 40069c0:	e13ffd17 	ldw	r4,-12(fp)
 40069c4:	20c7883a 	add	r3,r4,r3
 40069c8:	18c20e03 	ldbu	r3,2104(r3)
 40069cc:	18c03fcc 	andi	r3,r3,255
 40069d0:	18c0201c 	xori	r3,r3,128
 40069d4:	18ffe004 	addi	r3,r3,-128
 40069d8:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 40069dc:	e0bffd17 	ldw	r2,-12(fp)
 40069e0:	10800d17 	ldw	r2,52(r2)
 40069e4:	10800044 	addi	r2,r2,1
 40069e8:	10c1ffcc 	andi	r3,r2,2047
 40069ec:	e0bffd17 	ldw	r2,-12(fp)
 40069f0:	10c00d15 	stw	r3,52(r2)
 40069f4:	0001883a 	nop

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
 40069f8:	e0bffe17 	ldw	r2,-8(fp)
 40069fc:	10bfffc4 	addi	r2,r2,-1
 4006a00:	e0bffe15 	stw	r2,-8(fp)
      while (space > 0 && sp->tx_out != sp->tx_in)
 4006a04:	e0bffe17 	ldw	r2,-8(fp)
 4006a08:	10000526 	beq	r2,zero,4006a20 <altera_avalon_jtag_uart_irq+0x1ac>
 4006a0c:	e0bffd17 	ldw	r2,-12(fp)
 4006a10:	10c00d17 	ldw	r3,52(r2)
 4006a14:	e0bffd17 	ldw	r2,-12(fp)
 4006a18:	10800c17 	ldw	r2,48(r2)
 4006a1c:	18bfe51e 	bne	r3,r2,40069b4 <altera_avalon_jtag_uart_irq+0x140>
      }

      if (space > 0)
 4006a20:	e0bffe17 	ldw	r2,-8(fp)
 4006a24:	103f9d26 	beq	r2,zero,400689c <altera_avalon_jtag_uart_irq+0x28>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 4006a28:	e0bffd17 	ldw	r2,-12(fp)
 4006a2c:	10c00817 	ldw	r3,32(r2)
 4006a30:	00bfff44 	movi	r2,-3
 4006a34:	1886703a 	and	r3,r3,r2
 4006a38:	e0bffd17 	ldw	r2,-12(fp)
 4006a3c:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 4006a40:	e0bffd17 	ldw	r2,-12(fp)
 4006a44:	10800017 	ldw	r2,0(r2)
 4006a48:	10800104 	addi	r2,r2,4
 4006a4c:	1007883a 	mov	r3,r2
 4006a50:	e0bffd17 	ldw	r2,-12(fp)
 4006a54:	10800817 	ldw	r2,32(r2)
 4006a58:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 4006a5c:	e0bffc17 	ldw	r2,-16(fp)
 4006a60:	10800104 	addi	r2,r2,4
 4006a64:	10800037 	ldwio	r2,0(r2)
  {
 4006a68:	003f8c06 	br	400689c <altera_avalon_jtag_uart_irq+0x28>
      break;
 4006a6c:	0001883a 	nop
      }
    }
  }
}
 4006a70:	0001883a 	nop
 4006a74:	e037883a 	mov	sp,fp
 4006a78:	df000017 	ldw	fp,0(sp)
 4006a7c:	dec00104 	addi	sp,sp,4
 4006a80:	f800283a 	ret

04006a84 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
 4006a84:	defffc04 	addi	sp,sp,-16
 4006a88:	df000315 	stw	fp,12(sp)
 4006a8c:	df000304 	addi	fp,sp,12
 4006a90:	e13ffd15 	stw	r4,-12(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
 4006a94:	e0bffd17 	ldw	r2,-12(fp)
 4006a98:	e0bfff15 	stw	r2,-4(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
 4006a9c:	e0bfff17 	ldw	r2,-4(fp)
 4006aa0:	10800017 	ldw	r2,0(r2)
 4006aa4:	10800104 	addi	r2,r2,4
 4006aa8:	10800037 	ldwio	r2,0(r2)
 4006aac:	e0bffe15 	stw	r2,-8(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
 4006ab0:	e0bffe17 	ldw	r2,-8(fp)
 4006ab4:	1081000c 	andi	r2,r2,1024
 4006ab8:	10000b26 	beq	r2,zero,4006ae8 <altera_avalon_jtag_uart_timeout+0x64>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
 4006abc:	e0bfff17 	ldw	r2,-4(fp)
 4006ac0:	10800017 	ldw	r2,0(r2)
 4006ac4:	10800104 	addi	r2,r2,4
 4006ac8:	1007883a 	mov	r3,r2
 4006acc:	e0bfff17 	ldw	r2,-4(fp)
 4006ad0:	10800817 	ldw	r2,32(r2)
 4006ad4:	10810014 	ori	r2,r2,1024
 4006ad8:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
 4006adc:	e0bfff17 	ldw	r2,-4(fp)
 4006ae0:	10000915 	stw	zero,36(r2)
 4006ae4:	00000a06 	br	4006b10 <altera_avalon_jtag_uart_timeout+0x8c>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
 4006ae8:	e0bfff17 	ldw	r2,-4(fp)
 4006aec:	10c00917 	ldw	r3,36(r2)
 4006af0:	00a00034 	movhi	r2,32768
 4006af4:	10bfff04 	addi	r2,r2,-4
 4006af8:	10c00536 	bltu	r2,r3,4006b10 <altera_avalon_jtag_uart_timeout+0x8c>
    sp->host_inactive++;
 4006afc:	e0bfff17 	ldw	r2,-4(fp)
 4006b00:	10800917 	ldw	r2,36(r2)
 4006b04:	10c00044 	addi	r3,r2,1
 4006b08:	e0bfff17 	ldw	r2,-4(fp)
 4006b0c:	10c00915 	stw	r3,36(r2)
 4006b10:	d0a5bb17 	ldw	r2,-26900(gp)
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
 4006b14:	e037883a 	mov	sp,fp
 4006b18:	df000017 	ldw	fp,0(sp)
 4006b1c:	dec00104 	addi	sp,sp,4
 4006b20:	f800283a 	ret

04006b24 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
 4006b24:	defffd04 	addi	sp,sp,-12
 4006b28:	df000215 	stw	fp,8(sp)
 4006b2c:	df000204 	addi	fp,sp,8
 4006b30:	e13fff15 	stw	r4,-4(fp)
 4006b34:	e17ffe15 	stw	r5,-8(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 4006b38:	00000506 	br	4006b50 <altera_avalon_jtag_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
 4006b3c:	e0bffe17 	ldw	r2,-8(fp)
 4006b40:	1090000c 	andi	r2,r2,16384
 4006b44:	10000226 	beq	r2,zero,4006b50 <altera_avalon_jtag_uart_close+0x2c>
      return -EWOULDBLOCK; 
 4006b48:	00bffd44 	movi	r2,-11
 4006b4c:	00000b06 	br	4006b7c <altera_avalon_jtag_uart_close+0x58>
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 4006b50:	e0bfff17 	ldw	r2,-4(fp)
 4006b54:	10c00d17 	ldw	r3,52(r2)
 4006b58:	e0bfff17 	ldw	r2,-4(fp)
 4006b5c:	10800c17 	ldw	r2,48(r2)
 4006b60:	18800526 	beq	r3,r2,4006b78 <altera_avalon_jtag_uart_close+0x54>
 4006b64:	e0bfff17 	ldw	r2,-4(fp)
 4006b68:	10c00917 	ldw	r3,36(r2)
 4006b6c:	e0bfff17 	ldw	r2,-4(fp)
 4006b70:	10800117 	ldw	r2,4(r2)
 4006b74:	18bff136 	bltu	r3,r2,4006b3c <altera_avalon_jtag_uart_close+0x18>
    }
  }

  return 0;
 4006b78:	0005883a 	mov	r2,zero
}
 4006b7c:	e037883a 	mov	sp,fp
 4006b80:	df000017 	ldw	fp,0(sp)
 4006b84:	dec00104 	addi	sp,sp,4
 4006b88:	f800283a 	ret

04006b8c <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
 4006b8c:	defffa04 	addi	sp,sp,-24
 4006b90:	df000515 	stw	fp,20(sp)
 4006b94:	df000504 	addi	fp,sp,20
 4006b98:	e13ffd15 	stw	r4,-12(fp)
 4006b9c:	e17ffc15 	stw	r5,-16(fp)
 4006ba0:	e1bffb15 	stw	r6,-20(fp)
  int rc = -ENOTTY;
 4006ba4:	00bff9c4 	movi	r2,-25
 4006ba8:	e0bfff15 	stw	r2,-4(fp)

  switch (req)
 4006bac:	e0bffc17 	ldw	r2,-16(fp)
 4006bb0:	109a8060 	cmpeqi	r2,r2,27137
 4006bb4:	1000041e 	bne	r2,zero,4006bc8 <altera_avalon_jtag_uart_ioctl+0x3c>
 4006bb8:	e0bffc17 	ldw	r2,-16(fp)
 4006bbc:	109a80a0 	cmpeqi	r2,r2,27138
 4006bc0:	1000181e 	bne	r2,zero,4006c24 <altera_avalon_jtag_uart_ioctl+0x98>
      rc = 0;
    }
    break;

  default:
    break;
 4006bc4:	00002906 	br	4006c6c <altera_avalon_jtag_uart_ioctl+0xe0>
    if (sp->timeout != INT_MAX)
 4006bc8:	e0bffd17 	ldw	r2,-12(fp)
 4006bcc:	10c00117 	ldw	r3,4(r2)
 4006bd0:	00a00034 	movhi	r2,32768
 4006bd4:	10bfffc4 	addi	r2,r2,-1
 4006bd8:	18802126 	beq	r3,r2,4006c60 <altera_avalon_jtag_uart_ioctl+0xd4>
      int timeout = *((int *)arg);
 4006bdc:	e0bffb17 	ldw	r2,-20(fp)
 4006be0:	10800017 	ldw	r2,0(r2)
 4006be4:	e0bffe15 	stw	r2,-8(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
 4006be8:	e0bffe17 	ldw	r2,-8(fp)
 4006bec:	10800090 	cmplti	r2,r2,2
 4006bf0:	1000061e 	bne	r2,zero,4006c0c <altera_avalon_jtag_uart_ioctl+0x80>
 4006bf4:	e0fffe17 	ldw	r3,-8(fp)
 4006bf8:	00a00034 	movhi	r2,32768
 4006bfc:	10bfffc4 	addi	r2,r2,-1
 4006c00:	18800226 	beq	r3,r2,4006c0c <altera_avalon_jtag_uart_ioctl+0x80>
 4006c04:	e0bffe17 	ldw	r2,-8(fp)
 4006c08:	00000206 	br	4006c14 <altera_avalon_jtag_uart_ioctl+0x88>
 4006c0c:	00a00034 	movhi	r2,32768
 4006c10:	10bfff84 	addi	r2,r2,-2
 4006c14:	e0fffd17 	ldw	r3,-12(fp)
 4006c18:	18800115 	stw	r2,4(r3)
      rc = 0;
 4006c1c:	e03fff15 	stw	zero,-4(fp)
    break;
 4006c20:	00000f06 	br	4006c60 <altera_avalon_jtag_uart_ioctl+0xd4>
    if (sp->timeout != INT_MAX)
 4006c24:	e0bffd17 	ldw	r2,-12(fp)
 4006c28:	10c00117 	ldw	r3,4(r2)
 4006c2c:	00a00034 	movhi	r2,32768
 4006c30:	10bfffc4 	addi	r2,r2,-1
 4006c34:	18800c26 	beq	r3,r2,4006c68 <altera_avalon_jtag_uart_ioctl+0xdc>
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
 4006c38:	e0bffd17 	ldw	r2,-12(fp)
 4006c3c:	10c00917 	ldw	r3,36(r2)
 4006c40:	e0bffd17 	ldw	r2,-12(fp)
 4006c44:	10800117 	ldw	r2,4(r2)
 4006c48:	1885803a 	cmpltu	r2,r3,r2
 4006c4c:	10c03fcc 	andi	r3,r2,255
 4006c50:	e0bffb17 	ldw	r2,-20(fp)
 4006c54:	10c00015 	stw	r3,0(r2)
      rc = 0;
 4006c58:	e03fff15 	stw	zero,-4(fp)
    break;
 4006c5c:	00000206 	br	4006c68 <altera_avalon_jtag_uart_ioctl+0xdc>
    break;
 4006c60:	0001883a 	nop
 4006c64:	00000106 	br	4006c6c <altera_avalon_jtag_uart_ioctl+0xe0>
    break;
 4006c68:	0001883a 	nop
  }

  return rc;
 4006c6c:	e0bfff17 	ldw	r2,-4(fp)
}
 4006c70:	e037883a 	mov	sp,fp
 4006c74:	df000017 	ldw	fp,0(sp)
 4006c78:	dec00104 	addi	sp,sp,4
 4006c7c:	f800283a 	ret

04006c80 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
 4006c80:	defff304 	addi	sp,sp,-52
 4006c84:	dfc00c15 	stw	ra,48(sp)
 4006c88:	df000b15 	stw	fp,44(sp)
 4006c8c:	df000b04 	addi	fp,sp,44
 4006c90:	e13ff815 	stw	r4,-32(fp)
 4006c94:	e17ff715 	stw	r5,-36(fp)
 4006c98:	e1bff615 	stw	r6,-40(fp)
 4006c9c:	e1fff515 	stw	r7,-44(fp)
  char * ptr = buffer;
 4006ca0:	e0bff717 	ldw	r2,-36(fp)
 4006ca4:	e0bfff15 	stw	r2,-4(fp)
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 4006ca8:	00004706 	br	4006dc8 <altera_avalon_jtag_uart_read+0x148>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
 4006cac:	e0bff817 	ldw	r2,-32(fp)
 4006cb0:	10800a17 	ldw	r2,40(r2)
 4006cb4:	e0bffd15 	stw	r2,-12(fp)
      out = sp->rx_out;
 4006cb8:	e0bff817 	ldw	r2,-32(fp)
 4006cbc:	10800b17 	ldw	r2,44(r2)
 4006cc0:	e0bffc15 	stw	r2,-16(fp)

      if (in >= out)
 4006cc4:	e0fffd17 	ldw	r3,-12(fp)
 4006cc8:	e0bffc17 	ldw	r2,-16(fp)
 4006ccc:	18800536 	bltu	r3,r2,4006ce4 <altera_avalon_jtag_uart_read+0x64>
        n = in - out;
 4006cd0:	e0fffd17 	ldw	r3,-12(fp)
 4006cd4:	e0bffc17 	ldw	r2,-16(fp)
 4006cd8:	1885c83a 	sub	r2,r3,r2
 4006cdc:	e0bffe15 	stw	r2,-8(fp)
 4006ce0:	00000406 	br	4006cf4 <altera_avalon_jtag_uart_read+0x74>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
 4006ce4:	00c20004 	movi	r3,2048
 4006ce8:	e0bffc17 	ldw	r2,-16(fp)
 4006cec:	1885c83a 	sub	r2,r3,r2
 4006cf0:	e0bffe15 	stw	r2,-8(fp)

      if (n == 0)
 4006cf4:	e0bffe17 	ldw	r2,-8(fp)
 4006cf8:	10001e26 	beq	r2,zero,4006d74 <altera_avalon_jtag_uart_read+0xf4>
        break; /* No more data available */

      if (n > space)
 4006cfc:	e0fff617 	ldw	r3,-40(fp)
 4006d00:	e0bffe17 	ldw	r2,-8(fp)
 4006d04:	1880022e 	bgeu	r3,r2,4006d10 <altera_avalon_jtag_uart_read+0x90>
        n = space;
 4006d08:	e0bff617 	ldw	r2,-40(fp)
 4006d0c:	e0bffe15 	stw	r2,-8(fp)

      memcpy(ptr, sp->rx_buf + out, n);
 4006d10:	e0bff817 	ldw	r2,-32(fp)
 4006d14:	10c00e04 	addi	r3,r2,56
 4006d18:	e0bffc17 	ldw	r2,-16(fp)
 4006d1c:	1885883a 	add	r2,r3,r2
 4006d20:	e1bffe17 	ldw	r6,-8(fp)
 4006d24:	100b883a 	mov	r5,r2
 4006d28:	e13fff17 	ldw	r4,-4(fp)
 4006d2c:	40062340 	call	4006234 <memcpy>
      ptr   += n;
 4006d30:	e0ffff17 	ldw	r3,-4(fp)
 4006d34:	e0bffe17 	ldw	r2,-8(fp)
 4006d38:	1885883a 	add	r2,r3,r2
 4006d3c:	e0bfff15 	stw	r2,-4(fp)
      space -= n;
 4006d40:	e0fff617 	ldw	r3,-40(fp)
 4006d44:	e0bffe17 	ldw	r2,-8(fp)
 4006d48:	1885c83a 	sub	r2,r3,r2
 4006d4c:	e0bff615 	stw	r2,-40(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 4006d50:	e0fffc17 	ldw	r3,-16(fp)
 4006d54:	e0bffe17 	ldw	r2,-8(fp)
 4006d58:	1885883a 	add	r2,r3,r2
 4006d5c:	10c1ffcc 	andi	r3,r2,2047
 4006d60:	e0bff817 	ldw	r2,-32(fp)
 4006d64:	10c00b15 	stw	r3,44(r2)
    }
    while (space > 0);
 4006d68:	e0bff617 	ldw	r2,-40(fp)
 4006d6c:	00bfcf16 	blt	zero,r2,4006cac <altera_avalon_jtag_uart_read+0x2c>
 4006d70:	00000106 	br	4006d78 <altera_avalon_jtag_uart_read+0xf8>
        break; /* No more data available */
 4006d74:	0001883a 	nop

    /* If we read any data then return it */
    if (ptr != buffer)
 4006d78:	e0ffff17 	ldw	r3,-4(fp)
 4006d7c:	e0bff717 	ldw	r2,-36(fp)
 4006d80:	1880141e 	bne	r3,r2,4006dd4 <altera_avalon_jtag_uart_read+0x154>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
 4006d84:	e0bff517 	ldw	r2,-44(fp)
 4006d88:	1090000c 	andi	r2,r2,16384
 4006d8c:	1000131e 	bne	r2,zero,4006ddc <altera_avalon_jtag_uart_read+0x15c>
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
        ;
    }
#else
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
 4006d90:	0001883a 	nop
 4006d94:	e0bff817 	ldw	r2,-32(fp)
 4006d98:	10800a17 	ldw	r2,40(r2)
 4006d9c:	e0fffd17 	ldw	r3,-12(fp)
 4006da0:	1880051e 	bne	r3,r2,4006db8 <altera_avalon_jtag_uart_read+0x138>
 4006da4:	e0bff817 	ldw	r2,-32(fp)
 4006da8:	10c00917 	ldw	r3,36(r2)
 4006dac:	e0bff817 	ldw	r2,-32(fp)
 4006db0:	10800117 	ldw	r2,4(r2)
 4006db4:	18bff736 	bltu	r3,r2,4006d94 <altera_avalon_jtag_uart_read+0x114>
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
 4006db8:	e0bff817 	ldw	r2,-32(fp)
 4006dbc:	10800a17 	ldw	r2,40(r2)
 4006dc0:	e0fffd17 	ldw	r3,-12(fp)
 4006dc4:	18800726 	beq	r3,r2,4006de4 <altera_avalon_jtag_uart_read+0x164>
  while (space > 0)
 4006dc8:	e0bff617 	ldw	r2,-40(fp)
 4006dcc:	00bfb716 	blt	zero,r2,4006cac <altera_avalon_jtag_uart_read+0x2c>
 4006dd0:	00000506 	br	4006de8 <altera_avalon_jtag_uart_read+0x168>
      break;
 4006dd4:	0001883a 	nop
 4006dd8:	00000306 	br	4006de8 <altera_avalon_jtag_uart_read+0x168>
      break;
 4006ddc:	0001883a 	nop
 4006de0:	00000106 	br	4006de8 <altera_avalon_jtag_uart_read+0x168>
      break;
 4006de4:	0001883a 	nop
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);

  if (ptr != buffer)
 4006de8:	e0ffff17 	ldw	r3,-4(fp)
 4006dec:	e0bff717 	ldw	r2,-36(fp)
 4006df0:	18801926 	beq	r3,r2,4006e58 <altera_avalon_jtag_uart_read+0x1d8>
  NIOS2_READ_STATUS (context);
 4006df4:	0005303a 	rdctl	r2,status
 4006df8:	e0bff915 	stw	r2,-28(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 4006dfc:	e0fff917 	ldw	r3,-28(fp)
 4006e00:	00bfff84 	movi	r2,-2
 4006e04:	1884703a 	and	r2,r3,r2
 4006e08:	1001703a 	wrctl	status,r2
  return context;
 4006e0c:	e0bff917 	ldw	r2,-28(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
 4006e10:	e0bffb15 	stw	r2,-20(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 4006e14:	e0bff817 	ldw	r2,-32(fp)
 4006e18:	10800817 	ldw	r2,32(r2)
 4006e1c:	10c00054 	ori	r3,r2,1
 4006e20:	e0bff817 	ldw	r2,-32(fp)
 4006e24:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 4006e28:	e0bff817 	ldw	r2,-32(fp)
 4006e2c:	10800017 	ldw	r2,0(r2)
 4006e30:	10800104 	addi	r2,r2,4
 4006e34:	1007883a 	mov	r3,r2
 4006e38:	e0bff817 	ldw	r2,-32(fp)
 4006e3c:	10800817 	ldw	r2,32(r2)
 4006e40:	18800035 	stwio	r2,0(r3)
 4006e44:	e0bffb17 	ldw	r2,-20(fp)
 4006e48:	e0bffa15 	stw	r2,-24(fp)
  NIOS2_WRITE_STATUS (context);
 4006e4c:	e0bffa17 	ldw	r2,-24(fp)
 4006e50:	1001703a 	wrctl	status,r2
}
 4006e54:	0001883a 	nop
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
 4006e58:	e0ffff17 	ldw	r3,-4(fp)
 4006e5c:	e0bff717 	ldw	r2,-36(fp)
 4006e60:	18800426 	beq	r3,r2,4006e74 <altera_avalon_jtag_uart_read+0x1f4>
    return ptr - buffer;
 4006e64:	e0ffff17 	ldw	r3,-4(fp)
 4006e68:	e0bff717 	ldw	r2,-36(fp)
 4006e6c:	1885c83a 	sub	r2,r3,r2
 4006e70:	00000606 	br	4006e8c <altera_avalon_jtag_uart_read+0x20c>
  else if (flags & O_NONBLOCK)
 4006e74:	e0bff517 	ldw	r2,-44(fp)
 4006e78:	1090000c 	andi	r2,r2,16384
 4006e7c:	10000226 	beq	r2,zero,4006e88 <altera_avalon_jtag_uart_read+0x208>
    return -EWOULDBLOCK;
 4006e80:	00bffd44 	movi	r2,-11
 4006e84:	00000106 	br	4006e8c <altera_avalon_jtag_uart_read+0x20c>
  else
    return -EIO;
 4006e88:	00bffec4 	movi	r2,-5
}
 4006e8c:	e037883a 	mov	sp,fp
 4006e90:	dfc00117 	ldw	ra,4(sp)
 4006e94:	df000017 	ldw	fp,0(sp)
 4006e98:	dec00204 	addi	sp,sp,8
 4006e9c:	f800283a 	ret

04006ea0 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
 4006ea0:	defff304 	addi	sp,sp,-52
 4006ea4:	dfc00c15 	stw	ra,48(sp)
 4006ea8:	df000b15 	stw	fp,44(sp)
 4006eac:	df000b04 	addi	fp,sp,44
 4006eb0:	e13ff815 	stw	r4,-32(fp)
 4006eb4:	e17ff715 	stw	r5,-36(fp)
 4006eb8:	e1bff615 	stw	r6,-40(fp)
 4006ebc:	e1fff515 	stw	r7,-44(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
 4006ec0:	e03fff15 	stw	zero,-4(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
 4006ec4:	e0bff717 	ldw	r2,-36(fp)
 4006ec8:	e0bffd15 	stw	r2,-12(fp)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 4006ecc:	00003706 	br	4006fac <altera_avalon_jtag_uart_write+0x10c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
 4006ed0:	e0bff817 	ldw	r2,-32(fp)
 4006ed4:	10800c17 	ldw	r2,48(r2)
 4006ed8:	e0bffc15 	stw	r2,-16(fp)
      out = sp->tx_out;
 4006edc:	e0bff817 	ldw	r2,-32(fp)
 4006ee0:	10800d17 	ldw	r2,52(r2)
 4006ee4:	e0bfff15 	stw	r2,-4(fp)

      if (in < out)
 4006ee8:	e0fffc17 	ldw	r3,-16(fp)
 4006eec:	e0bfff17 	ldw	r2,-4(fp)
 4006ef0:	1880062e 	bgeu	r3,r2,4006f0c <altera_avalon_jtag_uart_write+0x6c>
        n = out - 1 - in;
 4006ef4:	e0ffff17 	ldw	r3,-4(fp)
 4006ef8:	e0bffc17 	ldw	r2,-16(fp)
 4006efc:	1885c83a 	sub	r2,r3,r2
 4006f00:	10bfffc4 	addi	r2,r2,-1
 4006f04:	e0bffe15 	stw	r2,-8(fp)
 4006f08:	00000b06 	br	4006f38 <altera_avalon_jtag_uart_write+0x98>
      else if (out > 0)
 4006f0c:	e0bfff17 	ldw	r2,-4(fp)
 4006f10:	10000526 	beq	r2,zero,4006f28 <altera_avalon_jtag_uart_write+0x88>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
 4006f14:	00c20004 	movi	r3,2048
 4006f18:	e0bffc17 	ldw	r2,-16(fp)
 4006f1c:	1885c83a 	sub	r2,r3,r2
 4006f20:	e0bffe15 	stw	r2,-8(fp)
 4006f24:	00000406 	br	4006f38 <altera_avalon_jtag_uart_write+0x98>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
 4006f28:	00c1ffc4 	movi	r3,2047
 4006f2c:	e0bffc17 	ldw	r2,-16(fp)
 4006f30:	1885c83a 	sub	r2,r3,r2
 4006f34:	e0bffe15 	stw	r2,-8(fp)

      if (n == 0)
 4006f38:	e0bffe17 	ldw	r2,-8(fp)
 4006f3c:	10001e26 	beq	r2,zero,4006fb8 <altera_avalon_jtag_uart_write+0x118>
        break;

      if (n > count)
 4006f40:	e0fff617 	ldw	r3,-40(fp)
 4006f44:	e0bffe17 	ldw	r2,-8(fp)
 4006f48:	1880022e 	bgeu	r3,r2,4006f54 <altera_avalon_jtag_uart_write+0xb4>
        n = count;
 4006f4c:	e0bff617 	ldw	r2,-40(fp)
 4006f50:	e0bffe15 	stw	r2,-8(fp)

      memcpy(sp->tx_buf + in, ptr, n);
 4006f54:	e0bff817 	ldw	r2,-32(fp)
 4006f58:	10c20e04 	addi	r3,r2,2104
 4006f5c:	e0bffc17 	ldw	r2,-16(fp)
 4006f60:	1885883a 	add	r2,r3,r2
 4006f64:	e1bffe17 	ldw	r6,-8(fp)
 4006f68:	e17ff717 	ldw	r5,-36(fp)
 4006f6c:	1009883a 	mov	r4,r2
 4006f70:	40062340 	call	4006234 <memcpy>
      ptr   += n;
 4006f74:	e0fff717 	ldw	r3,-36(fp)
 4006f78:	e0bffe17 	ldw	r2,-8(fp)
 4006f7c:	1885883a 	add	r2,r3,r2
 4006f80:	e0bff715 	stw	r2,-36(fp)
      count -= n;
 4006f84:	e0fff617 	ldw	r3,-40(fp)
 4006f88:	e0bffe17 	ldw	r2,-8(fp)
 4006f8c:	1885c83a 	sub	r2,r3,r2
 4006f90:	e0bff615 	stw	r2,-40(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 4006f94:	e0fffc17 	ldw	r3,-16(fp)
 4006f98:	e0bffe17 	ldw	r2,-8(fp)
 4006f9c:	1885883a 	add	r2,r3,r2
 4006fa0:	10c1ffcc 	andi	r3,r2,2047
 4006fa4:	e0bff817 	ldw	r2,-32(fp)
 4006fa8:	10c00c15 	stw	r3,48(r2)
    while (count > 0)
 4006fac:	e0bff617 	ldw	r2,-40(fp)
 4006fb0:	00bfc716 	blt	zero,r2,4006ed0 <altera_avalon_jtag_uart_write+0x30>
 4006fb4:	00000106 	br	4006fbc <altera_avalon_jtag_uart_write+0x11c>
        break;
 4006fb8:	0001883a 	nop
  NIOS2_READ_STATUS (context);
 4006fbc:	0005303a 	rdctl	r2,status
 4006fc0:	e0bff915 	stw	r2,-28(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 4006fc4:	e0fff917 	ldw	r3,-28(fp)
 4006fc8:	00bfff84 	movi	r2,-2
 4006fcc:	1884703a 	and	r2,r3,r2
 4006fd0:	1001703a 	wrctl	status,r2
  return context;
 4006fd4:	e0bff917 	ldw	r2,-28(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
 4006fd8:	e0bffb15 	stw	r2,-20(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 4006fdc:	e0bff817 	ldw	r2,-32(fp)
 4006fe0:	10800817 	ldw	r2,32(r2)
 4006fe4:	10c00094 	ori	r3,r2,2
 4006fe8:	e0bff817 	ldw	r2,-32(fp)
 4006fec:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 4006ff0:	e0bff817 	ldw	r2,-32(fp)
 4006ff4:	10800017 	ldw	r2,0(r2)
 4006ff8:	10800104 	addi	r2,r2,4
 4006ffc:	1007883a 	mov	r3,r2
 4007000:	e0bff817 	ldw	r2,-32(fp)
 4007004:	10800817 	ldw	r2,32(r2)
 4007008:	18800035 	stwio	r2,0(r3)
 400700c:	e0bffb17 	ldw	r2,-20(fp)
 4007010:	e0bffa15 	stw	r2,-24(fp)
  NIOS2_WRITE_STATUS (context);
 4007014:	e0bffa17 	ldw	r2,-24(fp)
 4007018:	1001703a 	wrctl	status,r2
}
 400701c:	0001883a 	nop
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
 4007020:	e0bff617 	ldw	r2,-40(fp)
 4007024:	0080100e 	bge	zero,r2,4007068 <altera_avalon_jtag_uart_write+0x1c8>
    {
      if (flags & O_NONBLOCK)
 4007028:	e0bff517 	ldw	r2,-44(fp)
 400702c:	1090000c 	andi	r2,r2,16384
 4007030:	1000101e 	bne	r2,zero,4007074 <altera_avalon_jtag_uart_write+0x1d4>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
 4007034:	0001883a 	nop
 4007038:	e0bff817 	ldw	r2,-32(fp)
 400703c:	10800d17 	ldw	r2,52(r2)
 4007040:	e0ffff17 	ldw	r3,-4(fp)
 4007044:	1880051e 	bne	r3,r2,400705c <altera_avalon_jtag_uart_write+0x1bc>
 4007048:	e0bff817 	ldw	r2,-32(fp)
 400704c:	10c00917 	ldw	r3,36(r2)
 4007050:	e0bff817 	ldw	r2,-32(fp)
 4007054:	10800117 	ldw	r2,4(r2)
 4007058:	18bff736 	bltu	r3,r2,4007038 <altera_avalon_jtag_uart_write+0x198>
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
 400705c:	e0bff817 	ldw	r2,-32(fp)
 4007060:	10800917 	ldw	r2,36(r2)
 4007064:	1000051e 	bne	r2,zero,400707c <altera_avalon_jtag_uart_write+0x1dc>
         break;
    }
  }
  while (count > 0);
 4007068:	e0bff617 	ldw	r2,-40(fp)
 400706c:	00bfcf16 	blt	zero,r2,4006fac <altera_avalon_jtag_uart_write+0x10c>
 4007070:	00000306 	br	4007080 <altera_avalon_jtag_uart_write+0x1e0>
        break;
 4007074:	0001883a 	nop
 4007078:	00000106 	br	4007080 <altera_avalon_jtag_uart_write+0x1e0>
         break;
 400707c:	0001883a 	nop
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
 4007080:	e0fff717 	ldw	r3,-36(fp)
 4007084:	e0bffd17 	ldw	r2,-12(fp)
 4007088:	18800426 	beq	r3,r2,400709c <altera_avalon_jtag_uart_write+0x1fc>
    return ptr - start;
 400708c:	e0fff717 	ldw	r3,-36(fp)
 4007090:	e0bffd17 	ldw	r2,-12(fp)
 4007094:	1885c83a 	sub	r2,r3,r2
 4007098:	00000606 	br	40070b4 <altera_avalon_jtag_uart_write+0x214>
  else if (flags & O_NONBLOCK)
 400709c:	e0bff517 	ldw	r2,-44(fp)
 40070a0:	1090000c 	andi	r2,r2,16384
 40070a4:	10000226 	beq	r2,zero,40070b0 <altera_avalon_jtag_uart_write+0x210>
    return -EWOULDBLOCK;
 40070a8:	00bffd44 	movi	r2,-11
 40070ac:	00000106 	br	40070b4 <altera_avalon_jtag_uart_write+0x214>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
 40070b0:	00bffec4 	movi	r2,-5
}
 40070b4:	e037883a 	mov	sp,fp
 40070b8:	dfc00117 	ldw	ra,4(sp)
 40070bc:	df000017 	ldw	fp,0(sp)
 40070c0:	dec00204 	addi	sp,sp,8
 40070c4:	f800283a 	ret

040070c8 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
 40070c8:	defff904 	addi	sp,sp,-28
 40070cc:	dfc00615 	stw	ra,24(sp)
 40070d0:	df000515 	stw	fp,20(sp)
 40070d4:	df000504 	addi	fp,sp,20
 40070d8:	e13ffc15 	stw	r4,-16(fp)
 40070dc:	e17ffb15 	stw	r5,-20(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
 40070e0:	0007883a 	mov	r3,zero
 40070e4:	e0bffc17 	ldw	r2,-16(fp)
 40070e8:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
 40070ec:	e0bffc17 	ldw	r2,-16(fp)
 40070f0:	10800104 	addi	r2,r2,4
 40070f4:	10800037 	ldwio	r2,0(r2)
  NIOS2_READ_STATUS (context);
 40070f8:	0005303a 	rdctl	r2,status
 40070fc:	e0bffd15 	stw	r2,-12(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 4007100:	e0fffd17 	ldw	r3,-12(fp)
 4007104:	00bfff84 	movi	r2,-2
 4007108:	1884703a 	and	r2,r3,r2
 400710c:	1001703a 	wrctl	status,r2
  return context;
 4007110:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
 4007114:	e0bfff15 	stw	r2,-4(fp)
  alt_tick ();
 4007118:	4007acc0 	call	4007acc <alt_tick>
 400711c:	e0bfff17 	ldw	r2,-4(fp)
 4007120:	e0bffe15 	stw	r2,-8(fp)
  NIOS2_WRITE_STATUS (context);
 4007124:	e0bffe17 	ldw	r2,-8(fp)
 4007128:	1001703a 	wrctl	status,r2
}
 400712c:	0001883a 	nop
  alt_irq_enable_all(cpu_sr);
}
 4007130:	0001883a 	nop
 4007134:	e037883a 	mov	sp,fp
 4007138:	dfc00117 	ldw	ra,4(sp)
 400713c:	df000017 	ldw	fp,0(sp)
 4007140:	dec00204 	addi	sp,sp,8
 4007144:	f800283a 	ret

04007148 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
 4007148:	defff904 	addi	sp,sp,-28
 400714c:	dfc00615 	stw	ra,24(sp)
 4007150:	df000515 	stw	fp,20(sp)
 4007154:	df000504 	addi	fp,sp,20
 4007158:	e13ffe15 	stw	r4,-8(fp)
 400715c:	e17ffd15 	stw	r5,-12(fp)
 4007160:	e1bffc15 	stw	r6,-16(fp)
 4007164:	e1fffb15 	stw	r7,-20(fp)
 4007168:	e0bffb17 	ldw	r2,-20(fp)
 400716c:	e0bfff15 	stw	r2,-4(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
 4007170:	d0a5bb17 	ldw	r2,-26900(gp)
 4007174:	1000031e 	bne	r2,zero,4007184 <alt_avalon_timer_sc_init+0x3c>
  {
    _alt_tick_rate = nticks;
 4007178:	e0bfff17 	ldw	r2,-4(fp)
 400717c:	d0a5bb15 	stw	r2,-26900(gp)
    return 0;
 4007180:	00000106 	br	4007188 <alt_avalon_timer_sc_init+0x40>
  }
  else
  {
    return -1;
 4007184:	0001883a 	nop
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
 4007188:	e0bffe17 	ldw	r2,-8(fp)
 400718c:	10800104 	addi	r2,r2,4
 4007190:	00c001c4 	movi	r3,7
 4007194:	10c00035 	stwio	r3,0(r2)
  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
 4007198:	01810034 	movhi	r6,1024
 400719c:	319c3204 	addi	r6,r6,28872
 40071a0:	e17ffe17 	ldw	r5,-8(fp)
 40071a4:	e13ffc17 	ldw	r4,-16(fp)
 40071a8:	40004c80 	call	40004c8 <alt_irq_register>
#endif  
}
 40071ac:	0001883a 	nop
 40071b0:	e037883a 	mov	sp,fp
 40071b4:	dfc00117 	ldw	ra,4(sp)
 40071b8:	df000017 	ldw	fp,0(sp)
 40071bc:	dec00204 	addi	sp,sp,8
 40071c0:	f800283a 	ret

040071c4 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
 40071c4:	defff504 	addi	sp,sp,-44
 40071c8:	df000a15 	stw	fp,40(sp)
 40071cc:	df000a04 	addi	fp,sp,40
 40071d0:	e13ff915 	stw	r4,-28(fp)
 40071d4:	e17ff815 	stw	r5,-32(fp)
 40071d8:	e1bff715 	stw	r6,-36(fp)
 40071dc:	e1fff615 	stw	r7,-40(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
 40071e0:	e03fff15 	stw	zero,-4(fp)
  return _alt_tick_rate;
 40071e4:	d0a5bb17 	ldw	r2,-26900(gp)
  
  if (alt_ticks_per_second ())
 40071e8:	10003e26 	beq	r2,zero,40072e4 <alt_alarm_start+0x120>
  {
    if (alarm)
 40071ec:	e0bff917 	ldw	r2,-28(fp)
 40071f0:	10003a26 	beq	r2,zero,40072dc <alt_alarm_start+0x118>
    {
      alarm->callback = callback;
 40071f4:	e0bff917 	ldw	r2,-28(fp)
 40071f8:	e0fff717 	ldw	r3,-36(fp)
 40071fc:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
 4007200:	e0bff917 	ldw	r2,-28(fp)
 4007204:	e0fff617 	ldw	r3,-40(fp)
 4007208:	10c00515 	stw	r3,20(r2)
  NIOS2_READ_STATUS (context);
 400720c:	0005303a 	rdctl	r2,status
 4007210:	e0bffd15 	stw	r2,-12(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 4007214:	e0fffd17 	ldw	r3,-12(fp)
 4007218:	00bfff84 	movi	r2,-2
 400721c:	1884703a 	and	r2,r3,r2
 4007220:	1001703a 	wrctl	status,r2
  return context;
 4007224:	e0bffd17 	ldw	r2,-12(fp)
 
      irq_context = alt_irq_disable_all ();
 4007228:	e0bffe15 	stw	r2,-8(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
 400722c:	d0a5bc17 	ldw	r2,-26896(gp)
      
      current_nticks = alt_nticks();
 4007230:	e0bfff15 	stw	r2,-4(fp)
      
      alarm->time = nticks + current_nticks + 1; 
 4007234:	e0fff817 	ldw	r3,-32(fp)
 4007238:	e0bfff17 	ldw	r2,-4(fp)
 400723c:	1885883a 	add	r2,r3,r2
 4007240:	10c00044 	addi	r3,r2,1
 4007244:	e0bff917 	ldw	r2,-28(fp)
 4007248:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
 400724c:	e0bff917 	ldw	r2,-28(fp)
 4007250:	10c00217 	ldw	r3,8(r2)
 4007254:	e0bfff17 	ldw	r2,-4(fp)
 4007258:	1880042e 	bgeu	r3,r2,400726c <alt_alarm_start+0xa8>
      {
        alarm->rollover = 1;
 400725c:	e0bff917 	ldw	r2,-28(fp)
 4007260:	00c00044 	movi	r3,1
 4007264:	10c00405 	stb	r3,16(r2)
 4007268:	00000206 	br	4007274 <alt_alarm_start+0xb0>
      }
      else
      {
        alarm->rollover = 0;
 400726c:	e0bff917 	ldw	r2,-28(fp)
 4007270:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
 4007274:	e0bff917 	ldw	r2,-28(fp)
 4007278:	d0e00804 	addi	r3,gp,-32736
 400727c:	e0fffb15 	stw	r3,-20(fp)
 4007280:	e0bffa15 	stw	r2,-24(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 4007284:	e0bffa17 	ldw	r2,-24(fp)
 4007288:	e0fffb17 	ldw	r3,-20(fp)
 400728c:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 4007290:	e0bffb17 	ldw	r2,-20(fp)
 4007294:	10c00017 	ldw	r3,0(r2)
 4007298:	e0bffa17 	ldw	r2,-24(fp)
 400729c:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 40072a0:	e0bffb17 	ldw	r2,-20(fp)
 40072a4:	10800017 	ldw	r2,0(r2)
 40072a8:	e0fffa17 	ldw	r3,-24(fp)
 40072ac:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 40072b0:	e0bffb17 	ldw	r2,-20(fp)
 40072b4:	e0fffa17 	ldw	r3,-24(fp)
 40072b8:	10c00015 	stw	r3,0(r2)
}
 40072bc:	0001883a 	nop
 40072c0:	e0bffe17 	ldw	r2,-8(fp)
 40072c4:	e0bffc15 	stw	r2,-16(fp)
  NIOS2_WRITE_STATUS (context);
 40072c8:	e0bffc17 	ldw	r2,-16(fp)
 40072cc:	1001703a 	wrctl	status,r2
}
 40072d0:	0001883a 	nop
      alt_irq_enable_all (irq_context);

      return 0;
 40072d4:	0005883a 	mov	r2,zero
 40072d8:	00000306 	br	40072e8 <alt_alarm_start+0x124>
    }
    else
    {
      return -EINVAL;
 40072dc:	00bffa84 	movi	r2,-22
 40072e0:	00000106 	br	40072e8 <alt_alarm_start+0x124>
    }
  }
  else
  {
    return -ENOTSUP;
 40072e4:	00bfde84 	movi	r2,-134
  }
}
 40072e8:	e037883a 	mov	sp,fp
 40072ec:	df000017 	ldw	fp,0(sp)
 40072f0:	dec00104 	addi	sp,sp,4
 40072f4:	f800283a 	ret

040072f8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 40072f8:	defffe04 	addi	sp,sp,-8
 40072fc:	dfc00115 	stw	ra,4(sp)
 4007300:	df000015 	stw	fp,0(sp)
 4007304:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 4007308:	d0a00717 	ldw	r2,-32740(gp)
 400730c:	10000326 	beq	r2,zero,400731c <alt_get_errno+0x24>
 4007310:	d0a00717 	ldw	r2,-32740(gp)
 4007314:	103ee83a 	callr	r2
 4007318:	00000106 	br	4007320 <alt_get_errno+0x28>
 400731c:	d0a5bd04 	addi	r2,gp,-26892
}
 4007320:	e037883a 	mov	sp,fp
 4007324:	dfc00117 	ldw	ra,4(sp)
 4007328:	df000017 	ldw	fp,0(sp)
 400732c:	dec00204 	addi	sp,sp,8
 4007330:	f800283a 	ret

04007334 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
 4007334:	defffb04 	addi	sp,sp,-20
 4007338:	dfc00415 	stw	ra,16(sp)
 400733c:	df000315 	stw	fp,12(sp)
 4007340:	df000304 	addi	fp,sp,12
 4007344:	e13ffd15 	stw	r4,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
 4007348:	e0bffd17 	ldw	r2,-12(fp)
 400734c:	10000616 	blt	r2,zero,4007368 <close+0x34>
 4007350:	e0bffd17 	ldw	r2,-12(fp)
 4007354:	10c00324 	muli	r3,r2,12
 4007358:	00810074 	movhi	r2,1025
 400735c:	10a4b504 	addi	r2,r2,-27948
 4007360:	1885883a 	add	r2,r3,r2
 4007364:	00000106 	br	400736c <close+0x38>
 4007368:	0005883a 	mov	r2,zero
 400736c:	e0bfff15 	stw	r2,-4(fp)

  if (fd)
 4007370:	e0bfff17 	ldw	r2,-4(fp)
 4007374:	10001926 	beq	r2,zero,40073dc <close+0xa8>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
 4007378:	e0bfff17 	ldw	r2,-4(fp)
 400737c:	10800017 	ldw	r2,0(r2)
 4007380:	10800417 	ldw	r2,16(r2)
 4007384:	10000626 	beq	r2,zero,40073a0 <close+0x6c>
 4007388:	e0bfff17 	ldw	r2,-4(fp)
 400738c:	10800017 	ldw	r2,0(r2)
 4007390:	10800417 	ldw	r2,16(r2)
 4007394:	e13fff17 	ldw	r4,-4(fp)
 4007398:	103ee83a 	callr	r2
 400739c:	00000106 	br	40073a4 <close+0x70>
 40073a0:	0005883a 	mov	r2,zero
 40073a4:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
 40073a8:	e13ffd17 	ldw	r4,-12(fp)
 40073ac:	40079d00 	call	40079d0 <alt_release_fd>
    if (rval < 0)
 40073b0:	e0bffe17 	ldw	r2,-8(fp)
 40073b4:	1000070e 	bge	r2,zero,40073d4 <close+0xa0>
    {
      ALT_ERRNO = -rval;
 40073b8:	40072f80 	call	40072f8 <alt_get_errno>
 40073bc:	1007883a 	mov	r3,r2
 40073c0:	e0bffe17 	ldw	r2,-8(fp)
 40073c4:	0085c83a 	sub	r2,zero,r2
 40073c8:	18800015 	stw	r2,0(r3)
      return -1;
 40073cc:	00bfffc4 	movi	r2,-1
 40073d0:	00000706 	br	40073f0 <close+0xbc>
    }
    return 0;
 40073d4:	0005883a 	mov	r2,zero
 40073d8:	00000506 	br	40073f0 <close+0xbc>
  }
  else
  {
    ALT_ERRNO = EBADFD;
 40073dc:	40072f80 	call	40072f8 <alt_get_errno>
 40073e0:	1007883a 	mov	r3,r2
 40073e4:	00801444 	movi	r2,81
 40073e8:	18800015 	stw	r2,0(r3)
    return -1;
 40073ec:	00bfffc4 	movi	r2,-1
  }
}
 40073f0:	e037883a 	mov	sp,fp
 40073f4:	dfc00117 	ldw	ra,4(sp)
 40073f8:	df000017 	ldw	fp,0(sp)
 40073fc:	dec00204 	addi	sp,sp,8
 4007400:	f800283a 	ret

04007404 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
 4007404:	defffe04 	addi	sp,sp,-8
 4007408:	df000115 	stw	fp,4(sp)
 400740c:	df000104 	addi	fp,sp,4
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
 4007410:	e03fff15 	stw	zero,-4(fp)
 4007414:	00000506 	br	400742c <alt_dcache_flush_all+0x28>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
 4007418:	e0bfff17 	ldw	r2,-4(fp)
 400741c:	1000003b 	flushd	0(r2)
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
 4007420:	e0bfff17 	ldw	r2,-4(fp)
 4007424:	10800804 	addi	r2,r2,32
 4007428:	e0bfff15 	stw	r2,-4(fp)
 400742c:	e0bfff17 	ldw	r2,-4(fp)
 4007430:	10820030 	cmpltui	r2,r2,2048
 4007434:	103ff81e 	bne	r2,zero,4007418 <alt_dcache_flush_all+0x14>
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 4007438:	0001883a 	nop
 400743c:	0001883a 	nop
 4007440:	e037883a 	mov	sp,fp
 4007444:	df000017 	ldw	fp,0(sp)
 4007448:	dec00104 	addi	sp,sp,4
 400744c:	f800283a 	ret

04007450 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
 4007450:	defffc04 	addi	sp,sp,-16
 4007454:	df000315 	stw	fp,12(sp)
 4007458:	df000304 	addi	fp,sp,12
 400745c:	e13fff15 	stw	r4,-4(fp)
 4007460:	e17ffe15 	stw	r5,-8(fp)
 4007464:	e1bffd15 	stw	r6,-12(fp)
  return len;
 4007468:	e0bffd17 	ldw	r2,-12(fp)
}
 400746c:	e037883a 	mov	sp,fp
 4007470:	df000017 	ldw	fp,0(sp)
 4007474:	dec00104 	addi	sp,sp,4
 4007478:	f800283a 	ret

0400747c <alt_get_errno>:
{
 400747c:	defffe04 	addi	sp,sp,-8
 4007480:	dfc00115 	stw	ra,4(sp)
 4007484:	df000015 	stw	fp,0(sp)
 4007488:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 400748c:	d0a00717 	ldw	r2,-32740(gp)
 4007490:	10000326 	beq	r2,zero,40074a0 <alt_get_errno+0x24>
 4007494:	d0a00717 	ldw	r2,-32740(gp)
 4007498:	103ee83a 	callr	r2
 400749c:	00000106 	br	40074a4 <alt_get_errno+0x28>
 40074a0:	d0a5bd04 	addi	r2,gp,-26892
}
 40074a4:	e037883a 	mov	sp,fp
 40074a8:	dfc00117 	ldw	ra,4(sp)
 40074ac:	df000017 	ldw	fp,0(sp)
 40074b0:	dec00204 	addi	sp,sp,8
 40074b4:	f800283a 	ret

040074b8 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
 40074b8:	defffa04 	addi	sp,sp,-24
 40074bc:	dfc00515 	stw	ra,20(sp)
 40074c0:	df000415 	stw	fp,16(sp)
 40074c4:	df000404 	addi	fp,sp,16
 40074c8:	e13ffd15 	stw	r4,-12(fp)
 40074cc:	e17ffc15 	stw	r5,-16(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
 40074d0:	e0bffd17 	ldw	r2,-12(fp)
 40074d4:	10000326 	beq	r2,zero,40074e4 <alt_dev_llist_insert+0x2c>
 40074d8:	e0bffd17 	ldw	r2,-12(fp)
 40074dc:	10800217 	ldw	r2,8(r2)
 40074e0:	1000061e 	bne	r2,zero,40074fc <alt_dev_llist_insert+0x44>
  {
    ALT_ERRNO = EINVAL;
 40074e4:	400747c0 	call	400747c <alt_get_errno>
 40074e8:	1007883a 	mov	r3,r2
 40074ec:	00800584 	movi	r2,22
 40074f0:	18800015 	stw	r2,0(r3)
    return -EINVAL;
 40074f4:	00bffa84 	movi	r2,-22
 40074f8:	00001406 	br	400754c <alt_dev_llist_insert+0x94>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
 40074fc:	e0bffd17 	ldw	r2,-12(fp)
 4007500:	e0fffc17 	ldw	r3,-16(fp)
 4007504:	e0ffff15 	stw	r3,-4(fp)
 4007508:	e0bffe15 	stw	r2,-8(fp)
  entry->previous = list;
 400750c:	e0bffe17 	ldw	r2,-8(fp)
 4007510:	e0ffff17 	ldw	r3,-4(fp)
 4007514:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 4007518:	e0bfff17 	ldw	r2,-4(fp)
 400751c:	10c00017 	ldw	r3,0(r2)
 4007520:	e0bffe17 	ldw	r2,-8(fp)
 4007524:	10c00015 	stw	r3,0(r2)
  list->next->previous = entry;
 4007528:	e0bfff17 	ldw	r2,-4(fp)
 400752c:	10800017 	ldw	r2,0(r2)
 4007530:	e0fffe17 	ldw	r3,-8(fp)
 4007534:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 4007538:	e0bfff17 	ldw	r2,-4(fp)
 400753c:	e0fffe17 	ldw	r3,-8(fp)
 4007540:	10c00015 	stw	r3,0(r2)
}
 4007544:	0001883a 	nop

  return 0;  
 4007548:	0005883a 	mov	r2,zero
}
 400754c:	e037883a 	mov	sp,fp
 4007550:	dfc00117 	ldw	ra,4(sp)
 4007554:	df000017 	ldw	fp,0(sp)
 4007558:	dec00204 	addi	sp,sp,8
 400755c:	f800283a 	ret

04007560 <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
 4007560:	defffd04 	addi	sp,sp,-12
 4007564:	dfc00215 	stw	ra,8(sp)
 4007568:	df000115 	stw	fp,4(sp)
 400756c:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 4007570:	00810074 	movhi	r2,1025
 4007574:	10a07f04 	addi	r2,r2,-32260
 4007578:	e0bfff15 	stw	r2,-4(fp)
 400757c:	00000606 	br	4007598 <_do_ctors+0x38>
        (*ctor) (); 
 4007580:	e0bfff17 	ldw	r2,-4(fp)
 4007584:	10800017 	ldw	r2,0(r2)
 4007588:	103ee83a 	callr	r2
  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 400758c:	e0bfff17 	ldw	r2,-4(fp)
 4007590:	10bfff04 	addi	r2,r2,-4
 4007594:	e0bfff15 	stw	r2,-4(fp)
 4007598:	e0ffff17 	ldw	r3,-4(fp)
 400759c:	00810074 	movhi	r2,1025
 40075a0:	10a08004 	addi	r2,r2,-32256
 40075a4:	18bff62e 	bgeu	r3,r2,4007580 <_do_ctors+0x20>
}
 40075a8:	0001883a 	nop
 40075ac:	0001883a 	nop
 40075b0:	e037883a 	mov	sp,fp
 40075b4:	dfc00117 	ldw	ra,4(sp)
 40075b8:	df000017 	ldw	fp,0(sp)
 40075bc:	dec00204 	addi	sp,sp,8
 40075c0:	f800283a 	ret

040075c4 <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
 40075c4:	defffd04 	addi	sp,sp,-12
 40075c8:	dfc00215 	stw	ra,8(sp)
 40075cc:	df000115 	stw	fp,4(sp)
 40075d0:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 40075d4:	00810074 	movhi	r2,1025
 40075d8:	10a07f04 	addi	r2,r2,-32260
 40075dc:	e0bfff15 	stw	r2,-4(fp)
 40075e0:	00000606 	br	40075fc <_do_dtors+0x38>
        (*dtor) (); 
 40075e4:	e0bfff17 	ldw	r2,-4(fp)
 40075e8:	10800017 	ldw	r2,0(r2)
 40075ec:	103ee83a 	callr	r2
  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 40075f0:	e0bfff17 	ldw	r2,-4(fp)
 40075f4:	10bfff04 	addi	r2,r2,-4
 40075f8:	e0bfff15 	stw	r2,-4(fp)
 40075fc:	e0ffff17 	ldw	r3,-4(fp)
 4007600:	00810074 	movhi	r2,1025
 4007604:	10a08004 	addi	r2,r2,-32256
 4007608:	18bff62e 	bgeu	r3,r2,40075e4 <_do_dtors+0x20>
}
 400760c:	0001883a 	nop
 4007610:	0001883a 	nop
 4007614:	e037883a 	mov	sp,fp
 4007618:	dfc00117 	ldw	ra,4(sp)
 400761c:	df000017 	ldw	fp,0(sp)
 4007620:	dec00204 	addi	sp,sp,8
 4007624:	f800283a 	ret

04007628 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
 4007628:	defffe04 	addi	sp,sp,-8
 400762c:	dfc00115 	stw	ra,4(sp)
 4007630:	df000015 	stw	fp,0(sp)
 4007634:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
 4007638:	01440004 	movi	r5,4096
 400763c:	0009883a 	mov	r4,zero
 4007640:	4007e300 	call	4007e30 <alt_icache_flush>
#endif
}
 4007644:	0001883a 	nop
 4007648:	e037883a 	mov	sp,fp
 400764c:	dfc00117 	ldw	ra,4(sp)
 4007650:	df000017 	ldw	fp,0(sp)
 4007654:	dec00204 	addi	sp,sp,8
 4007658:	f800283a 	ret

0400765c <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
 400765c:	defff904 	addi	sp,sp,-28
 4007660:	dfc00615 	stw	ra,24(sp)
 4007664:	df000515 	stw	fp,20(sp)
 4007668:	df000504 	addi	fp,sp,20
 400766c:	e13ffe15 	stw	r4,-8(fp)
 4007670:	e17ffd15 	stw	r5,-12(fp)
 4007674:	e1bffc15 	stw	r6,-16(fp)
 4007678:	e1fffb15 	stw	r7,-20(fp)
  int old;

  old = open (name, flags, mode);
 400767c:	e1bffb17 	ldw	r6,-20(fp)
 4007680:	e17ffc17 	ldw	r5,-16(fp)
 4007684:	e13ffd17 	ldw	r4,-12(fp)
 4007688:	400787c0 	call	400787c <open>
 400768c:	e0bfff15 	stw	r2,-4(fp)

  if (old >= 0)
 4007690:	e0bfff17 	ldw	r2,-4(fp)
 4007694:	10001716 	blt	r2,zero,40076f4 <alt_open_fd+0x98>
  {
    fd->dev      = alt_fd_list[old].dev;
 4007698:	e0bfff17 	ldw	r2,-4(fp)
 400769c:	10c00324 	muli	r3,r2,12
 40076a0:	00810074 	movhi	r2,1025
 40076a4:	1885883a 	add	r2,r3,r2
 40076a8:	10e4b517 	ldw	r3,-27948(r2)
 40076ac:	e0bffe17 	ldw	r2,-8(fp)
 40076b0:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
 40076b4:	e0bfff17 	ldw	r2,-4(fp)
 40076b8:	10c00324 	muli	r3,r2,12
 40076bc:	00810074 	movhi	r2,1025
 40076c0:	1885883a 	add	r2,r3,r2
 40076c4:	10e4b617 	ldw	r3,-27944(r2)
 40076c8:	e0bffe17 	ldw	r2,-8(fp)
 40076cc:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
 40076d0:	e0bfff17 	ldw	r2,-4(fp)
 40076d4:	10c00324 	muli	r3,r2,12
 40076d8:	00810074 	movhi	r2,1025
 40076dc:	1885883a 	add	r2,r3,r2
 40076e0:	10e4b717 	ldw	r3,-27940(r2)
 40076e4:	e0bffe17 	ldw	r2,-8(fp)
 40076e8:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
 40076ec:	e13fff17 	ldw	r4,-4(fp)
 40076f0:	40079d00 	call	40079d0 <alt_release_fd>
  }
} 
 40076f4:	0001883a 	nop
 40076f8:	e037883a 	mov	sp,fp
 40076fc:	dfc00117 	ldw	ra,4(sp)
 4007700:	df000017 	ldw	fp,0(sp)
 4007704:	dec00204 	addi	sp,sp,8
 4007708:	f800283a 	ret

0400770c <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
 400770c:	defffb04 	addi	sp,sp,-20
 4007710:	dfc00415 	stw	ra,16(sp)
 4007714:	df000315 	stw	fp,12(sp)
 4007718:	df000304 	addi	fp,sp,12
 400771c:	e13fff15 	stw	r4,-4(fp)
 4007720:	e17ffe15 	stw	r5,-8(fp)
 4007724:	e1bffd15 	stw	r6,-12(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
 4007728:	01c07fc4 	movi	r7,511
 400772c:	01800044 	movi	r6,1
 4007730:	e17fff17 	ldw	r5,-4(fp)
 4007734:	01010074 	movhi	r4,1025
 4007738:	2124b804 	addi	r4,r4,-27936
 400773c:	400765c0 	call	400765c <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
 4007740:	01c07fc4 	movi	r7,511
 4007744:	000d883a 	mov	r6,zero
 4007748:	e17ffe17 	ldw	r5,-8(fp)
 400774c:	01010074 	movhi	r4,1025
 4007750:	2124b504 	addi	r4,r4,-27948
 4007754:	400765c0 	call	400765c <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
 4007758:	01c07fc4 	movi	r7,511
 400775c:	01800044 	movi	r6,1
 4007760:	e17ffd17 	ldw	r5,-12(fp)
 4007764:	01010074 	movhi	r4,1025
 4007768:	2124bb04 	addi	r4,r4,-27924
 400776c:	400765c0 	call	400765c <alt_open_fd>
}  
 4007770:	0001883a 	nop
 4007774:	e037883a 	mov	sp,fp
 4007778:	dfc00117 	ldw	ra,4(sp)
 400777c:	df000017 	ldw	fp,0(sp)
 4007780:	dec00204 	addi	sp,sp,8
 4007784:	f800283a 	ret

04007788 <alt_get_errno>:
{
 4007788:	defffe04 	addi	sp,sp,-8
 400778c:	dfc00115 	stw	ra,4(sp)
 4007790:	df000015 	stw	fp,0(sp)
 4007794:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 4007798:	d0a00717 	ldw	r2,-32740(gp)
 400779c:	10000326 	beq	r2,zero,40077ac <alt_get_errno+0x24>
 40077a0:	d0a00717 	ldw	r2,-32740(gp)
 40077a4:	103ee83a 	callr	r2
 40077a8:	00000106 	br	40077b0 <alt_get_errno+0x28>
 40077ac:	d0a5bd04 	addi	r2,gp,-26892
}
 40077b0:	e037883a 	mov	sp,fp
 40077b4:	dfc00117 	ldw	ra,4(sp)
 40077b8:	df000017 	ldw	fp,0(sp)
 40077bc:	dec00204 	addi	sp,sp,8
 40077c0:	f800283a 	ret

040077c4 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
 40077c4:	defffd04 	addi	sp,sp,-12
 40077c8:	df000215 	stw	fp,8(sp)
 40077cc:	df000204 	addi	fp,sp,8
 40077d0:	e13ffe15 	stw	r4,-8(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
 40077d4:	e0bffe17 	ldw	r2,-8(fp)
 40077d8:	10800217 	ldw	r2,8(r2)
 40077dc:	10d00034 	orhi	r3,r2,16384
 40077e0:	e0bffe17 	ldw	r2,-8(fp)
 40077e4:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 40077e8:	e03fff15 	stw	zero,-4(fp)
 40077ec:	00001a06 	br	4007858 <alt_file_locked+0x94>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 40077f0:	e0bfff17 	ldw	r2,-4(fp)
 40077f4:	10c00324 	muli	r3,r2,12
 40077f8:	00810074 	movhi	r2,1025
 40077fc:	1885883a 	add	r2,r3,r2
 4007800:	10e4b517 	ldw	r3,-27948(r2)
 4007804:	e0bffe17 	ldw	r2,-8(fp)
 4007808:	10800017 	ldw	r2,0(r2)
 400780c:	18800f1e 	bne	r3,r2,400784c <alt_file_locked+0x88>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
 4007810:	e0bfff17 	ldw	r2,-4(fp)
 4007814:	10c00324 	muli	r3,r2,12
 4007818:	00810074 	movhi	r2,1025
 400781c:	1885883a 	add	r2,r3,r2
 4007820:	10a4b717 	ldw	r2,-27940(r2)
    if ((alt_fd_list[i].dev == fd->dev) &&
 4007824:	1000090e 	bge	r2,zero,400784c <alt_file_locked+0x88>
        (&alt_fd_list[i] != fd))
 4007828:	e0bfff17 	ldw	r2,-4(fp)
 400782c:	10c00324 	muli	r3,r2,12
 4007830:	00810074 	movhi	r2,1025
 4007834:	10a4b504 	addi	r2,r2,-27948
 4007838:	1885883a 	add	r2,r3,r2
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
 400783c:	e0fffe17 	ldw	r3,-8(fp)
 4007840:	18800226 	beq	r3,r2,400784c <alt_file_locked+0x88>
    {
      return -EACCES;
 4007844:	00bffcc4 	movi	r2,-13
 4007848:	00000806 	br	400786c <alt_file_locked+0xa8>
  for (i = 0; i <= alt_max_fd; i++)
 400784c:	e0bfff17 	ldw	r2,-4(fp)
 4007850:	10800044 	addi	r2,r2,1
 4007854:	e0bfff15 	stw	r2,-4(fp)
 4007858:	d0a00617 	ldw	r2,-32744(gp)
 400785c:	1007883a 	mov	r3,r2
 4007860:	e0bfff17 	ldw	r2,-4(fp)
 4007864:	18bfe22e 	bgeu	r3,r2,40077f0 <alt_file_locked+0x2c>
    }
  }
  
  /* The device is not locked */
 
  return 0;
 4007868:	0005883a 	mov	r2,zero
}
 400786c:	e037883a 	mov	sp,fp
 4007870:	df000017 	ldw	fp,0(sp)
 4007874:	dec00104 	addi	sp,sp,4
 4007878:	f800283a 	ret

0400787c <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
 400787c:	defff604 	addi	sp,sp,-40
 4007880:	dfc00915 	stw	ra,36(sp)
 4007884:	df000815 	stw	fp,32(sp)
 4007888:	df000804 	addi	fp,sp,32
 400788c:	e13ffa15 	stw	r4,-24(fp)
 4007890:	e17ff915 	stw	r5,-28(fp)
 4007894:	e1bff815 	stw	r6,-32(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
 4007898:	00bfffc4 	movi	r2,-1
 400789c:	e0bffe15 	stw	r2,-8(fp)
  int status = -ENODEV;
 40078a0:	00bffb44 	movi	r2,-19
 40078a4:	e0bffd15 	stw	r2,-12(fp)
  int isafs = 0;
 40078a8:	e03ffc15 	stw	zero,-16(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
 40078ac:	d1600404 	addi	r5,gp,-32752
 40078b0:	e13ffa17 	ldw	r4,-24(fp)
 40078b4:	4007bf80 	call	4007bf8 <alt_find_dev>
 40078b8:	e0bfff15 	stw	r2,-4(fp)
 40078bc:	e0bfff17 	ldw	r2,-4(fp)
 40078c0:	1000051e 	bne	r2,zero,40078d8 <open+0x5c>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
 40078c4:	e13ffa17 	ldw	r4,-24(fp)
 40078c8:	4007c880 	call	4007c88 <alt_find_file>
 40078cc:	e0bfff15 	stw	r2,-4(fp)
    isafs = 1;
 40078d0:	00800044 	movi	r2,1
 40078d4:	e0bffc15 	stw	r2,-16(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
 40078d8:	e0bfff17 	ldw	r2,-4(fp)
 40078dc:	10002926 	beq	r2,zero,4007984 <open+0x108>
  {
    if ((index = alt_get_fd (dev)) < 0)
 40078e0:	e13fff17 	ldw	r4,-4(fp)
 40078e4:	4007d900 	call	4007d90 <alt_get_fd>
 40078e8:	e0bffe15 	stw	r2,-8(fp)
 40078ec:	e0bffe17 	ldw	r2,-8(fp)
 40078f0:	1000030e 	bge	r2,zero,4007900 <open+0x84>
    {
      status = index;
 40078f4:	e0bffe17 	ldw	r2,-8(fp)
 40078f8:	e0bffd15 	stw	r2,-12(fp)
 40078fc:	00002306 	br	400798c <open+0x110>
    }
    else
    {
      fd = &alt_fd_list[index];
 4007900:	e0bffe17 	ldw	r2,-8(fp)
 4007904:	10c00324 	muli	r3,r2,12
 4007908:	00810074 	movhi	r2,1025
 400790c:	10a4b504 	addi	r2,r2,-27948
 4007910:	1885883a 	add	r2,r3,r2
 4007914:	e0bffb15 	stw	r2,-20(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
 4007918:	e0fff917 	ldw	r3,-28(fp)
 400791c:	00900034 	movhi	r2,16384
 4007920:	10bfffc4 	addi	r2,r2,-1
 4007924:	1886703a 	and	r3,r3,r2
 4007928:	e0bffb17 	ldw	r2,-20(fp)
 400792c:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
 4007930:	e0bffc17 	ldw	r2,-16(fp)
 4007934:	1000051e 	bne	r2,zero,400794c <open+0xd0>
 4007938:	e13ffb17 	ldw	r4,-20(fp)
 400793c:	40077c40 	call	40077c4 <alt_file_locked>
 4007940:	e0bffd15 	stw	r2,-12(fp)
 4007944:	e0bffd17 	ldw	r2,-12(fp)
 4007948:	10001016 	blt	r2,zero,400798c <open+0x110>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
 400794c:	e0bfff17 	ldw	r2,-4(fp)
 4007950:	10800317 	ldw	r2,12(r2)
 4007954:	10000826 	beq	r2,zero,4007978 <open+0xfc>
 4007958:	e0bfff17 	ldw	r2,-4(fp)
 400795c:	10800317 	ldw	r2,12(r2)
 4007960:	e1fff817 	ldw	r7,-32(fp)
 4007964:	e1bff917 	ldw	r6,-28(fp)
 4007968:	e17ffa17 	ldw	r5,-24(fp)
 400796c:	e13ffb17 	ldw	r4,-20(fp)
 4007970:	103ee83a 	callr	r2
 4007974:	00000106 	br	400797c <open+0x100>
 4007978:	0005883a 	mov	r2,zero
 400797c:	e0bffd15 	stw	r2,-12(fp)
 4007980:	00000206 	br	400798c <open+0x110>
      }
    }
  }
  else
  {
    status = -ENODEV;
 4007984:	00bffb44 	movi	r2,-19
 4007988:	e0bffd15 	stw	r2,-12(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
 400798c:	e0bffd17 	ldw	r2,-12(fp)
 4007990:	1000090e 	bge	r2,zero,40079b8 <open+0x13c>
  {
    alt_release_fd (index);  
 4007994:	e13ffe17 	ldw	r4,-8(fp)
 4007998:	40079d00 	call	40079d0 <alt_release_fd>
    ALT_ERRNO = -status;
 400799c:	40077880 	call	4007788 <alt_get_errno>
 40079a0:	1007883a 	mov	r3,r2
 40079a4:	e0bffd17 	ldw	r2,-12(fp)
 40079a8:	0085c83a 	sub	r2,zero,r2
 40079ac:	18800015 	stw	r2,0(r3)
    return -1;
 40079b0:	00bfffc4 	movi	r2,-1
 40079b4:	00000106 	br	40079bc <open+0x140>
  }
  
  /* return the reference upon success */

  return index;
 40079b8:	e0bffe17 	ldw	r2,-8(fp)
}
 40079bc:	e037883a 	mov	sp,fp
 40079c0:	dfc00117 	ldw	ra,4(sp)
 40079c4:	df000017 	ldw	fp,0(sp)
 40079c8:	dec00204 	addi	sp,sp,8
 40079cc:	f800283a 	ret

040079d0 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
 40079d0:	defffe04 	addi	sp,sp,-8
 40079d4:	df000115 	stw	fp,4(sp)
 40079d8:	df000104 	addi	fp,sp,4
 40079dc:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
 40079e0:	e0bfff17 	ldw	r2,-4(fp)
 40079e4:	108000d0 	cmplti	r2,r2,3
 40079e8:	10000a1e 	bne	r2,zero,4007a14 <alt_release_fd+0x44>
  {
    alt_fd_list[fd].fd_flags = 0;
 40079ec:	e0bfff17 	ldw	r2,-4(fp)
 40079f0:	10c00324 	muli	r3,r2,12
 40079f4:	00810074 	movhi	r2,1025
 40079f8:	1885883a 	add	r2,r3,r2
 40079fc:	1024b715 	stw	zero,-27940(r2)
    alt_fd_list[fd].dev      = 0;
 4007a00:	e0bfff17 	ldw	r2,-4(fp)
 4007a04:	10c00324 	muli	r3,r2,12
 4007a08:	00810074 	movhi	r2,1025
 4007a0c:	1885883a 	add	r2,r3,r2
 4007a10:	1024b515 	stw	zero,-27948(r2)
  }
}
 4007a14:	0001883a 	nop
 4007a18:	e037883a 	mov	sp,fp
 4007a1c:	df000017 	ldw	fp,0(sp)
 4007a20:	dec00104 	addi	sp,sp,4
 4007a24:	f800283a 	ret

04007a28 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
 4007a28:	defffa04 	addi	sp,sp,-24
 4007a2c:	df000515 	stw	fp,20(sp)
 4007a30:	df000504 	addi	fp,sp,20
 4007a34:	e13ffb15 	stw	r4,-20(fp)
  NIOS2_READ_STATUS (context);
 4007a38:	0005303a 	rdctl	r2,status
 4007a3c:	e0bffc15 	stw	r2,-16(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 4007a40:	e0fffc17 	ldw	r3,-16(fp)
 4007a44:	00bfff84 	movi	r2,-2
 4007a48:	1884703a 	and	r2,r3,r2
 4007a4c:	1001703a 	wrctl	status,r2
  return context;
 4007a50:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
 4007a54:	e0bfff15 	stw	r2,-4(fp)
  alt_llist_remove (&alarm->llist);
 4007a58:	e0bffb17 	ldw	r2,-20(fp)
 4007a5c:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
 4007a60:	e0bffd17 	ldw	r2,-12(fp)
 4007a64:	10800017 	ldw	r2,0(r2)
 4007a68:	e0fffd17 	ldw	r3,-12(fp)
 4007a6c:	18c00117 	ldw	r3,4(r3)
 4007a70:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
 4007a74:	e0bffd17 	ldw	r2,-12(fp)
 4007a78:	10800117 	ldw	r2,4(r2)
 4007a7c:	e0fffd17 	ldw	r3,-12(fp)
 4007a80:	18c00017 	ldw	r3,0(r3)
 4007a84:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
 4007a88:	e0bffd17 	ldw	r2,-12(fp)
 4007a8c:	e0fffd17 	ldw	r3,-12(fp)
 4007a90:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
 4007a94:	e0bffd17 	ldw	r2,-12(fp)
 4007a98:	e0fffd17 	ldw	r3,-12(fp)
 4007a9c:	10c00015 	stw	r3,0(r2)
} 
 4007aa0:	0001883a 	nop
 4007aa4:	e0bfff17 	ldw	r2,-4(fp)
 4007aa8:	e0bffe15 	stw	r2,-8(fp)
  NIOS2_WRITE_STATUS (context);
 4007aac:	e0bffe17 	ldw	r2,-8(fp)
 4007ab0:	1001703a 	wrctl	status,r2
}
 4007ab4:	0001883a 	nop
  alt_irq_enable_all (irq_context);
}
 4007ab8:	0001883a 	nop
 4007abc:	e037883a 	mov	sp,fp
 4007ac0:	df000017 	ldw	fp,0(sp)
 4007ac4:	dec00104 	addi	sp,sp,4
 4007ac8:	f800283a 	ret

04007acc <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 4007acc:	defffb04 	addi	sp,sp,-20
 4007ad0:	dfc00415 	stw	ra,16(sp)
 4007ad4:	df000315 	stw	fp,12(sp)
 4007ad8:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
 4007adc:	d0a00817 	ldw	r2,-32736(gp)
 4007ae0:	e0bfff15 	stw	r2,-4(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 4007ae4:	d0a5bc17 	ldw	r2,-26896(gp)
 4007ae8:	10800044 	addi	r2,r2,1
 4007aec:	d0a5bc15 	stw	r2,-26896(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 4007af0:	00002e06 	br	4007bac <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
 4007af4:	e0bfff17 	ldw	r2,-4(fp)
 4007af8:	10800017 	ldw	r2,0(r2)
 4007afc:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
 4007b00:	e0bfff17 	ldw	r2,-4(fp)
 4007b04:	10800403 	ldbu	r2,16(r2)
 4007b08:	10803fcc 	andi	r2,r2,255
 4007b0c:	10000426 	beq	r2,zero,4007b20 <alt_tick+0x54>
 4007b10:	d0a5bc17 	ldw	r2,-26896(gp)
 4007b14:	1000021e 	bne	r2,zero,4007b20 <alt_tick+0x54>
    {
      alarm->rollover = 0;
 4007b18:	e0bfff17 	ldw	r2,-4(fp)
 4007b1c:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
 4007b20:	e0bfff17 	ldw	r2,-4(fp)
 4007b24:	10800217 	ldw	r2,8(r2)
 4007b28:	d0e5bc17 	ldw	r3,-26896(gp)
 4007b2c:	18801d36 	bltu	r3,r2,4007ba4 <alt_tick+0xd8>
 4007b30:	e0bfff17 	ldw	r2,-4(fp)
 4007b34:	10800403 	ldbu	r2,16(r2)
 4007b38:	10803fcc 	andi	r2,r2,255
 4007b3c:	1000191e 	bne	r2,zero,4007ba4 <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
 4007b40:	e0bfff17 	ldw	r2,-4(fp)
 4007b44:	10800317 	ldw	r2,12(r2)
 4007b48:	e0ffff17 	ldw	r3,-4(fp)
 4007b4c:	18c00517 	ldw	r3,20(r3)
 4007b50:	1809883a 	mov	r4,r3
 4007b54:	103ee83a 	callr	r2
 4007b58:	e0bffd15 	stw	r2,-12(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
 4007b5c:	e0bffd17 	ldw	r2,-12(fp)
 4007b60:	1000031e 	bne	r2,zero,4007b70 <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
 4007b64:	e13fff17 	ldw	r4,-4(fp)
 4007b68:	4007a280 	call	4007a28 <alt_alarm_stop>
 4007b6c:	00000d06 	br	4007ba4 <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
 4007b70:	e0bfff17 	ldw	r2,-4(fp)
 4007b74:	10c00217 	ldw	r3,8(r2)
 4007b78:	e0bffd17 	ldw	r2,-12(fp)
 4007b7c:	1887883a 	add	r3,r3,r2
 4007b80:	e0bfff17 	ldw	r2,-4(fp)
 4007b84:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
 4007b88:	e0bfff17 	ldw	r2,-4(fp)
 4007b8c:	10c00217 	ldw	r3,8(r2)
 4007b90:	d0a5bc17 	ldw	r2,-26896(gp)
 4007b94:	1880032e 	bgeu	r3,r2,4007ba4 <alt_tick+0xd8>
        {
          alarm->rollover = 1;
 4007b98:	e0bfff17 	ldw	r2,-4(fp)
 4007b9c:	00c00044 	movi	r3,1
 4007ba0:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
 4007ba4:	e0bffe17 	ldw	r2,-8(fp)
 4007ba8:	e0bfff15 	stw	r2,-4(fp)
  while (alarm != (alt_alarm*) &alt_alarm_list)
 4007bac:	e0ffff17 	ldw	r3,-4(fp)
 4007bb0:	d0a00804 	addi	r2,gp,-32736
 4007bb4:	18bfcf1e 	bne	r3,r2,4007af4 <alt_tick+0x28>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
 4007bb8:	0001883a 	nop
}
 4007bbc:	0001883a 	nop
 4007bc0:	e037883a 	mov	sp,fp
 4007bc4:	dfc00117 	ldw	ra,4(sp)
 4007bc8:	df000017 	ldw	fp,0(sp)
 4007bcc:	dec00204 	addi	sp,sp,8
 4007bd0:	f800283a 	ret

04007bd4 <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
 4007bd4:	deffff04 	addi	sp,sp,-4
 4007bd8:	df000015 	stw	fp,0(sp)
 4007bdc:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
 4007be0:	000170fa 	wrctl	ienable,zero
}
 4007be4:	0001883a 	nop
 4007be8:	e037883a 	mov	sp,fp
 4007bec:	df000017 	ldw	fp,0(sp)
 4007bf0:	dec00104 	addi	sp,sp,4
 4007bf4:	f800283a 	ret

04007bf8 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
 4007bf8:	defffa04 	addi	sp,sp,-24
 4007bfc:	dfc00515 	stw	ra,20(sp)
 4007c00:	df000415 	stw	fp,16(sp)
 4007c04:	df000404 	addi	fp,sp,16
 4007c08:	e13ffd15 	stw	r4,-12(fp)
 4007c0c:	e17ffc15 	stw	r5,-16(fp)
  alt_dev* next = (alt_dev*) llist->next;
 4007c10:	e0bffc17 	ldw	r2,-16(fp)
 4007c14:	10800017 	ldw	r2,0(r2)
 4007c18:	e0bfff15 	stw	r2,-4(fp)
  alt_32 len;

  len  = strlen(name) + 1;
 4007c1c:	e13ffd17 	ldw	r4,-12(fp)
 4007c20:	4007f800 	call	4007f80 <strlen>
 4007c24:	10800044 	addi	r2,r2,1
 4007c28:	e0bffe15 	stw	r2,-8(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 4007c2c:	00000d06 	br	4007c64 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
 4007c30:	e0bfff17 	ldw	r2,-4(fp)
 4007c34:	10800217 	ldw	r2,8(r2)
 4007c38:	e0fffe17 	ldw	r3,-8(fp)
 4007c3c:	180d883a 	mov	r6,r3
 4007c40:	e17ffd17 	ldw	r5,-12(fp)
 4007c44:	1009883a 	mov	r4,r2
 4007c48:	4007f080 	call	4007f08 <memcmp>
 4007c4c:	1000021e 	bne	r2,zero,4007c58 <alt_find_dev+0x60>
    {
      /* match found */

      return next;
 4007c50:	e0bfff17 	ldw	r2,-4(fp)
 4007c54:	00000706 	br	4007c74 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
 4007c58:	e0bfff17 	ldw	r2,-4(fp)
 4007c5c:	10800017 	ldw	r2,0(r2)
 4007c60:	e0bfff15 	stw	r2,-4(fp)
  while (next != (alt_dev*) llist)
 4007c64:	e0ffff17 	ldw	r3,-4(fp)
 4007c68:	e0bffc17 	ldw	r2,-16(fp)
 4007c6c:	18bff01e 	bne	r3,r2,4007c30 <alt_find_dev+0x38>
  }
  
  /* No match found */
  
  return NULL;
 4007c70:	0005883a 	mov	r2,zero
}
 4007c74:	e037883a 	mov	sp,fp
 4007c78:	dfc00117 	ldw	ra,4(sp)
 4007c7c:	df000017 	ldw	fp,0(sp)
 4007c80:	dec00204 	addi	sp,sp,8
 4007c84:	f800283a 	ret

04007c88 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
 4007c88:	defffb04 	addi	sp,sp,-20
 4007c8c:	dfc00415 	stw	ra,16(sp)
 4007c90:	df000315 	stw	fp,12(sp)
 4007c94:	df000304 	addi	fp,sp,12
 4007c98:	e13ffd15 	stw	r4,-12(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
 4007c9c:	d0a00217 	ldw	r2,-32760(gp)
 4007ca0:	e0bfff15 	stw	r2,-4(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 4007ca4:	00003106 	br	4007d6c <alt_find_file+0xe4>
  {
    len = strlen(next->name);
 4007ca8:	e0bfff17 	ldw	r2,-4(fp)
 4007cac:	10800217 	ldw	r2,8(r2)
 4007cb0:	1009883a 	mov	r4,r2
 4007cb4:	4007f800 	call	4007f80 <strlen>
 4007cb8:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
 4007cbc:	e0bfff17 	ldw	r2,-4(fp)
 4007cc0:	10c00217 	ldw	r3,8(r2)
 4007cc4:	e0bffe17 	ldw	r2,-8(fp)
 4007cc8:	10bfffc4 	addi	r2,r2,-1
 4007ccc:	1885883a 	add	r2,r3,r2
 4007cd0:	10800003 	ldbu	r2,0(r2)
 4007cd4:	10803fcc 	andi	r2,r2,255
 4007cd8:	1080201c 	xori	r2,r2,128
 4007cdc:	10bfe004 	addi	r2,r2,-128
 4007ce0:	10800bd8 	cmpnei	r2,r2,47
 4007ce4:	1000031e 	bne	r2,zero,4007cf4 <alt_find_file+0x6c>
    {
      len -= 1;
 4007ce8:	e0bffe17 	ldw	r2,-8(fp)
 4007cec:	10bfffc4 	addi	r2,r2,-1
 4007cf0:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 4007cf4:	e0bffe17 	ldw	r2,-8(fp)
 4007cf8:	e0fffd17 	ldw	r3,-12(fp)
 4007cfc:	1885883a 	add	r2,r3,r2
 4007d00:	10800003 	ldbu	r2,0(r2)
 4007d04:	10803fcc 	andi	r2,r2,255
 4007d08:	1080201c 	xori	r2,r2,128
 4007d0c:	10bfe004 	addi	r2,r2,-128
 4007d10:	10800be0 	cmpeqi	r2,r2,47
 4007d14:	1000081e 	bne	r2,zero,4007d38 <alt_find_file+0xb0>
 4007d18:	e0bffe17 	ldw	r2,-8(fp)
 4007d1c:	e0fffd17 	ldw	r3,-12(fp)
 4007d20:	1885883a 	add	r2,r3,r2
 4007d24:	10800003 	ldbu	r2,0(r2)
 4007d28:	10803fcc 	andi	r2,r2,255
 4007d2c:	1080201c 	xori	r2,r2,128
 4007d30:	10bfe004 	addi	r2,r2,-128
 4007d34:	10000a1e 	bne	r2,zero,4007d60 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
 4007d38:	e0bfff17 	ldw	r2,-4(fp)
 4007d3c:	10800217 	ldw	r2,8(r2)
 4007d40:	e0fffe17 	ldw	r3,-8(fp)
 4007d44:	180d883a 	mov	r6,r3
 4007d48:	e17ffd17 	ldw	r5,-12(fp)
 4007d4c:	1009883a 	mov	r4,r2
 4007d50:	4007f080 	call	4007f08 <memcmp>
    if (((name[len] == '/') || (name[len] == '\0')) && 
 4007d54:	1000021e 	bne	r2,zero,4007d60 <alt_find_file+0xd8>
    {
      /* match found */

      return next;
 4007d58:	e0bfff17 	ldw	r2,-4(fp)
 4007d5c:	00000706 	br	4007d7c <alt_find_file+0xf4>
    }
    next = (alt_dev*) next->llist.next;
 4007d60:	e0bfff17 	ldw	r2,-4(fp)
 4007d64:	10800017 	ldw	r2,0(r2)
 4007d68:	e0bfff15 	stw	r2,-4(fp)
  while (next != (alt_dev*) &alt_fs_list)
 4007d6c:	e0ffff17 	ldw	r3,-4(fp)
 4007d70:	d0a00204 	addi	r2,gp,-32760
 4007d74:	18bfcc1e 	bne	r3,r2,4007ca8 <alt_find_file+0x20>
  }
  
  /* No match found */
  
  return NULL;     
 4007d78:	0005883a 	mov	r2,zero
}
 4007d7c:	e037883a 	mov	sp,fp
 4007d80:	dfc00117 	ldw	ra,4(sp)
 4007d84:	df000017 	ldw	fp,0(sp)
 4007d88:	dec00204 	addi	sp,sp,8
 4007d8c:	f800283a 	ret

04007d90 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
 4007d90:	defffc04 	addi	sp,sp,-16
 4007d94:	df000315 	stw	fp,12(sp)
 4007d98:	df000304 	addi	fp,sp,12
 4007d9c:	e13ffd15 	stw	r4,-12(fp)
  alt_32 i;
  int rc = -EMFILE;
 4007da0:	00bffa04 	movi	r2,-24
 4007da4:	e0bffe15 	stw	r2,-8(fp)
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 4007da8:	e03fff15 	stw	zero,-4(fp)
 4007dac:	00001706 	br	4007e0c <alt_get_fd+0x7c>
  {
    if (!alt_fd_list[i].dev)
 4007db0:	e0bfff17 	ldw	r2,-4(fp)
 4007db4:	10c00324 	muli	r3,r2,12
 4007db8:	00810074 	movhi	r2,1025
 4007dbc:	1885883a 	add	r2,r3,r2
 4007dc0:	10a4b517 	ldw	r2,-27948(r2)
 4007dc4:	10000e1e 	bne	r2,zero,4007e00 <alt_get_fd+0x70>
    {
      alt_fd_list[i].dev = dev;
 4007dc8:	e0bfff17 	ldw	r2,-4(fp)
 4007dcc:	11000324 	muli	r4,r2,12
 4007dd0:	e0fffd17 	ldw	r3,-12(fp)
 4007dd4:	00810074 	movhi	r2,1025
 4007dd8:	2085883a 	add	r2,r4,r2
 4007ddc:	10e4b515 	stw	r3,-27948(r2)
      if (i > alt_max_fd)
 4007de0:	d0e00617 	ldw	r3,-32744(gp)
 4007de4:	e0bfff17 	ldw	r2,-4(fp)
 4007de8:	1880020e 	bge	r3,r2,4007df4 <alt_get_fd+0x64>
      {
        alt_max_fd = i;
 4007dec:	e0bfff17 	ldw	r2,-4(fp)
 4007df0:	d0a00615 	stw	r2,-32744(gp)
      }
      rc = i;
 4007df4:	e0bfff17 	ldw	r2,-4(fp)
 4007df8:	e0bffe15 	stw	r2,-8(fp)
      goto alt_get_fd_exit;
 4007dfc:	00000706 	br	4007e1c <alt_get_fd+0x8c>
  for (i = 0; i < ALT_MAX_FD; i++)
 4007e00:	e0bfff17 	ldw	r2,-4(fp)
 4007e04:	10800044 	addi	r2,r2,1
 4007e08:	e0bfff15 	stw	r2,-4(fp)
 4007e0c:	e0bfff17 	ldw	r2,-4(fp)
 4007e10:	10800810 	cmplti	r2,r2,32
 4007e14:	103fe61e 	bne	r2,zero,4007db0 <alt_get_fd+0x20>
    }
  }

 alt_get_fd_exit:
 4007e18:	0001883a 	nop
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
 4007e1c:	e0bffe17 	ldw	r2,-8(fp)
}
 4007e20:	e037883a 	mov	sp,fp
 4007e24:	df000017 	ldw	fp,0(sp)
 4007e28:	dec00104 	addi	sp,sp,4
 4007e2c:	f800283a 	ret

04007e30 <alt_icache_flush>:
 * alt_icache_flush() is called to flush the instruction cache for a memory
 * region of length "len" bytes, starting at address "start".
 */

void alt_icache_flush (void* start, alt_u32 len)
{
 4007e30:	defffb04 	addi	sp,sp,-20
 4007e34:	df000415 	stw	fp,16(sp)
 4007e38:	df000404 	addi	fp,sp,16
 4007e3c:	e13ffd15 	stw	r4,-12(fp)
 4007e40:	e17ffc15 	stw	r5,-16(fp)

  /*
   * This is the most we would ever need to flush.
   */
 
  if (len > NIOS2_ICACHE_SIZE)
 4007e44:	e0bffc17 	ldw	r2,-16(fp)
 4007e48:	10840070 	cmpltui	r2,r2,4097
 4007e4c:	1000021e 	bne	r2,zero,4007e58 <alt_icache_flush+0x28>
  {
    len = NIOS2_ICACHE_SIZE;
 4007e50:	00840004 	movi	r2,4096
 4007e54:	e0bffc15 	stw	r2,-16(fp)
  }

  end = ((char*) start) + len;
 4007e58:	e0fffd17 	ldw	r3,-12(fp)
 4007e5c:	e0bffc17 	ldw	r2,-16(fp)
 4007e60:	1885883a 	add	r2,r3,r2
 4007e64:	e0bffe15 	stw	r2,-8(fp)

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
 4007e68:	e0bffd17 	ldw	r2,-12(fp)
 4007e6c:	e0bfff15 	stw	r2,-4(fp)
 4007e70:	00000506 	br	4007e88 <alt_icache_flush+0x58>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
 4007e74:	e0bfff17 	ldw	r2,-4(fp)
 4007e78:	1000603a 	flushi	r2
  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
 4007e7c:	e0bfff17 	ldw	r2,-4(fp)
 4007e80:	10800804 	addi	r2,r2,32
 4007e84:	e0bfff15 	stw	r2,-4(fp)
 4007e88:	e0ffff17 	ldw	r3,-4(fp)
 4007e8c:	e0bffe17 	ldw	r2,-8(fp)
 4007e90:	18bff836 	bltu	r3,r2,4007e74 <alt_icache_flush+0x44>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
 4007e94:	e0bffd17 	ldw	r2,-12(fp)
 4007e98:	108007cc 	andi	r2,r2,31
 4007e9c:	10000226 	beq	r2,zero,4007ea8 <alt_icache_flush+0x78>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
 4007ea0:	e0bfff17 	ldw	r2,-4(fp)
 4007ea4:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
 4007ea8:	0000203a 	flushp

#endif /* NIOS2_ICACHE_SIZE > 0 */
}
 4007eac:	0001883a 	nop
 4007eb0:	e037883a 	mov	sp,fp
 4007eb4:	df000017 	ldw	fp,0(sp)
 4007eb8:	dec00104 	addi	sp,sp,4
 4007ebc:	f800283a 	ret

04007ec0 <atexit>:
 4007ec0:	200b883a 	mov	r5,r4
 4007ec4:	000f883a 	mov	r7,zero
 4007ec8:	000d883a 	mov	r6,zero
 4007ecc:	0009883a 	mov	r4,zero
 4007ed0:	40080181 	jmpi	4008018 <__register_exitproc>

04007ed4 <exit>:
 4007ed4:	defffe04 	addi	sp,sp,-8
 4007ed8:	000b883a 	mov	r5,zero
 4007edc:	dc000015 	stw	r16,0(sp)
 4007ee0:	dfc00115 	stw	ra,4(sp)
 4007ee4:	2021883a 	mov	r16,r4
 4007ee8:	40080a80 	call	40080a8 <__call_exitprocs>
 4007eec:	00810074 	movhi	r2,1025
 4007ef0:	11262817 	ldw	r4,-26464(r2)
 4007ef4:	20800f17 	ldw	r2,60(r4)
 4007ef8:	10000126 	beq	r2,zero,4007f00 <exit+0x2c>
 4007efc:	103ee83a 	callr	r2
 4007f00:	8009883a 	mov	r4,r16
 4007f04:	40081c80 	call	40081c8 <_exit>

04007f08 <memcmp>:
 4007f08:	30800130 	cmpltui	r2,r6,4
 4007f0c:	10000b1e 	bne	r2,zero,4007f3c <memcmp+0x34>
 4007f10:	2144b03a 	or	r2,r4,r5
 4007f14:	108000cc 	andi	r2,r2,3
 4007f18:	1000171e 	bne	r2,zero,4007f78 <memcmp+0x70>
 4007f1c:	20c00017 	ldw	r3,0(r4)
 4007f20:	28800017 	ldw	r2,0(r5)
 4007f24:	1880141e 	bne	r3,r2,4007f78 <memcmp+0x70>
 4007f28:	31bfff04 	addi	r6,r6,-4
 4007f2c:	30800128 	cmpgeui	r2,r6,4
 4007f30:	21000104 	addi	r4,r4,4
 4007f34:	29400104 	addi	r5,r5,4
 4007f38:	103ff81e 	bne	r2,zero,4007f1c <memcmp+0x14>
 4007f3c:	30bfffc4 	addi	r2,r6,-1
 4007f40:	30000b26 	beq	r6,zero,4007f70 <memcmp+0x68>
 4007f44:	11800044 	addi	r6,r2,1
 4007f48:	298d883a 	add	r6,r5,r6
 4007f4c:	00000106 	br	4007f54 <memcmp+0x4c>
 4007f50:	29800726 	beq	r5,r6,4007f70 <memcmp+0x68>
 4007f54:	20800003 	ldbu	r2,0(r4)
 4007f58:	28c00003 	ldbu	r3,0(r5)
 4007f5c:	21000044 	addi	r4,r4,1
 4007f60:	29400044 	addi	r5,r5,1
 4007f64:	10fffa26 	beq	r2,r3,4007f50 <memcmp+0x48>
 4007f68:	10c5c83a 	sub	r2,r2,r3
 4007f6c:	f800283a 	ret
 4007f70:	0005883a 	mov	r2,zero
 4007f74:	f800283a 	ret
 4007f78:	30bfffc4 	addi	r2,r6,-1
 4007f7c:	003ff106 	br	4007f44 <memcmp+0x3c>

04007f80 <strlen>:
 4007f80:	208000cc 	andi	r2,r4,3
 4007f84:	10000926 	beq	r2,zero,4007fac <strlen+0x2c>
 4007f88:	2005883a 	mov	r2,r4
 4007f8c:	00000306 	br	4007f9c <strlen+0x1c>
 4007f90:	10800044 	addi	r2,r2,1
 4007f94:	10c000cc 	andi	r3,r2,3
 4007f98:	18000526 	beq	r3,zero,4007fb0 <strlen+0x30>
 4007f9c:	10c00007 	ldb	r3,0(r2)
 4007fa0:	183ffb1e 	bne	r3,zero,4007f90 <strlen+0x10>
 4007fa4:	1105c83a 	sub	r2,r2,r4
 4007fa8:	f800283a 	ret
 4007fac:	2005883a 	mov	r2,r4
 4007fb0:	11400017 	ldw	r5,0(r2)
 4007fb4:	01ffbff4 	movhi	r7,65279
 4007fb8:	39ffbfc4 	addi	r7,r7,-257
 4007fbc:	29c7883a 	add	r3,r5,r7
 4007fc0:	01a02074 	movhi	r6,32897
 4007fc4:	014a303a 	nor	r5,zero,r5
 4007fc8:	1946703a 	and	r3,r3,r5
 4007fcc:	31a02004 	addi	r6,r6,-32640
 4007fd0:	1986703a 	and	r3,r3,r6
 4007fd4:	1800071e 	bne	r3,zero,4007ff4 <strlen+0x74>
 4007fd8:	11400117 	ldw	r5,4(r2)
 4007fdc:	10800104 	addi	r2,r2,4
 4007fe0:	29c7883a 	add	r3,r5,r7
 4007fe4:	014a303a 	nor	r5,zero,r5
 4007fe8:	1946703a 	and	r3,r3,r5
 4007fec:	1986703a 	and	r3,r3,r6
 4007ff0:	183ff926 	beq	r3,zero,4007fd8 <strlen+0x58>
 4007ff4:	10c00007 	ldb	r3,0(r2)
 4007ff8:	183fea26 	beq	r3,zero,4007fa4 <strlen+0x24>
 4007ffc:	10c00047 	ldb	r3,1(r2)
 4008000:	10800044 	addi	r2,r2,1
 4008004:	183fe726 	beq	r3,zero,4007fa4 <strlen+0x24>
 4008008:	10c00047 	ldb	r3,1(r2)
 400800c:	10800044 	addi	r2,r2,1
 4008010:	183ffa1e 	bne	r3,zero,4007ffc <strlen+0x7c>
 4008014:	003fe306 	br	4007fa4 <strlen+0x24>

04008018 <__register_exitproc>:
 4008018:	00810074 	movhi	r2,1025
 400801c:	10e62817 	ldw	r3,-26464(r2)
 4008020:	18805217 	ldw	r2,328(r3)
 4008024:	10001726 	beq	r2,zero,4008084 <__register_exitproc+0x6c>
 4008028:	10c00117 	ldw	r3,4(r2)
 400802c:	1a000808 	cmpgei	r8,r3,32
 4008030:	40001b1e 	bne	r8,zero,40080a0 <__register_exitproc+0x88>
 4008034:	20000b26 	beq	r4,zero,4008064 <__register_exitproc+0x4c>
 4008038:	181090ba 	slli	r8,r3,2
 400803c:	02400044 	movi	r9,1
 4008040:	48d2983a 	sll	r9,r9,r3
 4008044:	1211883a 	add	r8,r2,r8
 4008048:	41802215 	stw	r6,136(r8)
 400804c:	11806217 	ldw	r6,392(r2)
 4008050:	21000098 	cmpnei	r4,r4,2
 4008054:	324cb03a 	or	r6,r6,r9
 4008058:	11806215 	stw	r6,392(r2)
 400805c:	41c04215 	stw	r7,264(r8)
 4008060:	20000b26 	beq	r4,zero,4008090 <__register_exitproc+0x78>
 4008064:	19000084 	addi	r4,r3,2
 4008068:	200890ba 	slli	r4,r4,2
 400806c:	18c00044 	addi	r3,r3,1
 4008070:	10c00115 	stw	r3,4(r2)
 4008074:	1105883a 	add	r2,r2,r4
 4008078:	11400015 	stw	r5,0(r2)
 400807c:	0005883a 	mov	r2,zero
 4008080:	f800283a 	ret
 4008084:	18805304 	addi	r2,r3,332
 4008088:	18805215 	stw	r2,328(r3)
 400808c:	003fe606 	br	4008028 <__register_exitproc+0x10>
 4008090:	11006317 	ldw	r4,396(r2)
 4008094:	2252b03a 	or	r9,r4,r9
 4008098:	12406315 	stw	r9,396(r2)
 400809c:	003ff106 	br	4008064 <__register_exitproc+0x4c>
 40080a0:	00bfffc4 	movi	r2,-1
 40080a4:	f800283a 	ret

040080a8 <__call_exitprocs>:
 40080a8:	defff704 	addi	sp,sp,-36
 40080ac:	00810074 	movhi	r2,1025
 40080b0:	dcc00315 	stw	r19,12(sp)
 40080b4:	14e62817 	ldw	r19,-26464(r2)
 40080b8:	dc800215 	stw	r18,8(sp)
 40080bc:	dfc00815 	stw	ra,32(sp)
 40080c0:	9c805217 	ldw	r18,328(r19)
 40080c4:	ddc00715 	stw	r23,28(sp)
 40080c8:	dd800615 	stw	r22,24(sp)
 40080cc:	dd400515 	stw	r21,20(sp)
 40080d0:	dd000415 	stw	r20,16(sp)
 40080d4:	dc400115 	stw	r17,4(sp)
 40080d8:	dc000015 	stw	r16,0(sp)
 40080dc:	90001026 	beq	r18,zero,4008120 <__call_exitprocs+0x78>
 40080e0:	202b883a 	mov	r21,r4
 40080e4:	282d883a 	mov	r22,r5
 40080e8:	05000044 	movi	r20,1
 40080ec:	94000117 	ldw	r16,4(r18)
 40080f0:	847fffc4 	addi	r17,r16,-1
 40080f4:	88000a16 	blt	r17,zero,4008120 <__call_exitprocs+0x78>
 40080f8:	84000044 	addi	r16,r16,1
 40080fc:	802090ba 	slli	r16,r16,2
 4008100:	9421883a 	add	r16,r18,r16
 4008104:	b0001126 	beq	r22,zero,400814c <__call_exitprocs+0xa4>
 4008108:	80804017 	ldw	r2,256(r16)
 400810c:	15800f26 	beq	r2,r22,400814c <__call_exitprocs+0xa4>
 4008110:	8c7fffc4 	addi	r17,r17,-1
 4008114:	88bfffd8 	cmpnei	r2,r17,-1
 4008118:	843fff04 	addi	r16,r16,-4
 400811c:	103ff91e 	bne	r2,zero,4008104 <__call_exitprocs+0x5c>
 4008120:	dfc00817 	ldw	ra,32(sp)
 4008124:	ddc00717 	ldw	r23,28(sp)
 4008128:	dd800617 	ldw	r22,24(sp)
 400812c:	dd400517 	ldw	r21,20(sp)
 4008130:	dd000417 	ldw	r20,16(sp)
 4008134:	dcc00317 	ldw	r19,12(sp)
 4008138:	dc800217 	ldw	r18,8(sp)
 400813c:	dc400117 	ldw	r17,4(sp)
 4008140:	dc000017 	ldw	r16,0(sp)
 4008144:	dec00904 	addi	sp,sp,36
 4008148:	f800283a 	ret
 400814c:	90800117 	ldw	r2,4(r18)
 4008150:	81800017 	ldw	r6,0(r16)
 4008154:	10bfffc4 	addi	r2,r2,-1
 4008158:	14401726 	beq	r2,r17,40081b8 <__call_exitprocs+0x110>
 400815c:	80000015 	stw	zero,0(r16)
 4008160:	303feb26 	beq	r6,zero,4008110 <__call_exitprocs+0x68>
 4008164:	a446983a 	sll	r3,r20,r17
 4008168:	90806217 	ldw	r2,392(r18)
 400816c:	95c00117 	ldw	r23,4(r18)
 4008170:	1884703a 	and	r2,r3,r2
 4008174:	1000081e 	bne	r2,zero,4008198 <__call_exitprocs+0xf0>
 4008178:	303ee83a 	callr	r6
 400817c:	90c00117 	ldw	r3,4(r18)
 4008180:	98805217 	ldw	r2,328(r19)
 4008184:	1dc0011e 	bne	r3,r23,400818c <__call_exitprocs+0xe4>
 4008188:	90bfe126 	beq	r18,r2,4008110 <__call_exitprocs+0x68>
 400818c:	103fe426 	beq	r2,zero,4008120 <__call_exitprocs+0x78>
 4008190:	1025883a 	mov	r18,r2
 4008194:	003fd506 	br	40080ec <__call_exitprocs+0x44>
 4008198:	90806317 	ldw	r2,396(r18)
 400819c:	81002017 	ldw	r4,128(r16)
 40081a0:	1886703a 	and	r3,r3,r2
 40081a4:	1800061e 	bne	r3,zero,40081c0 <__call_exitprocs+0x118>
 40081a8:	200b883a 	mov	r5,r4
 40081ac:	a809883a 	mov	r4,r21
 40081b0:	303ee83a 	callr	r6
 40081b4:	003ff106 	br	400817c <__call_exitprocs+0xd4>
 40081b8:	94400115 	stw	r17,4(r18)
 40081bc:	003fe806 	br	4008160 <__call_exitprocs+0xb8>
 40081c0:	303ee83a 	callr	r6
 40081c4:	003fed06 	br	400817c <__call_exitprocs+0xd4>

040081c8 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
 40081c8:	defffd04 	addi	sp,sp,-12
 40081cc:	df000215 	stw	fp,8(sp)
 40081d0:	df000204 	addi	fp,sp,8
 40081d4:	e13ffe15 	stw	r4,-8(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
 40081d8:	0001883a 	nop
 40081dc:	e0bffe17 	ldw	r2,-8(fp)
 40081e0:	e0bfff15 	stw	r2,-4(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
 40081e4:	e0bfff17 	ldw	r2,-4(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
 40081e8:	10000226 	beq	r2,zero,40081f4 <_exit+0x2c>
    ALT_SIM_FAIL();
 40081ec:	002af070 	cmpltui	zero,zero,43969
  } else {
    ALT_SIM_PASS();
  }
#endif /* DEBUG_STUB */
}
 40081f0:	00000106 	br	40081f8 <_exit+0x30>
    ALT_SIM_PASS();
 40081f4:	002af0b0 	cmpltui	zero,zero,43970
}
 40081f8:	0001883a 	nop
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
 40081fc:	003fff06 	br	40081fc <_exit+0x34>
